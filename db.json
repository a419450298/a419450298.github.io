{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.png","path":"img/favicon.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/me.png","path":"img/me.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1}],"Cache":[{"_id":"source/_posts/Npm包管理工具私有化.md","hash":"2f8770ea9d1b8c7684d770c48069021023e02fa2","modified":1668921337977},{"_id":"source/_posts/WebRTC阶段一.md","hash":"4490bf8db1b8b64e788402129e1ff0e1ce677884","modified":1668921337977},{"_id":"source/_posts/ffmpeg常用命令.md","hash":"5bc128bfea70ab72f0abaaf45b448aafb8d63a87","modified":1668921337977},{"_id":"source/_posts/vue2中常用属性.md","hash":"2ba9d62ab5c4c0fa1170889a7ecb43ccb8005fee","modified":1668921337978},{"_id":"source/_posts/vue-cli配置说明.md","hash":"6954f85f2e0dbb328ec83c5c0f83f08783b9f8f3","modified":1668921337977},{"_id":"source/_posts/vue中引入外部js文件.md","hash":"7705c8d0dea0d5567c2827f87b09dab2b96d3fe9","modified":1668921337978},{"_id":"source/_posts/关于Tomcat无法加载jsp标签原因排查及说明.md","hash":"3c0a63077cded3c59d169d611b2888075f21e2f4","modified":1683132343687},{"_id":"source/_posts/yapi的使用.md","hash":"a2aecf7f907ed580b03f991105e3b873ef605768","modified":1668921337978},{"_id":"source/_posts/前端监控.md","hash":"475e36bc09cc3a1708c9ce075415b1e6a6a6bae3","modified":1668921337978},{"_id":"source/_posts/报错合集及解决办法.md","hash":"b1cf75740d07647acde87c6b5335085f10009e13","modified":1668921337978},{"_id":"source/_posts/同时安装一个包的多个版本.md","hash":"aaf0e5773e06d91b862663ae0d10cc000e916049","modified":1668921337978},{"_id":"source/_posts/大前端基础复习.md","hash":"f9c8945484bb78eaa1b427bb37e4082f2d10adff","modified":1683132366836},{"_id":"source/_posts/搭建samba服务实现文件共享.md","hash":"b55b76dcbd5fbfc73d161c63fff861fd95d88bdc","modified":1674869185725},{"_id":"source/_posts/没有tts用怎么办.md","hash":"9173146525053306917375e46c19366cabe5d7a8","modified":1683132353621},{"_id":"source/_posts/越来越卷之java学习.md","hash":"6f1b76f30b40b04c12648d1acd5c4c061c1a8695","modified":1668921337979},{"_id":"source/about/index.md","hash":"49df00cb6d0ddd7bb4aab4f38a1043c0224ed8f1","modified":1683135050726},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1668921337998},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1668921337980},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1668921337980},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1668921337981},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1668921337981},{"_id":"themes/fluid/README.md","hash":"2ec6a89d66f8e41fded68aa8ec3b3363a20ea48c","modified":1668921337982},{"_id":"themes/fluid/package.json","hash":"2716fb0ceeeb195737cfedecb86ab9bd24dda84f","modified":1668921337990},{"_id":"themes/fluid/README_en.md","hash":"10ff41f4b3cf24ad0fece6555b77f61694916133","modified":1668921337982},{"_id":"themes/fluid/_config.yml","hash":"868b83c9c976cd50d04ff16928d2e309a2f5dc41","modified":1674333326022},{"_id":"themes/fluid/layout/404.ejs","hash":"0a589faccde6c2c9572e8d3d359e7c8fb166335e","modified":1668921337983},{"_id":"themes/fluid/layout/about.ejs","hash":"a35a03e0b845b651e6e89d9c94e422cefa274799","modified":1668921337989},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1668921337989},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1668921337989},{"_id":"themes/fluid/layout/index.ejs","hash":"4bd6d432638e480106729c1f2fea61a53943641a","modified":1668921337989},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1668921337989},{"_id":"themes/fluid/layout/links.ejs","hash":"c1ff0f0f559ccd201f442789c0a62c324ded7b99","modified":1668921337990},{"_id":"themes/fluid/layout/layout.ejs","hash":"e8c590216835d51e5cc1622e5931d5149bc27b1c","modified":1668921337990},{"_id":"themes/fluid/layout/page.ejs","hash":"9084b88139f4535449578a00012208cc7ee50f76","modified":1668921337990},{"_id":"themes/fluid/layout/post.ejs","hash":"1c6b13c5d2d44cf40af87bdd3c1a24e4af9229bb","modified":1668921337990},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1668921337990},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1668921337990},{"_id":"themes/fluid/languages/de.yml","hash":"c52ce73a291fa50953edbd11c1dfb1cc7cab52c2","modified":1668921337982},{"_id":"themes/fluid/languages/en.yml","hash":"2839da328f197cf90cafdf2b538fcd027ab6cfba","modified":1668921337983},{"_id":"themes/fluid/languages/eo.yml","hash":"76d2920b49c8d2489c37514489545d0fc4eac834","modified":1668921337983},{"_id":"themes/fluid/languages/es.yml","hash":"7fcd16cd363f1a166a3270c23c0660eff7475744","modified":1668921337983},{"_id":"themes/fluid/languages/ja.yml","hash":"411aa49e2e8dea90a6d8cc2dc92f264609ea273b","modified":1668921337983},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"b05d1a43516dc6886d65631d90d6995acae673db","modified":1668921337983},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"676b3ee8a16d796b4a898a9e5be2f52c372055ed","modified":1668921337983},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"aac765cccef9f9044c4a88941fd01ba1883178fc","modified":1668921337983},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1668921337981},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1668921337981},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"beb3474d6f65c1e56700ba872c6a0d0836d4168e","modified":1668921337980},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1668921337980},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1668921337980},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"78ce211415d502c5a4398d786d5c697d34d868b9","modified":1668921337980},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"18381d03518526d7cefd024a0bdd8d9e7c6440f5","modified":1668921337981},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1668921337981},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1668921337983},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"bd763ffc145a1f0b2c4a5dc8a101f0bc94b3f2f7","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"bfea4674af78eb72b3a6baaa7ec9fc3c3db55ebd","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1668921337983},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"70646e7f7a7684e12b298cd8a36fbea2814c3635","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"52b8954ae0eff5eb66a3841b37f144336b8f0866","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7dc65c5022e5f9c07790a7f038213f1da5ae5f4b","modified":1683128523135},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"6f8351fe3c0e44fdbb1d3646ce3cd240dbc28fc7","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"4a80c71775081708bbb5526dcf9f703fad4c37ef","modified":1668921337989},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1668921337989},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1668921337990},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1668921337991},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1668921337992},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"1c9156e12030fa2219a933edde460ec563836047","modified":1668921337992},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"a2a15ea722863aba09dcad578558432682a3b6b3","modified":1668921337992},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"bda7fbe58082a2a02c0db066794b791b14462271","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"00a41768fe258bb8f3323bf4bb0b862d6e2d97c0","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"a93b87835bfa491fa2aa90f97f25281e3a4ffed9","modified":1668921337992},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1668921337993},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"d7ff7cf5e721dfeafe0c2a77a5929b2c3f8fee2a","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"aa03d0b914d87b9194ee3a0612ab5827a8dedbdd","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1668921337993},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"9c01393f446c490c56b6b0d482aaa8d97cc8b717","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1668921337993},{"_id":"themes/fluid/scripts/tags/note.js","hash":"8020acc2c4bb3a2054e3cb349fac7cd10b79a0be","modified":1668921337993},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1668921337994},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1668921337994},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1668921337994},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1668921337994},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1668921337999},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1668921337999},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1668921337999},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1668921337999},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1668921337999},{"_id":"themes/fluid/source/img/favicon.png","hash":"a397f7c6d429fdccf6d426d6f856298e1f441c6f","modified":1668921338005},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1668921338005},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1668921338013},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1668921338006},{"_id":"themes/fluid/source/js/boot.js","hash":"94fc698c8703e5e4d9a47fb8827cb862b0db8c3c","modified":1668921338014},{"_id":"themes/fluid/source/js/color-schema.js","hash":"a475da20540788c3c14ccd8b99f361529b0d4be2","modified":1668921338014},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1668921338014},{"_id":"themes/fluid/source/js/leancloud.js","hash":"5de1ea082e7797d35de7d22fbbc65b6fc416327d","modified":1668921338014},{"_id":"themes/fluid/source/js/local-search.js","hash":"1ab61ed47ec88c876e447872342fed9be560b0f0","modified":1668921338014},{"_id":"themes/fluid/source/js/events.js","hash":"7d70feed0a19e3d9f5886416ae99a72e21e2f10c","modified":1668921338014},{"_id":"themes/fluid/source/js/plugins.js","hash":"bb0ede596b4c61a7cc20bfdf4b4e029743059230","modified":1668921338015},{"_id":"themes/fluid/source/js/utils.js","hash":"1835b78a650e944d549e057a248d8afcb0088189","modified":1668921338015},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1668921338015},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1674338106154},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"1568d377cd1d214be50a6560197c185ead0f7740","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1668921337984},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"99fe072ec17e83332325b3c59464bd39ea1f5a96","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1668921337985},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"4c8647402f1ad72e28a96b331c80761529f00779","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"ed2348bd9f56d19836b508c52ce9cc9122471f51","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"1560b1ca7f1f40fe1e18047ab68a3576f6613619","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"486807aee6b4685a79dec3713c474d9a92090123","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"3b31e068f394c3f63a98843711e64ac4af463fef","modified":1668921337986},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"4d1950988da0cff04f1fbdad639661ce32c30ecd","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"43b8dd8a697200321fb80ac3c6b1184b06cbc469","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"fedcfb5de65c0828f6925d60a758e0c79a45396f","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"7bf29bd9faf12030e19993576299936a999c0e46","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"eac44cfb6b0843304b2da35b32b0fa24afd9d7f9","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1668921337987},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"9605ce21f964f33b440c9384462ca53f049c5dd0","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f9c0f25eee37cc6e72a5fbefb2cd7284a9fd16d7","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"cef058fd6f33651118b5bdaa3c814757f5c82154","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1668921337988},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"ac544baecc05df96c6558d42b57af219e1d59e52","modified":1668921337988},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1668921337990},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"c9efdd41b8606969e5b55f49a2f6df596641b995","modified":1668921337991},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"ccad5aeca9bf61a9a374d8d8955e57c40425920e","modified":1668921337991},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"fcc64d572a65b450788f7736606ef6cd8d4ca820","modified":1668921337991},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1668921337991},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1668921337991},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1668921337991},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1668921337994},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1668921337994},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1668921337998},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"3654f8fe02a7bd7860904821b4c586ec04b0c05b","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1668921337994},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"577f3289d7f3851d4eeb867db3d92f1313a431da","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"7f95c49025a347605c726b0874fe074d888e1cc2","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"1546709897ae49a4ecaf66c39b86f48cbdc377b3","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1668921337997},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"3cf445be358f1283a14b07a61b5a1e8515e09dfc","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"b524a157d95b91a724668026887dac4c2f3edab9","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"e8801b3fc396ba0a30590702e06343b02dff5377","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"e8fe053ef8734e54fae12e46acd0087bcd67f8a2","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1668921337998},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"30f50446609d49c896e92a89225591b606adc863","modified":1668921337995},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"fc5aa415a6d648f8524bb42b50369afa7f8b9099","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1668921337996},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1668921337996},{"_id":"themes/fluid/source/img/me.png","hash":"461b90e1a9a7d49747e2012f91f2d2b69d2dc5b1","modified":1668921338013},{"_id":"themes/fluid/source/img/default.png","hash":"df6556fea41ad1bff1fee796d9593e6d8da83144","modified":1668921338005},{"_id":"public/local-search.xml","hash":"ce6892b00ae6a8f9de5fbcae5cc9e03be3ec7179","modified":1691935830468},{"_id":"public/about/index.html","hash":"9e023453f5bb63dd71b67032c19cf4f6da709d0b","modified":1691935830468},{"_id":"public/archives/index.html","hash":"80134b0dee35a92b355c8dc3d11dc4d6cf149cd0","modified":1691935830468},{"_id":"public/archives/page/2/index.html","hash":"29a6cc19a587faafc9f8b955a8280939fdac05f2","modified":1691935830468},{"_id":"public/archives/2021/index.html","hash":"8522e1c9a9a2da457e44207acdd731efa9b151da","modified":1691935830468},{"_id":"public/archives/2021/page/2/index.html","hash":"d5662c950dde359b3c56458a3eb9e1310a0963e1","modified":1691935830468},{"_id":"public/archives/2021/09/index.html","hash":"7c2e838a3d998f95bf7b1512f8453a31e012da13","modified":1691935830468},{"_id":"public/archives/2021/10/index.html","hash":"02022e6d962b70de4a10e73e4a71a86a54a674fc","modified":1691935830468},{"_id":"public/archives/2021/12/index.html","hash":"a39ecf321fcd33946982853485eddce86b0cb3e1","modified":1691935830468},{"_id":"public/archives/2022/index.html","hash":"44e8664a35cc1d456ccd9572d241e1603b7dd912","modified":1691935830468},{"_id":"public/archives/2022/06/index.html","hash":"d97b239d20d715ff84883e9075cc8874826fc26f","modified":1691935830468},{"_id":"public/archives/2023/index.html","hash":"7a7238945f5deeace6b5c2dd7394e0705da24da9","modified":1691935830468},{"_id":"public/archives/2023/01/index.html","hash":"02aaee54975d66fa96508c24b5ff2bd58d70aa7e","modified":1691935830468},{"_id":"public/archives/2023/03/index.html","hash":"eb3f1afa8a63dfa9c78aa4da0c194852af32f779","modified":1691935830468},{"_id":"public/categories/WebRTC/index.html","hash":"a22b2162fa004c69c45f36584dc3b12372bf0fe9","modified":1691935830468},{"_id":"public/categories/视频处理/index.html","hash":"eb669cb40f4bc13ad7f54584c3eebe0bc1c6888c","modified":1691935830468},{"_id":"public/categories/知识复习/index.html","hash":"c9ad11bfdb2c00201309ef39d947438de03e905f","modified":1691935830468},{"_id":"public/categories/工具的使用/index.html","hash":"8f135afd59419dda243c45dd7a98445c0909434a","modified":1691935830468},{"_id":"public/categories/报错解决集合/index.html","hash":"be2f1e5bbea75d7dbbfd7b3db2bfcd6955dd28a0","modified":1691935830468},{"_id":"public/categories/前端监控/index.html","hash":"2cc36387c219e8899f25179dcad0579e97c0f800","modified":1691935830468},{"_id":"public/categories/环境搭建/index.html","hash":"5f9f6172aeaa8ecf9023d9d73e282d6efc1f30aa","modified":1691935830468},{"_id":"public/categories/DevOps/index.html","hash":"b2597afef442092bafdc78295e9061225b5f28fd","modified":1691935830468},{"_id":"public/categories/音频处理/index.html","hash":"60bd65620715e0f0a2c4f6ece4430ac5aa1361ac","modified":1691935830468},{"_id":"public/categories/Java/index.html","hash":"180b1e32006cc9305b4bdcca89477ff4a71210dc","modified":1691935830468},{"_id":"public/tags/webrtc/index.html","hash":"f571704ef6fbca2c6ea64dfbbc1b1434239c52f6","modified":1691935830468},{"_id":"public/tags/工具/index.html","hash":"03adde8a587877fb7173f34f9b5ffeb21d71e3cf","modified":1691935830468},{"_id":"public/tags/vue2/index.html","hash":"86a1b8cc8e456c7733fb998d29f2121029dcbb72","modified":1691935830468},{"_id":"public/tags/工作中问题/index.html","hash":"9abb2546634753de2004553f42a75843c61820d7","modified":1691935830468},{"_id":"public/tags/js/index.html","hash":"a1463978b05dcfd9068ca4041503f158aea1aa41","modified":1691935830468},{"_id":"public/tags/环境搭建/index.html","hash":"dbf40f30c38922dd2845c1c2bb1751e6a691fee9","modified":1691935830468},{"_id":"public/tags/报错集合/index.html","hash":"ed498cc4a176c015de822508418f03a5e4c8cba1","modified":1691935830468},{"_id":"public/tags/DevOps/index.html","hash":"256f3684db4ba4d662abafe0d965687cfb3044f9","modified":1691935830468},{"_id":"public/tags/Java/index.html","hash":"dadb157df2af0f1c79b53d8cb2135af9f2442d7f","modified":1691935830468},{"_id":"public/404.html","hash":"023b3be3649d73acfa9a28173fce307814749cfc","modified":1691935830468},{"_id":"public/tags/index.html","hash":"f59cbd3ea39b07611a37f0377c3eac03300ec682","modified":1691935830468},{"_id":"public/links/index.html","hash":"5479448c89d3bde181b1aacbfd672a6636e92230","modified":1691935830468},{"_id":"public/2023/03/06/没有tts用怎么办/index.html","hash":"3e129a1e8d84fff0b00c34e614eb7ed236f4beb4","modified":1691935830468},{"_id":"public/2023/03/06/关于Tomcat无法加载jsp标签原因排查及说明/index.html","hash":"de347149daaae099bb9eb178f930dfad7e7e5eeb","modified":1691935830468},{"_id":"public/2023/01/28/搭建samba服务实现文件共享/index.html","hash":"d89f2134a6c3649fecee192fa101512c4dbaeb57","modified":1691935830468},{"_id":"public/2022/06/01/前端监控/index.html","hash":"bc1886994dec8360227f668aa67d2d3b03fba5fb","modified":1691935830468},{"_id":"public/2021/12/04/ffmpeg常用命令/index.html","hash":"1d0fc58a98afd39f6d13efb4eeda85c4a818b1a2","modified":1691935830468},{"_id":"public/2021/10/28/vue中引入外部js文件/index.html","hash":"8bab23b161a5e3cca5e4d1890eca4cfe40a21ea6","modified":1691935830468},{"_id":"public/2021/10/28/越来越卷之java学习/index.html","hash":"0acb17832885a959fe84f511c3086dc79030dc53","modified":1691935830468},{"_id":"public/2021/10/20/vue-cli配置说明/index.html","hash":"f9ea2ce2163545234d6abbf47f48d50ca72ec841","modified":1691935830468},{"_id":"public/2021/10/18/vue2中常用属性/index.html","hash":"08e363762a772ca057b42ed1798e2e36cf3cf015","modified":1691935830468},{"_id":"public/2021/10/11/Npm包管理工具私有化/index.html","hash":"6b442d52803e74fd6f50e3202e0c00846fea8b3c","modified":1691935830468},{"_id":"public/2021/10/08/报错合集及解决办法/index.html","hash":"f57b8e6aeb621f1b84c5198ded09dfdb4f16bfd9","modified":1691935830468},{"_id":"public/2021/10/05/WebRTC阶段一/index.html","hash":"3e38d180bef6c557fb37ccee3608a61e15d503ce","modified":1691935830468},{"_id":"public/2021/09/30/同时安装一个包的多个版本/index.html","hash":"8803bc9b4db2059dd7240b31fb1c055fc578cb20","modified":1691935830468},{"_id":"public/2021/09/30/大前端基础复习/index.html","hash":"64c17d76302779ca7d7acbf9cb9fccb97b496ecd","modified":1691935830468},{"_id":"public/2021/09/26/yapi的使用/index.html","hash":"c6f2f3679d1a1ae73e599224e26d78ba89c49c41","modified":1691935830468},{"_id":"public/index.html","hash":"1243e020fd066758a24cf62f56cae531bfc060c1","modified":1691935830468},{"_id":"public/page/2/index.html","hash":"c4903b2282b2fd45572f7fb1ecec4dec8126032c","modified":1691935830468},{"_id":"public/categories/index.html","hash":"d8ce302ecf6e5fa66fa776526914085d6118e8a9","modified":1691935830468},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1691935830468},{"_id":"public/img/favicon.png","hash":"a397f7c6d429fdccf6d426d6f856298e1f441c6f","modified":1691935830468},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1691935830468},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1691935830468},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1691935830468},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1691935830468},{"_id":"public/live2dw/lib/L2Dwidget.min.js","hash":"5f1a807437cc723bcadc3791d37add5ceed566a2","modified":1691935830468},{"_id":"public/live2dw/lib/L2Dwidget.min.js.map","hash":"3290fe2df45f065b51a1cd7b24ec325cbf9bb5ce","modified":1691935830468},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js","hash":"35bb5b588b6de25c9be2dd51d3fd331feafac02d","modified":1691935830468},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1691935830468},{"_id":"public/css/highlight-dark.css","hash":"fdaf3f62244b6518f7dc5b7e22c7521213f2081e","modified":1691935830468},{"_id":"public/js/boot.js","hash":"6b7319b36ca2e2d3afe336623ef438994f3d26de","modified":1691935830468},{"_id":"public/css/highlight.css","hash":"6e2f8edcc875b4d8e0cf5f2610e6e908bf9b51b1","modified":1691935830468},{"_id":"public/js/color-schema.js","hash":"781e5c82556f279f99c97ffd13f359bd1a445145","modified":1691935830468},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1691935830468},{"_id":"public/js/events.js","hash":"f05a569a9fd6da2fda69a2cf8e276ba81580faf3","modified":1691935830468},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1691935830468},{"_id":"public/js/plugins.js","hash":"b4ca98f68bf09a74678932e4ac73ac56a7c01e03","modified":1691935830468},{"_id":"public/js/leancloud.js","hash":"ed23208de670d7a5900f2669cc715e2479885958","modified":1691935830468},{"_id":"public/js/utils.js","hash":"d49d462f8547de07ca49e1ea195dff864b08706b","modified":1691935830468},{"_id":"public/css/main.css","hash":"c0b9b11fd1c609d95eb804c7cf7770eba22c2e39","modified":1691935830468},{"_id":"public/live2dw/lib/L2Dwidget.0.min.js.map","hash":"35e71cc2a130199efb167b9a06939576602f0d75","modified":1691935830468},{"_id":"public/img/me.png","hash":"461b90e1a9a7d49747e2012f91f2d2b69d2dc5b1","modified":1691935830468},{"_id":"public/img/default.png","hash":"df6556fea41ad1bff1fee796d9593e6d8da83144","modified":1691935830468}],"Category":[{"name":"WebRTC","_id":"cll9ivvew0003b0gidksp8eqt"},{"name":"视频处理","_id":"cll9ivvez0008b0giadktb1zm"},{"name":"知识复习","_id":"cll9ivvf1000eb0gibado6f9a"},{"name":"工具的使用","_id":"cll9ivvf5000qb0gi5jm9f9dn"},{"name":"报错解决集合","_id":"cll9ivvf80016b0gie0oc1tb1"},{"name":"前端监控","_id":"cll9ivvf9001bb0gi5ey656ni"},{"name":"环境搭建","_id":"cll9ivvf9001fb0gi959j7ax5"},{"name":"DevOps","_id":"cll9ivvfa001mb0gi5394e81d"},{"name":"音频处理","_id":"cll9ivvfb001qb0gi45tncag5"},{"name":"Java","_id":"cll9ivvfb001sb0gi3mo23pfl"}],"Data":[],"Page":[{"title":"about","date":"2021-09-24T09:17:52.000Z","layout":"about","_content":"\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&id=1384026889&auto=1&height=66\"></iframe>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=442620244&bvid=BV1rL411e79L&cid=1097533197&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<p align=\"right\">邮箱：stoneleost@163.com</p>\n\n{% gaodeMap 114.87,22.60, 双月湾在惠东县港口镇，整个海湾从空中俯瞰好像两轮背对的新月，故名双月湾。双月湾的奇特之处在于，这里左湾水平如镜，右湾波涛汹涌，一静一动。相对于不远的巽寮湾，算是一个还没被过度开发的景点。, 16 %}\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2021-09-24 17:17:52\nlayout: about\n---\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&id=1384026889&auto=1&height=66\"></iframe>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=442620244&bvid=BV1rL411e79L&cid=1097533197&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<p align=\"right\">邮箱：stoneleost@163.com</p>\n\n{% gaodeMap 114.87,22.60, 双月湾在惠东县港口镇，整个海湾从空中俯瞰好像两轮背对的新月，故名双月湾。双月湾的奇特之处在于，这里左湾水平如镜，右湾波涛汹涌，一静一动。相对于不远的巽寮湾，算是一个还没被过度开发的景点。, 16 %}\n\n","updated":"2023-05-03T17:30:50.726Z","path":"about/index.html","comments":1,"_id":"cll9ivveq0000b0gid3002iaj","content":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&id=1384026889&auto=1&height=66\"></iframe>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=442620244&bvid=BV1rL411e79L&cid=1097533197&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<p align=\"right\">邮箱：stoneleost@163.com</p>\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css\"><script data-pjax src=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js\"></script><script data-pjax src=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js\"></script><div class=\"map-box\"><div id=\"gaodeMap-114.87-22.60\" style=\"max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;\"></div></div><script type=\"text/javascript\">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={\"高德地图\":normal,\"高德卫星地图\":imgm,\"高德卫星标注\":image};var mymap=L.map('gaodeMap-114.87-22.60',{center:[22.60,114.87],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['22.60','114.87']).addTo(mymap);marker.bindPopup(\"双月湾在惠东县港口镇，整个海湾从空中俯瞰好像两轮背对的新月，故名双月湾。双月湾的奇特之处在于，这里左湾水平如镜，右湾波涛汹涌，一静一动。相对于不远的巽寮湾，算是一个还没被过度开发的景点。\").openPopup();</script>\n\n","site":{"data":{}},"wordcount":845,"excerpt":"","more":"<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=100% height=86 src=\"//music.163.com/outchain/player?type=2&id=1384026889&auto=1&height=66\"></iframe>\n\n<div style=\"position: relative; width: 100%; height: 0; padding-bottom: 75%;\"><iframe \nsrc=\"//player.bilibili.com/player.html?aid=442620244&bvid=BV1rL411e79L&cid=1097533197&page=1\" scrolling=\"no\" border=\"0\" \nframeborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" style=\"position: absolute; width: 100%; \nheight: 100%; left: 0; top: 0;\"> </iframe></div>\n\n<p align=\"right\">邮箱：stoneleost@163.com</p>\n\n<link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.css\"><script data-pjax src=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet@1.7.1.js\"></script><script data-pjax src=\"https://cdn.jsdelivr.net/npm/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js\"></script><div class=\"map-box\"><div id=\"gaodeMap-114.87-22.60\" style=\"max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;\"></div></div><script type=\"text/javascript\">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'Amap'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'Amap'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={\"高德地图\":normal,\"高德卫星地图\":imgm,\"高德卫星标注\":image};var mymap=L.map('gaodeMap-114.87-22.60',{center:[22.60,114.87],zoom:16,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['22.60','114.87']).addTo(mymap);marker.bindPopup(\"双月湾在惠东县港口镇，整个海湾从空中俯瞰好像两轮背对的新月，故名双月湾。双月湾的奇特之处在于，这里左湾水平如镜，右湾波涛汹涌，一静一动。相对于不远的巽寮湾，算是一个还没被过度开发的景点。\").openPopup();</script>\n\n"}],"Post":[{"title":"WebRTC阶段一","date":"2021-10-05T04:57:23.000Z","_content":"\n## webRTC概述\n\n音视频处理 + 即时通讯的开源库\n\n2010年Google将其收购\n\n它是一个非常优秀的多媒体框架，跨平台\n\n## WebRTC能做啥\n\n音视频实时互动\n\n游戏，即时通讯，文字传输等等\n\n它是一个百宝箱，传输，音视频处理（回音降噪，降噪等）\n\n音视频设备访问与管理\n\n音视频数据的采集\n\n数据的传输与实时互动\n\n## WebRTC的工作机制\n\n![](https://z3.ax1x.com/2021/10/05/4vIMmF.png)\n\n## 架构组件\n\n### Your Web App\n\nWeb开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。\n\n### Web API\n\n面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用，需要注意的是可能在不同浏览器中API接口名会不太一样, 所以推荐使用这个JS适配器来协调各个浏览器的不同接口。 这些API可分成Media API、 RTCPeerConnection、Peer-to-peer Data API三类:\n\n### Media API\n\nMediaStream：MediaStream用来表示一个媒体数据流。 MediaStreamTrack：在浏览器中表示一个媒体源。\n\n### RTCPeerConnection\n\nRTCPeerConnection：一个RTCPeerConnection对象允许用户在两个浏览器之间直接通讯。 SDP: 用来描述当前连接者想要传输的内容，支持的协议类型，支持的编解码类型等。 RTCIceCandidate：表示一个ICE协议的候选者，简单的说，就是目标节点的IP以及端口。 RTCIceServer：表示一个ICE Server，其主要用于当前主机的IP发现，通过和ICE Server通讯，我们会得到一组可供连接使用的IP:Port候选值，双方通过交换ICE候选值来建立起连接。\n\n### Peer-to-peer Data API\n\nDataChannel：数据通道( DataChannel)接口表示一个在两个节点之间的双向的数据通道，该通道可以设置成可靠传输或非可靠传输 。\n\n### WebRTC Native C++ API\n\n本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。\n\n### Transport / Session\n\n传输部分可基于TCP/UDP，会话层组件采用了libjingle库的部分组件实现\n\n### AudioEngine\n\n音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。\n\n### VideoEngine\n\n视频引擎是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。\n\n## 通讯内容的确立\n\n首先，两个客户端（Alice & Bob）想要创建连接，一般来说需要有一个双方都能访问的服务器来帮助他们交换连接所需要的信息。有了交换数据的中间人之后，他们首先要交换的数据是SessionDescription（SD），这里面描述了连接双方想要建立怎样的连接。 \n\n![](https://z3.ax1x.com/2021/10/05/4v5zSP.jpg)\n\n## WebRTC的目录结构\n\nwebrtc windows 目录结构，不过都差不多\n\n#### 根目录： \n\n| 目录         | 功能                                                   |\n| ------------ | ------------------------------------------------------ |\n| api          | WebRTC接口层，浏览器都是通过该接口调用webRTC           |\n| call         | 数据流的管理层，Call代表同一个端点的所有数据的流入流出 |\n| video        | 与视频相关的逻辑                                       |\n| audio        | 与音频相关的逻辑                                       |\n| common_audio | 音频算法相关                                           |\n| common_video | 视频算法相关                                           |\n| media        | 与多媒体相关的逻辑处理，如编解码的逻辑处理             |\n| logging      | 日志相关                                               |\n| module       | 最重要的目录，子模块                                   |\n| pc           | Peer Connection,链接相关的逻辑层                       |\n| p2p          | 端对端相关代码,stun,turn                               |\n| rtc_base     | 基础代码，如线程，锁相关的统一接口代码                 |\n| rtc_tool     | 音视频分析相关的工具代码                               |\n| tool_webrtc  | WebRTC测试相关的工具代码。如CPU特性,原子操作等         |\n| stats        | 存放各类数据统计相关的类                               |\n| sdk          | 存放Android和IOS层代码。如视频采集，渲染等             |\n|              |                                                        |\n\nvideo_capture:\n\nwindows 上webrtc采用的是dshow技术，实现枚举视频的设备信息和视频数据的采集，这意味着可以支持大多数的视频采集设备；对那些需要单独驱动程序的视频采集卡（比如海康高清卡）就无能为力了。  （别买HIK的摄像头）\n\nvideo_coding:\n\nWebRTC采用I420/VP8编解码技术。VP8是google收购ON2后的开源实现，并且也用在WebM项目中。VP8能以更少的数据提供更高质量的视频，特别适合视频会议这样的需求。  (VP8压缩率实际不如h264,webrtc处理264的时候有问题，以后说)\n\nvideo_processing:\n\n 视频图像处理针对每一帧的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。\n\n#### 子目录：\n\n| 目录                     | 功能                                         |\n| ------------------------ | -------------------------------------------- |\n| audio_coding             | 音频编解码相关代码                           |\n| audio_device             | 音频采集与音频播放相关代码 （设备相关）      |\n| audio_mixer              | 混音相关代码（多人实时互动，要混在一起传输） |\n| audio_processing         | 音频先后处理的相关代码（轨迹消除，降噪）     |\n| bitrate_controller       | 码率控制相关代码（码流500k，1M）             |\n| congestion_controller    | 流控相关代码(流量控制)                       |\n| desktop_capture          | 桌面采集相关代码                             |\n| pacing                   | 码率探测及平滑处理相关的代码                 |\n| remote_bitrate_estimator | 码率探测及平滑处理相关的代码                 |\n| rtp_rtcp                 | rtp/rtcp协议相关的代码                       |\n| video_capture            | 视频采集相关的代码                           |\n| video_coding             | 视频编解码相关的代码                         |\n| video_processing         | 视频前后处理相关的代码                       |\n\n## webRTC的运行机制\n\n### 轨与流\n\nTrack :一路轨是平行且不相交的音频轨，视频轨 \n\nMediaStream: 借鉴了传统的媒体流的概念\n\n### WebRTC重要类\n\nMediaStream (包含很多轨)\n\nRTCPeerConnection   (最重要的类  里面包含了一些大而全的类，对于应用层来说将MediaStream塞到RTCPeerConnection   就好了，重点掌握) \n\nRTCDataChannel（普通的二进制数据通过PeerConnection获取，再通过DataChannel塞到PeerConnection中去）\n\n### PeerConnection调用过程\n\n![](https://z3.ax1x.com/2021/10/05/4v0pEF.png)\n\n### 调用时序图\n\n![](https://z3.ax1x.com/2021/10/05/4vBxkF.png)\n\n![](https://z3.ax1x.com/2021/10/05/4vRdm9.png)\n","source":"_posts/WebRTC阶段一.md","raw":"---\ntitle: WebRTC阶段一\ndate: 2021-10-05 12:57:23\ntags: webrtc\ncategories:\n- WebRTC\n---\n\n## webRTC概述\n\n音视频处理 + 即时通讯的开源库\n\n2010年Google将其收购\n\n它是一个非常优秀的多媒体框架，跨平台\n\n## WebRTC能做啥\n\n音视频实时互动\n\n游戏，即时通讯，文字传输等等\n\n它是一个百宝箱，传输，音视频处理（回音降噪，降噪等）\n\n音视频设备访问与管理\n\n音视频数据的采集\n\n数据的传输与实时互动\n\n## WebRTC的工作机制\n\n![](https://z3.ax1x.com/2021/10/05/4vIMmF.png)\n\n## 架构组件\n\n### Your Web App\n\nWeb开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。\n\n### Web API\n\n面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用，需要注意的是可能在不同浏览器中API接口名会不太一样, 所以推荐使用这个JS适配器来协调各个浏览器的不同接口。 这些API可分成Media API、 RTCPeerConnection、Peer-to-peer Data API三类:\n\n### Media API\n\nMediaStream：MediaStream用来表示一个媒体数据流。 MediaStreamTrack：在浏览器中表示一个媒体源。\n\n### RTCPeerConnection\n\nRTCPeerConnection：一个RTCPeerConnection对象允许用户在两个浏览器之间直接通讯。 SDP: 用来描述当前连接者想要传输的内容，支持的协议类型，支持的编解码类型等。 RTCIceCandidate：表示一个ICE协议的候选者，简单的说，就是目标节点的IP以及端口。 RTCIceServer：表示一个ICE Server，其主要用于当前主机的IP发现，通过和ICE Server通讯，我们会得到一组可供连接使用的IP:Port候选值，双方通过交换ICE候选值来建立起连接。\n\n### Peer-to-peer Data API\n\nDataChannel：数据通道( DataChannel)接口表示一个在两个节点之间的双向的数据通道，该通道可以设置成可靠传输或非可靠传输 。\n\n### WebRTC Native C++ API\n\n本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。\n\n### Transport / Session\n\n传输部分可基于TCP/UDP，会话层组件采用了libjingle库的部分组件实现\n\n### AudioEngine\n\n音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。\n\n### VideoEngine\n\n视频引擎是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。\n\n## 通讯内容的确立\n\n首先，两个客户端（Alice & Bob）想要创建连接，一般来说需要有一个双方都能访问的服务器来帮助他们交换连接所需要的信息。有了交换数据的中间人之后，他们首先要交换的数据是SessionDescription（SD），这里面描述了连接双方想要建立怎样的连接。 \n\n![](https://z3.ax1x.com/2021/10/05/4v5zSP.jpg)\n\n## WebRTC的目录结构\n\nwebrtc windows 目录结构，不过都差不多\n\n#### 根目录： \n\n| 目录         | 功能                                                   |\n| ------------ | ------------------------------------------------------ |\n| api          | WebRTC接口层，浏览器都是通过该接口调用webRTC           |\n| call         | 数据流的管理层，Call代表同一个端点的所有数据的流入流出 |\n| video        | 与视频相关的逻辑                                       |\n| audio        | 与音频相关的逻辑                                       |\n| common_audio | 音频算法相关                                           |\n| common_video | 视频算法相关                                           |\n| media        | 与多媒体相关的逻辑处理，如编解码的逻辑处理             |\n| logging      | 日志相关                                               |\n| module       | 最重要的目录，子模块                                   |\n| pc           | Peer Connection,链接相关的逻辑层                       |\n| p2p          | 端对端相关代码,stun,turn                               |\n| rtc_base     | 基础代码，如线程，锁相关的统一接口代码                 |\n| rtc_tool     | 音视频分析相关的工具代码                               |\n| tool_webrtc  | WebRTC测试相关的工具代码。如CPU特性,原子操作等         |\n| stats        | 存放各类数据统计相关的类                               |\n| sdk          | 存放Android和IOS层代码。如视频采集，渲染等             |\n|              |                                                        |\n\nvideo_capture:\n\nwindows 上webrtc采用的是dshow技术，实现枚举视频的设备信息和视频数据的采集，这意味着可以支持大多数的视频采集设备；对那些需要单独驱动程序的视频采集卡（比如海康高清卡）就无能为力了。  （别买HIK的摄像头）\n\nvideo_coding:\n\nWebRTC采用I420/VP8编解码技术。VP8是google收购ON2后的开源实现，并且也用在WebM项目中。VP8能以更少的数据提供更高质量的视频，特别适合视频会议这样的需求。  (VP8压缩率实际不如h264,webrtc处理264的时候有问题，以后说)\n\nvideo_processing:\n\n 视频图像处理针对每一帧的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。\n\n#### 子目录：\n\n| 目录                     | 功能                                         |\n| ------------------------ | -------------------------------------------- |\n| audio_coding             | 音频编解码相关代码                           |\n| audio_device             | 音频采集与音频播放相关代码 （设备相关）      |\n| audio_mixer              | 混音相关代码（多人实时互动，要混在一起传输） |\n| audio_processing         | 音频先后处理的相关代码（轨迹消除，降噪）     |\n| bitrate_controller       | 码率控制相关代码（码流500k，1M）             |\n| congestion_controller    | 流控相关代码(流量控制)                       |\n| desktop_capture          | 桌面采集相关代码                             |\n| pacing                   | 码率探测及平滑处理相关的代码                 |\n| remote_bitrate_estimator | 码率探测及平滑处理相关的代码                 |\n| rtp_rtcp                 | rtp/rtcp协议相关的代码                       |\n| video_capture            | 视频采集相关的代码                           |\n| video_coding             | 视频编解码相关的代码                         |\n| video_processing         | 视频前后处理相关的代码                       |\n\n## webRTC的运行机制\n\n### 轨与流\n\nTrack :一路轨是平行且不相交的音频轨，视频轨 \n\nMediaStream: 借鉴了传统的媒体流的概念\n\n### WebRTC重要类\n\nMediaStream (包含很多轨)\n\nRTCPeerConnection   (最重要的类  里面包含了一些大而全的类，对于应用层来说将MediaStream塞到RTCPeerConnection   就好了，重点掌握) \n\nRTCDataChannel（普通的二进制数据通过PeerConnection获取，再通过DataChannel塞到PeerConnection中去）\n\n### PeerConnection调用过程\n\n![](https://z3.ax1x.com/2021/10/05/4v0pEF.png)\n\n### 调用时序图\n\n![](https://z3.ax1x.com/2021/10/05/4vBxkF.png)\n\n![](https://z3.ax1x.com/2021/10/05/4vRdm9.png)\n","slug":"WebRTC阶段一","published":1,"updated":"2022-11-20T05:15:37.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivves0001b0gi3mj44z40","content":"<h2 id=\"webRTC概述\"><a href=\"#webRTC概述\" class=\"headerlink\" title=\"webRTC概述\"></a>webRTC概述</h2><p>音视频处理 + 即时通讯的开源库</p>\n<p>2010年Google将其收购</p>\n<p>它是一个非常优秀的多媒体框架，跨平台</p>\n<h2 id=\"WebRTC能做啥\"><a href=\"#WebRTC能做啥\" class=\"headerlink\" title=\"WebRTC能做啥\"></a>WebRTC能做啥</h2><p>音视频实时互动</p>\n<p>游戏，即时通讯，文字传输等等</p>\n<p>它是一个百宝箱，传输，音视频处理（回音降噪，降噪等）</p>\n<p>音视频设备访问与管理</p>\n<p>音视频数据的采集</p>\n<p>数据的传输与实时互动</p>\n<h2 id=\"WebRTC的工作机制\"><a href=\"#WebRTC的工作机制\" class=\"headerlink\" title=\"WebRTC的工作机制\"></a>WebRTC的工作机制</h2><p><img src=\"https://z3.ax1x.com/2021/10/05/4vIMmF.png\"></p>\n<h2 id=\"架构组件\"><a href=\"#架构组件\" class=\"headerlink\" title=\"架构组件\"></a>架构组件</h2><h3 id=\"Your-Web-App\"><a href=\"#Your-Web-App\" class=\"headerlink\" title=\"Your Web App\"></a>Your Web App</h3><p>Web开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。</p>\n<h3 id=\"Web-API\"><a href=\"#Web-API\" class=\"headerlink\" title=\"Web API\"></a>Web API</h3><p>面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用，需要注意的是可能在不同浏览器中API接口名会不太一样, 所以推荐使用这个JS适配器来协调各个浏览器的不同接口。 这些API可分成Media API、 RTCPeerConnection、Peer-to-peer Data API三类:</p>\n<h3 id=\"Media-API\"><a href=\"#Media-API\" class=\"headerlink\" title=\"Media API\"></a>Media API</h3><p>MediaStream：MediaStream用来表示一个媒体数据流。 MediaStreamTrack：在浏览器中表示一个媒体源。</p>\n<h3 id=\"RTCPeerConnection\"><a href=\"#RTCPeerConnection\" class=\"headerlink\" title=\"RTCPeerConnection\"></a>RTCPeerConnection</h3><p>RTCPeerConnection：一个RTCPeerConnection对象允许用户在两个浏览器之间直接通讯。 SDP: 用来描述当前连接者想要传输的内容，支持的协议类型，支持的编解码类型等。 RTCIceCandidate：表示一个ICE协议的候选者，简单的说，就是目标节点的IP以及端口。 RTCIceServer：表示一个ICE Server，其主要用于当前主机的IP发现，通过和ICE Server通讯，我们会得到一组可供连接使用的IP:Port候选值，双方通过交换ICE候选值来建立起连接。</p>\n<h3 id=\"Peer-to-peer-Data-API\"><a href=\"#Peer-to-peer-Data-API\" class=\"headerlink\" title=\"Peer-to-peer Data API\"></a>Peer-to-peer Data API</h3><p>DataChannel：数据通道( DataChannel)接口表示一个在两个节点之间的双向的数据通道，该通道可以设置成可靠传输或非可靠传输 。</p>\n<h3 id=\"WebRTC-Native-C-API\"><a href=\"#WebRTC-Native-C-API\" class=\"headerlink\" title=\"WebRTC Native C++ API\"></a>WebRTC Native C++ API</h3><p>本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。</p>\n<h3 id=\"Transport-Session\"><a href=\"#Transport-Session\" class=\"headerlink\" title=\"Transport / Session\"></a>Transport / Session</h3><p>传输部分可基于TCP/UDP，会话层组件采用了libjingle库的部分组件实现</p>\n<h3 id=\"AudioEngine\"><a href=\"#AudioEngine\" class=\"headerlink\" title=\"AudioEngine\"></a>AudioEngine</h3><p>音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。</p>\n<h3 id=\"VideoEngine\"><a href=\"#VideoEngine\" class=\"headerlink\" title=\"VideoEngine\"></a>VideoEngine</h3><p>视频引擎是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。</p>\n<h2 id=\"通讯内容的确立\"><a href=\"#通讯内容的确立\" class=\"headerlink\" title=\"通讯内容的确立\"></a>通讯内容的确立</h2><p>首先，两个客户端（Alice &amp; Bob）想要创建连接，一般来说需要有一个双方都能访问的服务器来帮助他们交换连接所需要的信息。有了交换数据的中间人之后，他们首先要交换的数据是SessionDescription（SD），这里面描述了连接双方想要建立怎样的连接。 </p>\n<p><img src=\"https://z3.ax1x.com/2021/10/05/4v5zSP.jpg\"></p>\n<h2 id=\"WebRTC的目录结构\"><a href=\"#WebRTC的目录结构\" class=\"headerlink\" title=\"WebRTC的目录结构\"></a>WebRTC的目录结构</h2><p>webrtc windows 目录结构，不过都差不多</p>\n<h4 id=\"根目录：\"><a href=\"#根目录：\" class=\"headerlink\" title=\"根目录：\"></a>根目录：</h4><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>api</td>\n<td>WebRTC接口层，浏览器都是通过该接口调用webRTC</td>\n</tr>\n<tr>\n<td>call</td>\n<td>数据流的管理层，Call代表同一个端点的所有数据的流入流出</td>\n</tr>\n<tr>\n<td>video</td>\n<td>与视频相关的逻辑</td>\n</tr>\n<tr>\n<td>audio</td>\n<td>与音频相关的逻辑</td>\n</tr>\n<tr>\n<td>common_audio</td>\n<td>音频算法相关</td>\n</tr>\n<tr>\n<td>common_video</td>\n<td>视频算法相关</td>\n</tr>\n<tr>\n<td>media</td>\n<td>与多媒体相关的逻辑处理，如编解码的逻辑处理</td>\n</tr>\n<tr>\n<td>logging</td>\n<td>日志相关</td>\n</tr>\n<tr>\n<td>module</td>\n<td>最重要的目录，子模块</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>Peer Connection,链接相关的逻辑层</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td>端对端相关代码,stun,turn</td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td>基础代码，如线程，锁相关的统一接口代码</td>\n</tr>\n<tr>\n<td>rtc_tool</td>\n<td>音视频分析相关的工具代码</td>\n</tr>\n<tr>\n<td>tool_webrtc</td>\n<td>WebRTC测试相关的工具代码。如CPU特性,原子操作等</td>\n</tr>\n<tr>\n<td>stats</td>\n<td>存放各类数据统计相关的类</td>\n</tr>\n<tr>\n<td>sdk</td>\n<td>存放Android和IOS层代码。如视频采集，渲染等</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>video_capture:</p>\n<p>windows 上webrtc采用的是dshow技术，实现枚举视频的设备信息和视频数据的采集，这意味着可以支持大多数的视频采集设备；对那些需要单独驱动程序的视频采集卡（比如海康高清卡）就无能为力了。  （别买HIK的摄像头）</p>\n<p>video_coding:</p>\n<p>WebRTC采用I420/VP8编解码技术。VP8是google收购ON2后的开源实现，并且也用在WebM项目中。VP8能以更少的数据提供更高质量的视频，特别适合视频会议这样的需求。  (VP8压缩率实际不如h264,webrtc处理264的时候有问题，以后说)</p>\n<p>video_processing:</p>\n<p> 视频图像处理针对每一帧的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。</p>\n<h4 id=\"子目录：\"><a href=\"#子目录：\" class=\"headerlink\" title=\"子目录：\"></a>子目录：</h4><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>audio_coding</td>\n<td>音频编解码相关代码</td>\n</tr>\n<tr>\n<td>audio_device</td>\n<td>音频采集与音频播放相关代码 （设备相关）</td>\n</tr>\n<tr>\n<td>audio_mixer</td>\n<td>混音相关代码（多人实时互动，要混在一起传输）</td>\n</tr>\n<tr>\n<td>audio_processing</td>\n<td>音频先后处理的相关代码（轨迹消除，降噪）</td>\n</tr>\n<tr>\n<td>bitrate_controller</td>\n<td>码率控制相关代码（码流500k，1M）</td>\n</tr>\n<tr>\n<td>congestion_controller</td>\n<td>流控相关代码(流量控制)</td>\n</tr>\n<tr>\n<td>desktop_capture</td>\n<td>桌面采集相关代码</td>\n</tr>\n<tr>\n<td>pacing</td>\n<td>码率探测及平滑处理相关的代码</td>\n</tr>\n<tr>\n<td>remote_bitrate_estimator</td>\n<td>码率探测及平滑处理相关的代码</td>\n</tr>\n<tr>\n<td>rtp_rtcp</td>\n<td>rtp/rtcp协议相关的代码</td>\n</tr>\n<tr>\n<td>video_capture</td>\n<td>视频采集相关的代码</td>\n</tr>\n<tr>\n<td>video_coding</td>\n<td>视频编解码相关的代码</td>\n</tr>\n<tr>\n<td>video_processing</td>\n<td>视频前后处理相关的代码</td>\n</tr>\n</tbody></table>\n<h2 id=\"webRTC的运行机制\"><a href=\"#webRTC的运行机制\" class=\"headerlink\" title=\"webRTC的运行机制\"></a>webRTC的运行机制</h2><h3 id=\"轨与流\"><a href=\"#轨与流\" class=\"headerlink\" title=\"轨与流\"></a>轨与流</h3><p>Track :一路轨是平行且不相交的音频轨，视频轨 </p>\n<p>MediaStream: 借鉴了传统的媒体流的概念</p>\n<h3 id=\"WebRTC重要类\"><a href=\"#WebRTC重要类\" class=\"headerlink\" title=\"WebRTC重要类\"></a>WebRTC重要类</h3><p>MediaStream (包含很多轨)</p>\n<p>RTCPeerConnection   (最重要的类  里面包含了一些大而全的类，对于应用层来说将MediaStream塞到RTCPeerConnection   就好了，重点掌握) </p>\n<p>RTCDataChannel（普通的二进制数据通过PeerConnection获取，再通过DataChannel塞到PeerConnection中去）</p>\n<h3 id=\"PeerConnection调用过程\"><a href=\"#PeerConnection调用过程\" class=\"headerlink\" title=\"PeerConnection调用过程\"></a>PeerConnection调用过程</h3><p><img src=\"https://z3.ax1x.com/2021/10/05/4v0pEF.png\"></p>\n<h3 id=\"调用时序图\"><a href=\"#调用时序图\" class=\"headerlink\" title=\"调用时序图\"></a>调用时序图</h3><p><img src=\"https://z3.ax1x.com/2021/10/05/4vBxkF.png\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/10/05/4vRdm9.png\"></p>\n","site":{"data":{}},"wordcount":2585,"excerpt":"","more":"<h2 id=\"webRTC概述\"><a href=\"#webRTC概述\" class=\"headerlink\" title=\"webRTC概述\"></a>webRTC概述</h2><p>音视频处理 + 即时通讯的开源库</p>\n<p>2010年Google将其收购</p>\n<p>它是一个非常优秀的多媒体框架，跨平台</p>\n<h2 id=\"WebRTC能做啥\"><a href=\"#WebRTC能做啥\" class=\"headerlink\" title=\"WebRTC能做啥\"></a>WebRTC能做啥</h2><p>音视频实时互动</p>\n<p>游戏，即时通讯，文字传输等等</p>\n<p>它是一个百宝箱，传输，音视频处理（回音降噪，降噪等）</p>\n<p>音视频设备访问与管理</p>\n<p>音视频数据的采集</p>\n<p>数据的传输与实时互动</p>\n<h2 id=\"WebRTC的工作机制\"><a href=\"#WebRTC的工作机制\" class=\"headerlink\" title=\"WebRTC的工作机制\"></a>WebRTC的工作机制</h2><p><img src=\"https://z3.ax1x.com/2021/10/05/4vIMmF.png\"></p>\n<h2 id=\"架构组件\"><a href=\"#架构组件\" class=\"headerlink\" title=\"架构组件\"></a>架构组件</h2><h3 id=\"Your-Web-App\"><a href=\"#Your-Web-App\" class=\"headerlink\" title=\"Your Web App\"></a>Your Web App</h3><p>Web开发者开发的程序，Web开发者可以基于集成WebRTC的浏览器提供的web API开发基于视频、音频的实时通信应用。</p>\n<h3 id=\"Web-API\"><a href=\"#Web-API\" class=\"headerlink\" title=\"Web API\"></a>Web API</h3><p>面向第三方开发者的WebRTC标准API（Javascript），使开发者能够容易地开发出类似于网络视频聊天的web应用，需要注意的是可能在不同浏览器中API接口名会不太一样, 所以推荐使用这个JS适配器来协调各个浏览器的不同接口。 这些API可分成Media API、 RTCPeerConnection、Peer-to-peer Data API三类:</p>\n<h3 id=\"Media-API\"><a href=\"#Media-API\" class=\"headerlink\" title=\"Media API\"></a>Media API</h3><p>MediaStream：MediaStream用来表示一个媒体数据流。 MediaStreamTrack：在浏览器中表示一个媒体源。</p>\n<h3 id=\"RTCPeerConnection\"><a href=\"#RTCPeerConnection\" class=\"headerlink\" title=\"RTCPeerConnection\"></a>RTCPeerConnection</h3><p>RTCPeerConnection：一个RTCPeerConnection对象允许用户在两个浏览器之间直接通讯。 SDP: 用来描述当前连接者想要传输的内容，支持的协议类型，支持的编解码类型等。 RTCIceCandidate：表示一个ICE协议的候选者，简单的说，就是目标节点的IP以及端口。 RTCIceServer：表示一个ICE Server，其主要用于当前主机的IP发现，通过和ICE Server通讯，我们会得到一组可供连接使用的IP:Port候选值，双方通过交换ICE候选值来建立起连接。</p>\n<h3 id=\"Peer-to-peer-Data-API\"><a href=\"#Peer-to-peer-Data-API\" class=\"headerlink\" title=\"Peer-to-peer Data API\"></a>Peer-to-peer Data API</h3><p>DataChannel：数据通道( DataChannel)接口表示一个在两个节点之间的双向的数据通道，该通道可以设置成可靠传输或非可靠传输 。</p>\n<h3 id=\"WebRTC-Native-C-API\"><a href=\"#WebRTC-Native-C-API\" class=\"headerlink\" title=\"WebRTC Native C++ API\"></a>WebRTC Native C++ API</h3><p>本地C++ API层，使浏览器厂商容易实现WebRTC标准的Web API，抽象地对数字信号过程进行处理。</p>\n<h3 id=\"Transport-Session\"><a href=\"#Transport-Session\" class=\"headerlink\" title=\"Transport / Session\"></a>Transport / Session</h3><p>传输部分可基于TCP/UDP，会话层组件采用了libjingle库的部分组件实现</p>\n<h3 id=\"AudioEngine\"><a href=\"#AudioEngine\" class=\"headerlink\" title=\"AudioEngine\"></a>AudioEngine</h3><p>音频引擎是包含一系列音频多媒体处理的框架，包括从视频采集卡到网络传输端等整个解决方案。</p>\n<h3 id=\"VideoEngine\"><a href=\"#VideoEngine\" class=\"headerlink\" title=\"VideoEngine\"></a>VideoEngine</h3><p>视频引擎是包含一系列视频处理的整体框架，从摄像头采集视频到视频信息网络传输再到视频显示整个完整过程的解决方案。</p>\n<h2 id=\"通讯内容的确立\"><a href=\"#通讯内容的确立\" class=\"headerlink\" title=\"通讯内容的确立\"></a>通讯内容的确立</h2><p>首先，两个客户端（Alice &amp; Bob）想要创建连接，一般来说需要有一个双方都能访问的服务器来帮助他们交换连接所需要的信息。有了交换数据的中间人之后，他们首先要交换的数据是SessionDescription（SD），这里面描述了连接双方想要建立怎样的连接。 </p>\n<p><img src=\"https://z3.ax1x.com/2021/10/05/4v5zSP.jpg\"></p>\n<h2 id=\"WebRTC的目录结构\"><a href=\"#WebRTC的目录结构\" class=\"headerlink\" title=\"WebRTC的目录结构\"></a>WebRTC的目录结构</h2><p>webrtc windows 目录结构，不过都差不多</p>\n<h4 id=\"根目录：\"><a href=\"#根目录：\" class=\"headerlink\" title=\"根目录：\"></a>根目录：</h4><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>api</td>\n<td>WebRTC接口层，浏览器都是通过该接口调用webRTC</td>\n</tr>\n<tr>\n<td>call</td>\n<td>数据流的管理层，Call代表同一个端点的所有数据的流入流出</td>\n</tr>\n<tr>\n<td>video</td>\n<td>与视频相关的逻辑</td>\n</tr>\n<tr>\n<td>audio</td>\n<td>与音频相关的逻辑</td>\n</tr>\n<tr>\n<td>common_audio</td>\n<td>音频算法相关</td>\n</tr>\n<tr>\n<td>common_video</td>\n<td>视频算法相关</td>\n</tr>\n<tr>\n<td>media</td>\n<td>与多媒体相关的逻辑处理，如编解码的逻辑处理</td>\n</tr>\n<tr>\n<td>logging</td>\n<td>日志相关</td>\n</tr>\n<tr>\n<td>module</td>\n<td>最重要的目录，子模块</td>\n</tr>\n<tr>\n<td>pc</td>\n<td>Peer Connection,链接相关的逻辑层</td>\n</tr>\n<tr>\n<td>p2p</td>\n<td>端对端相关代码,stun,turn</td>\n</tr>\n<tr>\n<td>rtc_base</td>\n<td>基础代码，如线程，锁相关的统一接口代码</td>\n</tr>\n<tr>\n<td>rtc_tool</td>\n<td>音视频分析相关的工具代码</td>\n</tr>\n<tr>\n<td>tool_webrtc</td>\n<td>WebRTC测试相关的工具代码。如CPU特性,原子操作等</td>\n</tr>\n<tr>\n<td>stats</td>\n<td>存放各类数据统计相关的类</td>\n</tr>\n<tr>\n<td>sdk</td>\n<td>存放Android和IOS层代码。如视频采集，渲染等</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>video_capture:</p>\n<p>windows 上webrtc采用的是dshow技术，实现枚举视频的设备信息和视频数据的采集，这意味着可以支持大多数的视频采集设备；对那些需要单独驱动程序的视频采集卡（比如海康高清卡）就无能为力了。  （别买HIK的摄像头）</p>\n<p>video_coding:</p>\n<p>WebRTC采用I420/VP8编解码技术。VP8是google收购ON2后的开源实现，并且也用在WebM项目中。VP8能以更少的数据提供更高质量的视频，特别适合视频会议这样的需求。  (VP8压缩率实际不如h264,webrtc处理264的时候有问题，以后说)</p>\n<p>video_processing:</p>\n<p> 视频图像处理针对每一帧的图像进行处理，包括明暗度检测、颜色增强、降噪处理等功能，用来提升视频质量。</p>\n<h4 id=\"子目录：\"><a href=\"#子目录：\" class=\"headerlink\" title=\"子目录：\"></a>子目录：</h4><table>\n<thead>\n<tr>\n<th>目录</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>audio_coding</td>\n<td>音频编解码相关代码</td>\n</tr>\n<tr>\n<td>audio_device</td>\n<td>音频采集与音频播放相关代码 （设备相关）</td>\n</tr>\n<tr>\n<td>audio_mixer</td>\n<td>混音相关代码（多人实时互动，要混在一起传输）</td>\n</tr>\n<tr>\n<td>audio_processing</td>\n<td>音频先后处理的相关代码（轨迹消除，降噪）</td>\n</tr>\n<tr>\n<td>bitrate_controller</td>\n<td>码率控制相关代码（码流500k，1M）</td>\n</tr>\n<tr>\n<td>congestion_controller</td>\n<td>流控相关代码(流量控制)</td>\n</tr>\n<tr>\n<td>desktop_capture</td>\n<td>桌面采集相关代码</td>\n</tr>\n<tr>\n<td>pacing</td>\n<td>码率探测及平滑处理相关的代码</td>\n</tr>\n<tr>\n<td>remote_bitrate_estimator</td>\n<td>码率探测及平滑处理相关的代码</td>\n</tr>\n<tr>\n<td>rtp_rtcp</td>\n<td>rtp/rtcp协议相关的代码</td>\n</tr>\n<tr>\n<td>video_capture</td>\n<td>视频采集相关的代码</td>\n</tr>\n<tr>\n<td>video_coding</td>\n<td>视频编解码相关的代码</td>\n</tr>\n<tr>\n<td>video_processing</td>\n<td>视频前后处理相关的代码</td>\n</tr>\n</tbody></table>\n<h2 id=\"webRTC的运行机制\"><a href=\"#webRTC的运行机制\" class=\"headerlink\" title=\"webRTC的运行机制\"></a>webRTC的运行机制</h2><h3 id=\"轨与流\"><a href=\"#轨与流\" class=\"headerlink\" title=\"轨与流\"></a>轨与流</h3><p>Track :一路轨是平行且不相交的音频轨，视频轨 </p>\n<p>MediaStream: 借鉴了传统的媒体流的概念</p>\n<h3 id=\"WebRTC重要类\"><a href=\"#WebRTC重要类\" class=\"headerlink\" title=\"WebRTC重要类\"></a>WebRTC重要类</h3><p>MediaStream (包含很多轨)</p>\n<p>RTCPeerConnection   (最重要的类  里面包含了一些大而全的类，对于应用层来说将MediaStream塞到RTCPeerConnection   就好了，重点掌握) </p>\n<p>RTCDataChannel（普通的二进制数据通过PeerConnection获取，再通过DataChannel塞到PeerConnection中去）</p>\n<h3 id=\"PeerConnection调用过程\"><a href=\"#PeerConnection调用过程\" class=\"headerlink\" title=\"PeerConnection调用过程\"></a>PeerConnection调用过程</h3><p><img src=\"https://z3.ax1x.com/2021/10/05/4v0pEF.png\"></p>\n<h3 id=\"调用时序图\"><a href=\"#调用时序图\" class=\"headerlink\" title=\"调用时序图\"></a>调用时序图</h3><p><img src=\"https://z3.ax1x.com/2021/10/05/4vBxkF.png\"></p>\n<p><img src=\"https://z3.ax1x.com/2021/10/05/4vRdm9.png\"></p>\n"},{"title":"ffmpeg常用命令","date":"2021-12-04T15:28:35.000Z","_content":"\nffmpeg下载：\n\n推荐官网下载(http://www.ffmpeg.org/download.html), 当然也可以采用国内的镜像源，我这里采用的是windows系统的版本，记得自己配置环境变量\n\n![](https://thumbnail1.baidupcs.com/thumbnail/5a28e05f8l22ba7094b3a0e502ba2f4e?fid=588163855-250528-1070814146298986&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-zQbcJBmEjfrDqxQQEU0kTWfx8V8%3d&expires=8h&chkbd=0&chkv=0&dp-logid=165598699728324489&dp-callid=0&time=1645876800&size=c1920_u1080&quality=90&vuk=588163855&ft=image&autopolicy=1)\n\n自身信息查看:\n\n```bash\nffmpeg -h             :查看基本帮助信息\nffmpeg -h long        :查看高级帮助信息\nffmpeg -h full        :查看所有帮助信息\nffmpeg -version       :查询版本\nffmpeg -buildconf     :查询编译配置\nffmpeg -formats       :查询可用格式\nffmpeg -muxers        :查询可用复用器\nffmpeg -demuxers      :查询可用解复用器\nffmpeg -codecs        :查询可用编解码器\nffmpeg -decoders      :查询可用解码器\nffmpeg -encoders      :查询可用编码器\nffmpeg -bsfs          :查询可可用比特流filter\nffmpeg -protocols     :查询可用的协议\nffmpeg -filters       :查询可用的过滤器\nffmpeg -pix_fmts      :查询可用的像素格式\nffmpeg -layouts       :查询标准声道名称\nffmpeg -sample_fmts   :查询可用的音频采样格式\nffmpeg -colors        :查询可用的颜色名称\n\n```\n\n主要参数：\n\n```bash\n-i               设置输入文件\n-f               设置输出格式\n-y               若输出文件已存在时则覆盖文件\n-fs              超过指定的文件大小时则结束转换\n-t               指定输出文件的持续时间，以秒为单位\n-ss              从指定时间开始转换，以秒为单位\n-title           设置标题\n-timestamp       设置时间戳\n-vsync           增减Frame使影音同步\n-c               指定输出文件的编码\n-metadata        更改输出文件的元数据\n-b:v             设置影像流量，默认为200Kbit/秒。（单位请引用下方注意事项）\n-r               设置帧率值，默认为25\n-s               设置画面的宽与高\n-aspect          设置画面的比例\n-vn              不处理影像，于仅针对声音做处理时使用\n-vcodec( -c:v )  设置影像影像编解码器，未设置时则使用与输入文件相同之编解码器\n-b:a             设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）\n-ar              设置采样率\n-ac              设置声音的Channel数\n-acodec ( -c:a ) 设置声音编解码器，未设置时与影像相同，使用与输入文件相同之编解码器\n-an              不处理声音，于仅针对影像做处理时使用\n-vol             设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）\n```\n\n视频参数：\n\n```bash\n-b 设定视频流量(码率)，默认为200Kbit/s \n-r 设定帧速率，默认为25 \n-s 设定画面的宽与高 \n-aspect 设定画面的比例 \n-vn 不处理视频 \n-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 \n```\n\n音频参数：\n\n```bash\n-ar 设定采样率 \n-ac 设定声音的Channel数 \n-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 \n-an 不处理音频\n```\n\n##### 1.视频格式转换\n\n```bash\nffmpeg -i input.avi output.mp4\nffmpeg -i input.mp4 output.ts\n```\n\n##### 2. 提取音频\n\n```bash\nffmpeg -i test.mp4 -acodec copy -vn output.aac\nffmpeg -i test.mp4 -acodec aac -vn output.aac\nffmpeg -i test.mp4 -f mp3 -vn test.mp3\n```\n\n##### 3.提取视频\n\n```bash\nffmpeg -i input.mp4 -vcodec copy -an output.mp4\n```\n\n##### 4.视频剪切\n\n00:00:15开始，截取5秒钟的视频\n\n```bash\nffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4\n```\n\n##### 5.码率控制\n\n码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。\n\n那么，什么是码率？很简单：\nbitrate = file size / duration\n比如一个文件20.8M，时长1分钟，那么，码率就是：\nbiterate = 20.8M bit/60s = 20.810241024*8 bit/60s= 2831Kbps\n一般音频的码率只有固定几种，比如是128Kbps，\n那么，video的就是\nvideo biterate = 2831Kbps -128Kbps = 2703Kbps。\n\n说完背景了。好了，来说ffmpeg如何控制码率。\nffmpg控制码率有3种选择，-minrate -b:v -maxrate\n-b:v主要是控制平均码率。\n比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k output.mp4\n```\n\n上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。\n不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize\n-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4\n```\n\n-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4\n```\n\n##### 6.视频编码格式转换\n\n```bash\nffmpeg -i input.mp4 -vcodec h264 output.mp4\nffmpeg -i input.mp4 -vcodec mpeg4 output.mp4\nffmpeg -i input.mp4 -c:v libx265 output.mp4\nffmpeg -i input.mp4 -c:v libx264 output.mp4\n```\n\n##### 7. 只提取视频ES数据\n\n```bash\nffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264\n```\n\n##### 8. 过滤器的使用\n\n###### 8.1.将输入的1920x1080缩小到960x540输出:\n\n```bash\nffmpeg -i input.mp4 -vf scale=960:540 output.mp4\n```\n\n###### 8.2 为视频添加logo\n\n```bash\nffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4\n```\n\n[![oGvMz8.png](https://z3.ax1x.com/2021/12/01/oGvMz8.png)](https://imgtu.com/i/oGvMz8)\n\n右上角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4\n```\n\n左下角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4\n```\n\n右下角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4\n```\n\n###### 8.3 去掉视频的logo\n\n有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。\n语法：-vf delogo=x:y:w:h[:t[:show]]\nx:y 离左上角的坐标\nw:h logo的宽和高\nt: 矩形边缘的厚度默认值4\nshow：若设置为1有一个绿色的矩形，默认值0。\n\n```bash\nffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4\n```\n\n结果如下所示：\n\n[![otnJRf.png](https://z3.ax1x.com/2021/12/02/otnJRf.png)](https://imgtu.com/i/otnJRf)\n\n##### 9. 抓取视频的一些帧，存为jpeg图片\n\n比如，一个视频，我想提取一些帧，存为图片，咋办？\n\n```bash\nffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\n```\n\n-r 表示每一秒几帧\n-q:v表示存储jpeg的图像质量，一般2是高质量。\n如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。\n\n[![otMusU.png](https://z3.ax1x.com/2021/12/02/otMusU.png)](https://imgtu.com/i/otMusU)\n\n60张？什么？这么多？不要不要。。。。。不要咋办？？\n可以设置开始的时间，和你想要截取的时间呀。\n\n```bash\nffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\n```\n\n-ss 表示开始时间\n-t表示共要多少时间。\n如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。\n[![otQAmD.png](https://z3.ax1x.com/2021/12/02/otQAmD.png)](https://imgtu.com/i/otQAmD)\n\n##### 10. 将带透明的png图片转为带透明的webM视频\n\n```bash\nffmpeg -f image2 -i cap_%d.png -c:v libvpx -auto-alt-ref 0 -r 10000 ./out_vp8.webm\n```\n\n##### 11. 视频与音频合并\n\n###### 11.1 视频本身有声音的情况\n\n命令：\n\n```bash\nffmpeg -i input_video.mp4 -i input_audio.mp3 -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 output.mp4\n```\n\n最后时长是音频或视频的时长的最大值。\n\n-map的意思是，使用第一个输入源的视频，第二个输入源的音频\n\n###### 11.2 视频本身没声音的情况\n\n命令：\n\n```bash\nffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac output.mp4\n```\n\n如果合并希望视频或音频哪个先结束，就完成合并，则加一个参数-shortest\n\n###### 11.3 剪切视频的部分区域\n\n```bash\nffmpeg -i in.mp4 -filter:v \"crop=out_w:out_h:x:y\" out.mp4\n```\n\nout_w 视频截取的宽\nout_h 视频截取的高\nx and y 截取的左上角坐标\n\n例如，把一个1080p的横屏视频，截取为一个宽高为576x1024的竖屏视频\n\n```bash\nffmpeg -i input.mp4 -filter:v \"crop=576:1024:0:0\" cut_out.mp4\n```\n\n###### 11.4 合并2个视频\n\n最好2个视频是同样格式以及大小。\n用如下3个命令，先把2个输入文件转为临时文件，保证格式一样，然后合并\n合并2个视频：\n\n```bash\nffmpeg -i input1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate1.ts\nffmpeg -i input2.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate2.ts\nffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.mp4\n```\n\n--未完待续--\n","source":"_posts/ffmpeg常用命令.md","raw":"---\ntitle: ffmpeg常用命令\ndate: 2021-12-04 23:28:35\ntags: 工具\ncategories:\n- 视频处理\n\n---\n\nffmpeg下载：\n\n推荐官网下载(http://www.ffmpeg.org/download.html), 当然也可以采用国内的镜像源，我这里采用的是windows系统的版本，记得自己配置环境变量\n\n![](https://thumbnail1.baidupcs.com/thumbnail/5a28e05f8l22ba7094b3a0e502ba2f4e?fid=588163855-250528-1070814146298986&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-zQbcJBmEjfrDqxQQEU0kTWfx8V8%3d&expires=8h&chkbd=0&chkv=0&dp-logid=165598699728324489&dp-callid=0&time=1645876800&size=c1920_u1080&quality=90&vuk=588163855&ft=image&autopolicy=1)\n\n自身信息查看:\n\n```bash\nffmpeg -h             :查看基本帮助信息\nffmpeg -h long        :查看高级帮助信息\nffmpeg -h full        :查看所有帮助信息\nffmpeg -version       :查询版本\nffmpeg -buildconf     :查询编译配置\nffmpeg -formats       :查询可用格式\nffmpeg -muxers        :查询可用复用器\nffmpeg -demuxers      :查询可用解复用器\nffmpeg -codecs        :查询可用编解码器\nffmpeg -decoders      :查询可用解码器\nffmpeg -encoders      :查询可用编码器\nffmpeg -bsfs          :查询可可用比特流filter\nffmpeg -protocols     :查询可用的协议\nffmpeg -filters       :查询可用的过滤器\nffmpeg -pix_fmts      :查询可用的像素格式\nffmpeg -layouts       :查询标准声道名称\nffmpeg -sample_fmts   :查询可用的音频采样格式\nffmpeg -colors        :查询可用的颜色名称\n\n```\n\n主要参数：\n\n```bash\n-i               设置输入文件\n-f               设置输出格式\n-y               若输出文件已存在时则覆盖文件\n-fs              超过指定的文件大小时则结束转换\n-t               指定输出文件的持续时间，以秒为单位\n-ss              从指定时间开始转换，以秒为单位\n-title           设置标题\n-timestamp       设置时间戳\n-vsync           增减Frame使影音同步\n-c               指定输出文件的编码\n-metadata        更改输出文件的元数据\n-b:v             设置影像流量，默认为200Kbit/秒。（单位请引用下方注意事项）\n-r               设置帧率值，默认为25\n-s               设置画面的宽与高\n-aspect          设置画面的比例\n-vn              不处理影像，于仅针对声音做处理时使用\n-vcodec( -c:v )  设置影像影像编解码器，未设置时则使用与输入文件相同之编解码器\n-b:a             设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）\n-ar              设置采样率\n-ac              设置声音的Channel数\n-acodec ( -c:a ) 设置声音编解码器，未设置时与影像相同，使用与输入文件相同之编解码器\n-an              不处理声音，于仅针对影像做处理时使用\n-vol             设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）\n```\n\n视频参数：\n\n```bash\n-b 设定视频流量(码率)，默认为200Kbit/s \n-r 设定帧速率，默认为25 \n-s 设定画面的宽与高 \n-aspect 设定画面的比例 \n-vn 不处理视频 \n-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 \n```\n\n音频参数：\n\n```bash\n-ar 设定采样率 \n-ac 设定声音的Channel数 \n-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 \n-an 不处理音频\n```\n\n##### 1.视频格式转换\n\n```bash\nffmpeg -i input.avi output.mp4\nffmpeg -i input.mp4 output.ts\n```\n\n##### 2. 提取音频\n\n```bash\nffmpeg -i test.mp4 -acodec copy -vn output.aac\nffmpeg -i test.mp4 -acodec aac -vn output.aac\nffmpeg -i test.mp4 -f mp3 -vn test.mp3\n```\n\n##### 3.提取视频\n\n```bash\nffmpeg -i input.mp4 -vcodec copy -an output.mp4\n```\n\n##### 4.视频剪切\n\n00:00:15开始，截取5秒钟的视频\n\n```bash\nffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4\n```\n\n##### 5.码率控制\n\n码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。\n\n那么，什么是码率？很简单：\nbitrate = file size / duration\n比如一个文件20.8M，时长1分钟，那么，码率就是：\nbiterate = 20.8M bit/60s = 20.810241024*8 bit/60s= 2831Kbps\n一般音频的码率只有固定几种，比如是128Kbps，\n那么，video的就是\nvideo biterate = 2831Kbps -128Kbps = 2703Kbps。\n\n说完背景了。好了，来说ffmpeg如何控制码率。\nffmpg控制码率有3种选择，-minrate -b:v -maxrate\n-b:v主要是控制平均码率。\n比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k output.mp4\n```\n\n上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。\n不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize\n-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4\n```\n\n-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。\n\n```bash\nffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4\n```\n\n##### 6.视频编码格式转换\n\n```bash\nffmpeg -i input.mp4 -vcodec h264 output.mp4\nffmpeg -i input.mp4 -vcodec mpeg4 output.mp4\nffmpeg -i input.mp4 -c:v libx265 output.mp4\nffmpeg -i input.mp4 -c:v libx264 output.mp4\n```\n\n##### 7. 只提取视频ES数据\n\n```bash\nffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264\n```\n\n##### 8. 过滤器的使用\n\n###### 8.1.将输入的1920x1080缩小到960x540输出:\n\n```bash\nffmpeg -i input.mp4 -vf scale=960:540 output.mp4\n```\n\n###### 8.2 为视频添加logo\n\n```bash\nffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4\n```\n\n[![oGvMz8.png](https://z3.ax1x.com/2021/12/01/oGvMz8.png)](https://imgtu.com/i/oGvMz8)\n\n右上角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4\n```\n\n左下角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4\n```\n\n右下角：\n\n```bash\nffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4\n```\n\n###### 8.3 去掉视频的logo\n\n有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。\n语法：-vf delogo=x:y:w:h[:t[:show]]\nx:y 离左上角的坐标\nw:h logo的宽和高\nt: 矩形边缘的厚度默认值4\nshow：若设置为1有一个绿色的矩形，默认值0。\n\n```bash\nffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4\n```\n\n结果如下所示：\n\n[![otnJRf.png](https://z3.ax1x.com/2021/12/02/otnJRf.png)](https://imgtu.com/i/otnJRf)\n\n##### 9. 抓取视频的一些帧，存为jpeg图片\n\n比如，一个视频，我想提取一些帧，存为图片，咋办？\n\n```bash\nffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\n```\n\n-r 表示每一秒几帧\n-q:v表示存储jpeg的图像质量，一般2是高质量。\n如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。\n\n[![otMusU.png](https://z3.ax1x.com/2021/12/02/otMusU.png)](https://imgtu.com/i/otMusU)\n\n60张？什么？这么多？不要不要。。。。。不要咋办？？\n可以设置开始的时间，和你想要截取的时间呀。\n\n```bash\nffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg\n```\n\n-ss 表示开始时间\n-t表示共要多少时间。\n如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。\n[![otQAmD.png](https://z3.ax1x.com/2021/12/02/otQAmD.png)](https://imgtu.com/i/otQAmD)\n\n##### 10. 将带透明的png图片转为带透明的webM视频\n\n```bash\nffmpeg -f image2 -i cap_%d.png -c:v libvpx -auto-alt-ref 0 -r 10000 ./out_vp8.webm\n```\n\n##### 11. 视频与音频合并\n\n###### 11.1 视频本身有声音的情况\n\n命令：\n\n```bash\nffmpeg -i input_video.mp4 -i input_audio.mp3 -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 output.mp4\n```\n\n最后时长是音频或视频的时长的最大值。\n\n-map的意思是，使用第一个输入源的视频，第二个输入源的音频\n\n###### 11.2 视频本身没声音的情况\n\n命令：\n\n```bash\nffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac output.mp4\n```\n\n如果合并希望视频或音频哪个先结束，就完成合并，则加一个参数-shortest\n\n###### 11.3 剪切视频的部分区域\n\n```bash\nffmpeg -i in.mp4 -filter:v \"crop=out_w:out_h:x:y\" out.mp4\n```\n\nout_w 视频截取的宽\nout_h 视频截取的高\nx and y 截取的左上角坐标\n\n例如，把一个1080p的横屏视频，截取为一个宽高为576x1024的竖屏视频\n\n```bash\nffmpeg -i input.mp4 -filter:v \"crop=576:1024:0:0\" cut_out.mp4\n```\n\n###### 11.4 合并2个视频\n\n最好2个视频是同样格式以及大小。\n用如下3个命令，先把2个输入文件转为临时文件，保证格式一样，然后合并\n合并2个视频：\n\n```bash\nffmpeg -i input1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate1.ts\nffmpeg -i input2.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate2.ts\nffmpeg -i \"concat:intermediate1.ts|intermediate2.ts\" -c copy -bsf:a aac_adtstoasc output.mp4\n```\n\n--未完待续--\n","slug":"ffmpeg常用命令","published":1,"updated":"2022-11-20T05:15:37.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivveu0002b0gi854a967d","content":"<p>ffmpeg下载：</p>\n<p>推荐官网下载(<a href=\"http://www.ffmpeg.org/download.html\">http://www.ffmpeg.org/download.html</a>), 当然也可以采用国内的镜像源，我这里采用的是windows系统的版本，记得自己配置环境变量</p>\n<p><img src=\"https://thumbnail1.baidupcs.com/thumbnail/5a28e05f8l22ba7094b3a0e502ba2f4e?fid=588163855-250528-1070814146298986&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-zQbcJBmEjfrDqxQQEU0kTWfx8V8=&expires=8h&chkbd=0&chkv=0&dp-logid=165598699728324489&dp-callid=0&time=1645876800&size=c1920_u1080&quality=90&vuk=588163855&ft=image&autopolicy=1\"></p>\n<p>自身信息查看:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -h             :查看基本帮助信息<br>ffmpeg -h long        :查看高级帮助信息<br>ffmpeg -h full        :查看所有帮助信息<br>ffmpeg -version       :查询版本<br>ffmpeg -buildconf     :查询编译配置<br>ffmpeg -formats       :查询可用格式<br>ffmpeg -muxers        :查询可用复用器<br>ffmpeg -demuxers      :查询可用解复用器<br>ffmpeg -codecs        :查询可用编解码器<br>ffmpeg -decoders      :查询可用解码器<br>ffmpeg -encoders      :查询可用编码器<br>ffmpeg -bsfs          :查询可可用比特流filter<br>ffmpeg -protocols     :查询可用的协议<br>ffmpeg -filters       :查询可用的过滤器<br>ffmpeg -pix_fmts      :查询可用的像素格式<br>ffmpeg -layouts       :查询标准声道名称<br>ffmpeg -sample_fmts   :查询可用的音频采样格式<br>ffmpeg -colors        :查询可用的颜色名称<br><br></code></pre></td></tr></table></figure>\n\n<p>主要参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-i               设置输入文件<br>-f               设置输出格式<br>-y               若输出文件已存在时则覆盖文件<br>-fs              超过指定的文件大小时则结束转换<br>-t               指定输出文件的持续时间，以秒为单位<br>-ss              从指定时间开始转换，以秒为单位<br>-title           设置标题<br>-timestamp       设置时间戳<br>-vsync           增减Frame使影音同步<br>-c               指定输出文件的编码<br>-metadata        更改输出文件的元数据<br>-b:v             设置影像流量，默认为200Kbit/秒。（单位请引用下方注意事项）<br>-r               设置帧率值，默认为25<br>-s               设置画面的宽与高<br>-aspect          设置画面的比例<br>-vn              不处理影像，于仅针对声音做处理时使用<br>-vcodec( -c:v )  设置影像影像编解码器，未设置时则使用与输入文件相同之编解码器<br>-b:a             设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）<br>-ar              设置采样率<br>-ac              设置声音的Channel数<br>-acodec ( -c:a ) 设置声音编解码器，未设置时与影像相同，使用与输入文件相同之编解码器<br>-an              不处理声音，于仅针对影像做处理时使用<br>-vol             设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）<br></code></pre></td></tr></table></figure>\n\n<p>视频参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-b 设定视频流量(码率)，默认为200Kbit/s <br>-r 设定帧速率，默认为25 <br>-s 设定画面的宽与高 <br>-aspect 设定画面的比例 <br>-vn 不处理视频 <br>-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 <br></code></pre></td></tr></table></figure>\n\n<p>音频参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-ar 设定采样率 <br>-ac 设定声音的Channel数 <br>-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 <br>-an 不处理音频<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"1-视频格式转换\"><a href=\"#1-视频格式转换\" class=\"headerlink\" title=\"1.视频格式转换\"></a>1.视频格式转换</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.avi output.mp4<br>ffmpeg -i input.mp4 output.ts<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-提取音频\"><a href=\"#2-提取音频\" class=\"headerlink\" title=\"2. 提取音频\"></a>2. 提取音频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i test.mp4 -acodec copy -vn output.aac<br>ffmpeg -i test.mp4 -acodec aac -vn output.aac<br>ffmpeg -i test.mp4 -f mp3 -vn test.mp3<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-提取视频\"><a href=\"#3-提取视频\" class=\"headerlink\" title=\"3.提取视频\"></a>3.提取视频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vcodec copy -an output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"4-视频剪切\"><a href=\"#4-视频剪切\" class=\"headerlink\" title=\"4.视频剪切\"></a>4.视频剪切</h5><p>00:00:15开始，截取5秒钟的视频</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"5-码率控制\"><a href=\"#5-码率控制\" class=\"headerlink\" title=\"5.码率控制\"></a>5.码率控制</h5><p>码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。</p>\n<p>那么，什么是码率？很简单：<br>bitrate = file size / duration<br>比如一个文件20.8M，时长1分钟，那么，码率就是：<br>biterate = 20.8M bit/60s = 20.810241024*8 bit/60s= 2831Kbps<br>一般音频的码率只有固定几种，比如是128Kbps，<br>那么，video的就是<br>video biterate = 2831Kbps -128Kbps = 2703Kbps。</p>\n<p>说完背景了。好了，来说ffmpeg如何控制码率。<br>ffmpg控制码率有3种选择，-minrate -b:v -maxrate<br>-b:v主要是控制平均码率。<br>比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。<br>不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize<br>-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"6-视频编码格式转换\"><a href=\"#6-视频编码格式转换\" class=\"headerlink\" title=\"6.视频编码格式转换\"></a>6.视频编码格式转换</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vcodec h264 output.mp4<br>ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4<br>ffmpeg -i input.mp4 -c:v libx265 output.mp4<br>ffmpeg -i input.mp4 -c:v libx264 output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"7-只提取视频ES数据\"><a href=\"#7-只提取视频ES数据\" class=\"headerlink\" title=\"7. 只提取视频ES数据\"></a>7. 只提取视频ES数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"8-过滤器的使用\"><a href=\"#8-过滤器的使用\" class=\"headerlink\" title=\"8. 过滤器的使用\"></a>8. 过滤器的使用</h5><h6 id=\"8-1-将输入的1920x1080缩小到960x540输出\"><a href=\"#8-1-将输入的1920x1080缩小到960x540输出\" class=\"headerlink\" title=\"8.1.将输入的1920x1080缩小到960x540输出:\"></a>8.1.将输入的1920x1080缩小到960x540输出:</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vf scale=960:540 output.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"8-2-为视频添加logo\"><a href=\"#8-2-为视频添加logo\" class=\"headerlink\" title=\"8.2 为视频添加logo\"></a>8.2 为视频添加logo</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://imgtu.com/i/oGvMz8\"><img src=\"https://z3.ax1x.com/2021/12/01/oGvMz8.png\" alt=\"oGvMz8.png\"></a></p>\n<p>右上角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>左下角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>右下角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"8-3-去掉视频的logo\"><a href=\"#8-3-去掉视频的logo\" class=\"headerlink\" title=\"8.3 去掉视频的logo\"></a>8.3 去掉视频的logo</h6><p>有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。<br>语法：-vf delogo=x:y:w:h[:t[:show]]<br>x:y 离左上角的坐标<br>w:h logo的宽和高<br>t: 矩形边缘的厚度默认值4<br>show：若设置为1有一个绿色的矩形，默认值0。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>结果如下所示：</p>\n<p><a href=\"https://imgtu.com/i/otnJRf\"><img src=\"https://z3.ax1x.com/2021/12/02/otnJRf.png\" alt=\"otnJRf.png\"></a></p>\n<h5 id=\"9-抓取视频的一些帧，存为jpeg图片\"><a href=\"#9-抓取视频的一些帧，存为jpeg图片\" class=\"headerlink\" title=\"9. 抓取视频的一些帧，存为jpeg图片\"></a>9. 抓取视频的一些帧，存为jpeg图片</h5><p>比如，一个视频，我想提取一些帧，存为图片，咋办？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br></code></pre></td></tr></table></figure>\n\n<p>-r 表示每一秒几帧<br>-q:v表示存储jpeg的图像质量，一般2是高质量。<br>如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。</p>\n<p><a href=\"https://imgtu.com/i/otMusU\"><img src=\"https://z3.ax1x.com/2021/12/02/otMusU.png\" alt=\"otMusU.png\"></a></p>\n<p>60张？什么？这么多？不要不要。。。。。不要咋办？？<br>可以设置开始的时间，和你想要截取的时间呀。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br></code></pre></td></tr></table></figure>\n\n<p>-ss 表示开始时间<br>-t表示共要多少时间。<br>如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。<br><a href=\"https://imgtu.com/i/otQAmD\"><img src=\"https://z3.ax1x.com/2021/12/02/otQAmD.png\" alt=\"otQAmD.png\"></a></p>\n<h5 id=\"10-将带透明的png图片转为带透明的webM视频\"><a href=\"#10-将带透明的png图片转为带透明的webM视频\" class=\"headerlink\" title=\"10. 将带透明的png图片转为带透明的webM视频\"></a>10. 将带透明的png图片转为带透明的webM视频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -f image2 -i cap_%d.png -c:v libvpx -auto-alt-ref 0 -r 10000 ./out_vp8.webm<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"11-视频与音频合并\"><a href=\"#11-视频与音频合并\" class=\"headerlink\" title=\"11. 视频与音频合并\"></a>11. 视频与音频合并</h5><h6 id=\"11-1-视频本身有声音的情况\"><a href=\"#11-1-视频本身有声音的情况\" class=\"headerlink\" title=\"11.1 视频本身有声音的情况\"></a>11.1 视频本身有声音的情况</h6><p>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input_video.mp4 -i input_audio.mp3 -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>最后时长是音频或视频的时长的最大值。</p>\n<p>-map的意思是，使用第一个输入源的视频，第二个输入源的音频</p>\n<h6 id=\"11-2-视频本身没声音的情况\"><a href=\"#11-2-视频本身没声音的情况\" class=\"headerlink\" title=\"11.2 视频本身没声音的情况\"></a>11.2 视频本身没声音的情况</h6><p>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>如果合并希望视频或音频哪个先结束，就完成合并，则加一个参数-shortest</p>\n<h6 id=\"11-3-剪切视频的部分区域\"><a href=\"#11-3-剪切视频的部分区域\" class=\"headerlink\" title=\"11.3 剪切视频的部分区域\"></a>11.3 剪切视频的部分区域</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i in.mp4 -filter:v <span class=\"hljs-string\">&quot;crop=out_w:out_h:x:y&quot;</span> out.mp4<br></code></pre></td></tr></table></figure>\n\n<p>out_w 视频截取的宽<br>out_h 视频截取的高<br>x and y 截取的左上角坐标</p>\n<p>例如，把一个1080p的横屏视频，截取为一个宽高为576x1024的竖屏视频</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -filter:v <span class=\"hljs-string\">&quot;crop=576:1024:0:0&quot;</span> cut_out.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"11-4-合并2个视频\"><a href=\"#11-4-合并2个视频\" class=\"headerlink\" title=\"11.4 合并2个视频\"></a>11.4 合并2个视频</h6><p>最好2个视频是同样格式以及大小。<br>用如下3个命令，先把2个输入文件转为临时文件，保证格式一样，然后合并<br>合并2个视频：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate1.ts<br>ffmpeg -i input2.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate2.ts<br>ffmpeg -i <span class=\"hljs-string\">&quot;concat:intermediate1.ts|intermediate2.ts&quot;</span> -c copy -bsf:a aac_adtstoasc output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>–未完待续–</p>\n","site":{"data":{}},"wordcount":4385,"excerpt":"","more":"<p>ffmpeg下载：</p>\n<p>推荐官网下载(<a href=\"http://www.ffmpeg.org/download.html\">http://www.ffmpeg.org/download.html</a>), 当然也可以采用国内的镜像源，我这里采用的是windows系统的版本，记得自己配置环境变量</p>\n<p><img src=\"https://thumbnail1.baidupcs.com/thumbnail/5a28e05f8l22ba7094b3a0e502ba2f4e?fid=588163855-250528-1070814146298986&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-zQbcJBmEjfrDqxQQEU0kTWfx8V8=&expires=8h&chkbd=0&chkv=0&dp-logid=165598699728324489&dp-callid=0&time=1645876800&size=c1920_u1080&quality=90&vuk=588163855&ft=image&autopolicy=1\"></p>\n<p>自身信息查看:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -h             :查看基本帮助信息<br>ffmpeg -h long        :查看高级帮助信息<br>ffmpeg -h full        :查看所有帮助信息<br>ffmpeg -version       :查询版本<br>ffmpeg -buildconf     :查询编译配置<br>ffmpeg -formats       :查询可用格式<br>ffmpeg -muxers        :查询可用复用器<br>ffmpeg -demuxers      :查询可用解复用器<br>ffmpeg -codecs        :查询可用编解码器<br>ffmpeg -decoders      :查询可用解码器<br>ffmpeg -encoders      :查询可用编码器<br>ffmpeg -bsfs          :查询可可用比特流filter<br>ffmpeg -protocols     :查询可用的协议<br>ffmpeg -filters       :查询可用的过滤器<br>ffmpeg -pix_fmts      :查询可用的像素格式<br>ffmpeg -layouts       :查询标准声道名称<br>ffmpeg -sample_fmts   :查询可用的音频采样格式<br>ffmpeg -colors        :查询可用的颜色名称<br><br></code></pre></td></tr></table></figure>\n\n<p>主要参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-i               设置输入文件<br>-f               设置输出格式<br>-y               若输出文件已存在时则覆盖文件<br>-fs              超过指定的文件大小时则结束转换<br>-t               指定输出文件的持续时间，以秒为单位<br>-ss              从指定时间开始转换，以秒为单位<br>-title           设置标题<br>-timestamp       设置时间戳<br>-vsync           增减Frame使影音同步<br>-c               指定输出文件的编码<br>-metadata        更改输出文件的元数据<br>-b:v             设置影像流量，默认为200Kbit/秒。（单位请引用下方注意事项）<br>-r               设置帧率值，默认为25<br>-s               设置画面的宽与高<br>-aspect          设置画面的比例<br>-vn              不处理影像，于仅针对声音做处理时使用<br>-vcodec( -c:v )  设置影像影像编解码器，未设置时则使用与输入文件相同之编解码器<br>-b:a             设置每Channel（最近的SVN版为所有Channel的总合）的流量。（单位请引用下方注意事项）<br>-ar              设置采样率<br>-ac              设置声音的Channel数<br>-acodec ( -c:a ) 设置声音编解码器，未设置时与影像相同，使用与输入文件相同之编解码器<br>-an              不处理声音，于仅针对影像做处理时使用<br>-vol             设置音量大小，256为标准音量。（要设置成两倍音量时则输入512，依此类推。）<br></code></pre></td></tr></table></figure>\n\n<p>视频参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-b 设定视频流量(码率)，默认为200Kbit/s <br>-r 设定帧速率，默认为25 <br>-s 设定画面的宽与高 <br>-aspect 设定画面的比例 <br>-vn 不处理视频 <br>-vcodec 设定视频编解码器，未设定时则使用与输入流相同的编解码器 <br></code></pre></td></tr></table></figure>\n\n<p>音频参数：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">-ar 设定采样率 <br>-ac 设定声音的Channel数 <br>-acodec 设定声音编解码器，未设定时则使用与输入流相同的编解码器 <br>-an 不处理音频<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"1-视频格式转换\"><a href=\"#1-视频格式转换\" class=\"headerlink\" title=\"1.视频格式转换\"></a>1.视频格式转换</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.avi output.mp4<br>ffmpeg -i input.mp4 output.ts<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-提取音频\"><a href=\"#2-提取音频\" class=\"headerlink\" title=\"2. 提取音频\"></a>2. 提取音频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i test.mp4 -acodec copy -vn output.aac<br>ffmpeg -i test.mp4 -acodec aac -vn output.aac<br>ffmpeg -i test.mp4 -f mp3 -vn test.mp3<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"3-提取视频\"><a href=\"#3-提取视频\" class=\"headerlink\" title=\"3.提取视频\"></a>3.提取视频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vcodec copy -an output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"4-视频剪切\"><a href=\"#4-视频剪切\" class=\"headerlink\" title=\"4.视频剪切\"></a>4.视频剪切</h5><p>00:00:15开始，截取5秒钟的视频</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"5-码率控制\"><a href=\"#5-码率控制\" class=\"headerlink\" title=\"5.码率控制\"></a>5.码率控制</h5><p>码率控制对于在线视频比较重要。因为在线视频需要考虑其能提供的带宽。</p>\n<p>那么，什么是码率？很简单：<br>bitrate = file size / duration<br>比如一个文件20.8M，时长1分钟，那么，码率就是：<br>biterate = 20.8M bit/60s = 20.810241024*8 bit/60s= 2831Kbps<br>一般音频的码率只有固定几种，比如是128Kbps，<br>那么，video的就是<br>video biterate = 2831Kbps -128Kbps = 2703Kbps。</p>\n<p>说完背景了。好了，来说ffmpeg如何控制码率。<br>ffmpg控制码率有3种选择，-minrate -b:v -maxrate<br>-b:v主要是控制平均码率。<br>比如一个视频源的码率太高了，有10Mbps，文件太大，想把文件弄小一点，但是又不破坏分辨率。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>上面把码率从原码率转成2Mbps码率，这样其实也间接让文件变小了。目测接近一半。<br>不过，ffmpeg官方wiki比较建议，设置b:v时，同时加上 -bufsize<br>-bufsize 用于设置码率控制缓冲器的大小，设置的好处是，让整体的码率更趋近于希望的值，减少波动。（简单来说，比如1 2的平均值是1.5， 1.49 1.51 也是1.5, 当然是第二种比较好）</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>-minrate -maxrate就简单了，在线视频有时候，希望码率波动，不要超过一个阈值，可以设置maxrate。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -b:v 2000k -bufsize 2000k -maxrate 2500k output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"6-视频编码格式转换\"><a href=\"#6-视频编码格式转换\" class=\"headerlink\" title=\"6.视频编码格式转换\"></a>6.视频编码格式转换</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vcodec h264 output.mp4<br>ffmpeg -i input.mp4 -vcodec mpeg4 output.mp4<br>ffmpeg -i input.mp4 -c:v libx265 output.mp4<br>ffmpeg -i input.mp4 -c:v libx264 output.mp4<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"7-只提取视频ES数据\"><a href=\"#7-只提取视频ES数据\" class=\"headerlink\" title=\"7. 只提取视频ES数据\"></a>7. 只提取视频ES数据</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg –i input.mp4 –vcodec copy –an –f m4v output.h264<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"8-过滤器的使用\"><a href=\"#8-过滤器的使用\" class=\"headerlink\" title=\"8. 过滤器的使用\"></a>8. 过滤器的使用</h5><h6 id=\"8-1-将输入的1920x1080缩小到960x540输出\"><a href=\"#8-1-将输入的1920x1080缩小到960x540输出\" class=\"headerlink\" title=\"8.1.将输入的1920x1080缩小到960x540输出:\"></a>8.1.将输入的1920x1080缩小到960x540输出:</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vf scale=960:540 output.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"8-2-为视频添加logo\"><a href=\"#8-2-为视频添加logo\" class=\"headerlink\" title=\"8.2 为视频添加logo\"></a>8.2 为视频添加logo</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i iQIYI_logo.png -filter_complex overlay output.mp4<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://imgtu.com/i/oGvMz8\"><img src=\"https://z3.ax1x.com/2021/12/01/oGvMz8.png\" alt=\"oGvMz8.png\"></a></p>\n<p>右上角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>左下角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=0:H-h output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>右下角：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -i logo.png -filter_complex overlay=W-w:H-h output.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"8-3-去掉视频的logo\"><a href=\"#8-3-去掉视频的logo\" class=\"headerlink\" title=\"8.3 去掉视频的logo\"></a>8.3 去掉视频的logo</h6><p>有时候，下载了某个网站的视频，但是有logo很烦，咋办？有办法，用ffmpeg的delogo过滤器。<br>语法：-vf delogo=x:y:w:h[:t[:show]]<br>x:y 离左上角的坐标<br>w:h logo的宽和高<br>t: 矩形边缘的厚度默认值4<br>show：若设置为1有一个绿色的矩形，默认值0。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>结果如下所示：</p>\n<p><a href=\"https://imgtu.com/i/otnJRf\"><img src=\"https://z3.ax1x.com/2021/12/02/otnJRf.png\" alt=\"otnJRf.png\"></a></p>\n<h5 id=\"9-抓取视频的一些帧，存为jpeg图片\"><a href=\"#9-抓取视频的一些帧，存为jpeg图片\" class=\"headerlink\" title=\"9. 抓取视频的一些帧，存为jpeg图片\"></a>9. 抓取视频的一些帧，存为jpeg图片</h5><p>比如，一个视频，我想提取一些帧，存为图片，咋办？</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br></code></pre></td></tr></table></figure>\n\n<p>-r 表示每一秒几帧<br>-q:v表示存储jpeg的图像质量，一般2是高质量。<br>如此，ffmpeg会把input.mp4，每隔一秒，存一张图片下来。假设有60s，那会有60张。</p>\n<p><a href=\"https://imgtu.com/i/otMusU\"><img src=\"https://z3.ax1x.com/2021/12/02/otMusU.png\" alt=\"otMusU.png\"></a></p>\n<p>60张？什么？这么多？不要不要。。。。。不要咋办？？<br>可以设置开始的时间，和你想要截取的时间呀。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -ss 00:00:20 -t 10 -r 1 -q:v 2 -f image2 pic-%03d.jpeg<br></code></pre></td></tr></table></figure>\n\n<p>-ss 表示开始时间<br>-t表示共要多少时间。<br>如此，ffmpeg会从input.mp4的第20s时间开始，往下10s，即20~30s这10秒钟之间，每隔1s就抓一帧，总共会抓10帧。<br><a href=\"https://imgtu.com/i/otQAmD\"><img src=\"https://z3.ax1x.com/2021/12/02/otQAmD.png\" alt=\"otQAmD.png\"></a></p>\n<h5 id=\"10-将带透明的png图片转为带透明的webM视频\"><a href=\"#10-将带透明的png图片转为带透明的webM视频\" class=\"headerlink\" title=\"10. 将带透明的png图片转为带透明的webM视频\"></a>10. 将带透明的png图片转为带透明的webM视频</h5><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -f image2 -i cap_%d.png -c:v libvpx -auto-alt-ref 0 -r 10000 ./out_vp8.webm<br></code></pre></td></tr></table></figure>\n\n<h5 id=\"11-视频与音频合并\"><a href=\"#11-视频与音频合并\" class=\"headerlink\" title=\"11. 视频与音频合并\"></a>11. 视频与音频合并</h5><h6 id=\"11-1-视频本身有声音的情况\"><a href=\"#11-1-视频本身有声音的情况\" class=\"headerlink\" title=\"11.1 视频本身有声音的情况\"></a>11.1 视频本身有声音的情况</h6><p>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input_video.mp4 -i input_audio.mp3 -c:v copy -c:a aac -map 0:v:0 -map 1:a:0 output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>最后时长是音频或视频的时长的最大值。</p>\n<p>-map的意思是，使用第一个输入源的视频，第二个输入源的音频</p>\n<h6 id=\"11-2-视频本身没声音的情况\"><a href=\"#11-2-视频本身没声音的情况\" class=\"headerlink\" title=\"11.2 视频本身没声音的情况\"></a>11.2 视频本身没声音的情况</h6><p>命令：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i video.mp4 -i audio.mp3 -c:v copy -c:a aac output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>如果合并希望视频或音频哪个先结束，就完成合并，则加一个参数-shortest</p>\n<h6 id=\"11-3-剪切视频的部分区域\"><a href=\"#11-3-剪切视频的部分区域\" class=\"headerlink\" title=\"11.3 剪切视频的部分区域\"></a>11.3 剪切视频的部分区域</h6><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i in.mp4 -filter:v <span class=\"hljs-string\">&quot;crop=out_w:out_h:x:y&quot;</span> out.mp4<br></code></pre></td></tr></table></figure>\n\n<p>out_w 视频截取的宽<br>out_h 视频截取的高<br>x and y 截取的左上角坐标</p>\n<p>例如，把一个1080p的横屏视频，截取为一个宽高为576x1024的竖屏视频</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input.mp4 -filter:v <span class=\"hljs-string\">&quot;crop=576:1024:0:0&quot;</span> cut_out.mp4<br></code></pre></td></tr></table></figure>\n\n<h6 id=\"11-4-合并2个视频\"><a href=\"#11-4-合并2个视频\" class=\"headerlink\" title=\"11.4 合并2个视频\"></a>11.4 合并2个视频</h6><p>最好2个视频是同样格式以及大小。<br>用如下3个命令，先把2个输入文件转为临时文件，保证格式一样，然后合并<br>合并2个视频：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">ffmpeg -i input1.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate1.ts<br>ffmpeg -i input2.mp4 -c copy -bsf:v h264_mp4toannexb -f mpegts intermediate2.ts<br>ffmpeg -i <span class=\"hljs-string\">&quot;concat:intermediate1.ts|intermediate2.ts&quot;</span> -c copy -bsf:a aac_adtstoasc output.mp4<br></code></pre></td></tr></table></figure>\n\n<p>–未完待续–</p>\n"},{"title":"vue-cli配置说明","date":"2021-10-20T02:21:32.000Z","_content":"\n### vue-cli中配置多个代理\n\n如果要研究vue-cli工具，一定要仔细阅读官方文档\n\n[vue-cli官方配置文档](http://vuejs-templates.github.io/webpack/commands.html)\n\n[vue-cli脚手架](https://cli.vuejs.org/zh/guide/)\n\n### 一、cli2 和cli3的区别\n\n在介绍配置之前有必要先介绍一下，cli2和cli3的区别\n\n#### 目录的区别\n\n#### ![](https://z3.ax1x.com/2021/10/20/5BP1Re.png)\n\nvue-cli 3.0的项目摈弃了 **config 、 build 、 static** 目录，新增了 **public** 目录，将根目录下的 index.html 放置在 public 目录下。\n\n新增 **webpack** 的配置文件 **vue.config.js** ，可以在该文件中进行webpack的相关配置，例如 **loader、开发环境**等等。\n\n新增 .**browserslistrc** 文件，指定了项目的目标浏览器的范围，用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀，可以理解为浏览器兼容。\n\n新增 **babel.config.js** 替代原先的**.babelrc**，具备和原先.babelrc一样的作用。\n\nsrc文件夹中多了 views 文件夹，相比2.0，在 index.js 变为了 router.js\n\n2.0版本相比3.0版本 有build和config文件夹等，src文件夹中有router文件夹，里面有index.js\n\n#### 启动项目\n\n3.x启动项目：\n\n```undefined\nnpm run serve\n```\n\n2.x启动项目：\n\n```undefined\nnpm run dev  或   npm run start\n```\n\n#### 配置项\n\n![](https://z3.ax1x.com/2021/10/20/5BApy4.png)\n\nvue-cli2.0的域名配置，分为开发环境和生产环境，所以配置域名时，需要在**config中的dev.env.js和prod.env.js中分别配置**\n\n前面说过，到了3.0 config文件已经被移除，但是多了.env.production和env.development文件，除了文件位置，实际配置起来和2.0没什么不同\n\n当然，没了config文件，**跨域需要配置域名时，从config/index.js 挪到了vue.config.js中，配置方法不变**\n\n### 二、vue.config.js配置\n\nvue-cli 3.x 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，**需要手动在根目录中创建 vue.config.js**。vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。\n\n```bash\nmodule.exports = {\n    // 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath\n    // baseUrl: process.env.NODE_ENV === 'production' ? './' : '/' \n    publicPath: process.env.NODE_ENV === 'production' ? '/public/' : './',\n    // 输出文件目录：在npm run build时，生成文件的目录名称 \n    outputDir: 'dist',\n    // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 \n    assetsDir: \"assets\",\n    // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度 \n    productionSourceMap: false,\n    // 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存，你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变)\n    filenameHashing: false,\n    // 代码保存时进行eslint检测\n    lintOnSave: false,\n    // webpack-dev-server 相关配置\n    devServer: {\n        // 自动打开浏览器\n        open: true,\n        host: 'localhost',\n        // 端口\n        port: 9930,\n        // https\n        https: false,\n        // 热更新\n        hotOnly: false,\n        // 使用代理\n        proxy: {\n            '/api': {\n                // 目标代理服务器地址\n                target: 'http://47.100.47.3/',\n                // 开启代理，本地创建一个虚拟服务器 允许跨域\n                changeOrigin: true, \n            },\n        },\n    },\n}\n```\n\n### 三、cli2设置多个反向代理\n\n设置\n\n```bash\nproxyTable: {\n  sencod: {\n    target: 'https://cnodejs.org/',     //这里只是例子\n        filter(pathname, req) {\n          // console.info('pathname',pathname)\n          const isApi = pathname.indexOf('/api') == 0;   //这里的abc是和后台商量好=>api\n          const ret = isApi;\n          return ret;\n        },\n        changeOrigin: true,\n    },\n  three: {\n    target: ' https://easy-mock.com/mock/59d78f3b9d/', //另外的一个接口例如mock的\n        filter(pathname, req) {\n          // console.info('pathname',pathname)\n          const isApi = pathname.indexOf('/baseapi') == 0;   //这里的abc是和后台商量好=>baseapi\n          const ret = isApi;\n          return ret;\n        },\n        changeOrigin: true,\n      },\n    },\n```\n\n调用\n\n```bash\nmethods: {\n      getData() {\n        axios.get('/api/v1/topics', { //cnodejs的接口\n          params: {\n            page: 20,\n            limit: 10\n          }\n        })\n          .then(function (response) {\n            //console.log(response);\n          })\n          .catch(function (error) {\n            //console.log(error);\n          });\n      },\n      getDatathree() {\n        axios.get('/baseapi/table') //easy-mock的模拟出来的接口\n          .then(function (response) {\n            console.log(response);\n          })\n          .catch(function (error) {\n            console.log(error);\n          });\n      }\n    },\n```\n\n### 四、cli3设置多个反向代理\n\n设置\n\n```bash\nmodule.exports = {\n    publicPath: '/',\n    outputDir: 'dist',\n    assetsDir: 'static',\n    filenameHashing: true,\n    devServer: {\n      open: true,  // 自动打开浏览器\n      host: '127.0.0.1',\n      port: 8081,\n      https: false,\n      hotOnly: false,\n      disableHostCheck: true,\n      proxy: {\n          \"/api\": {\n              target: 'http://xxxxxxx', // 这个地址结尾我原本加了一个‘/’,然后一直报404，去掉就好了\n              changeOrigin: true,\n              pathRewrite: {\n                  '^/api': '/'\n              }\n          },\n          '/bpi': {\n              target: \"http://xxxxxx\", // 目标地址\n              ws: true,  // 是否启用websockets\n              changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题\n              pathRewrite: {\n                '^/bpi': '/'  //这里重写路径\n            }\n          },\n          '/cpi': {\n              target: 'http://',\n              changeOrigin: true,\n              pathRewrite: {\n                '^/cpi': '/'\n            }\n          }\n      },\n  \n      before: app => {\n      }\n    },\n    // 构建时开启多进程处理 babel 编译\n    parallel: require('os').cpus().length > 1,\n  \n    // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa\n    pwa: {},\n  \n    // 第三方插件配置\n    pluginOptions: {}\n  };\n```\n\n调用\n\n1. 在main.js里面，设置baseURL，Vue.prototype.$http=axios; 这里根据实际需要设置请求头之类的\n\n```bash\nthis.$http({\n    method: 'post',\n    url: '/api/xxx/xxx',\n    data: params\n}).then(res => {\n    console.log(res.data)\n}).catch(error => {\n    console.log(error)\n})\n```\n\n### 五、一句话总结\n\n配置多个反向代理需要前端或后端约定,url中判断出区别从而代理到不同的接口\n\n### 六、其他\n\n#### 一、产生原因\n\n- 跨域是a页面想要获取b页面资源，如果a,b页面的协议、域名、端口号、子域名不同，所进行的访问都是跨域的，而浏览器一般为了安全都限制了跨域访问，也就是不允许跨域访问资源。\n\n#### 二、解决办法\n\n##### 1.JSONP\n\n- JSONP是一个非官方协议，它允许在服务器端集成script tags返回至客户端，通过javascript callback的形式实现跨域访问。\n- 基本思想：网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n\n\n```xml\n    <script type=\"text/javascript\">\n        function jsonpCallback(result){\n            //alert(result);\n            for(var i in result){\n                alert(i + \":\" + result[i]);     //循环输出\n            }\n        }\n        var JSONP = document.createElement(\"script\");\n        JSONP.type = \"text/javascript\";\n        JSONP.src = \"http://crossdomain.com/services.php?callback=jsonpCallback\";\n        document.getElementsByTagName(\"head\")[0].appendChild(JSONP);\n    </script>\n```\n\n##### 2.window.name\n\n- window.name+iframe需要目标服务器响应window.name，window对象有一个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window. name都有读写的权利，window.name 是持久存在一个窗口载入过的所有页面中的！\n\n##### 3.window.postMessage\n\n- HTML5引入了一个全新的API：跨文档消息传输Cross Document Messaging 。它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略对web sockets不适用）\n- web sockets原理：在JS创建了web sockets之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockets协议。\n- `otherWindow.postMessage(message, targetOrigin)`\n   otherWindow：指目标窗口，也就是给哪个窗口发消息，是window.frames属性的成员或者由window.open方法创建的窗口。\n   参数说明：\n   (1)message：是要发送的消息，类型为string，object\n   (2)targetOrigin：是限定消息接收范围，不限制使用“ * ”\n\n##### 4.CORS\n\n- 基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n\n##### 5.web sockets\n\n- web sockets是浏览器的一种API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)\n- web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。\n\n","source":"_posts/vue-cli配置说明.md","raw":"---\ntitle: vue-cli配置说明\ndate: 2021-10-20 10:21:32\ntags: vue2\ncategories:\n- 知识复习\n\n---\n\n### vue-cli中配置多个代理\n\n如果要研究vue-cli工具，一定要仔细阅读官方文档\n\n[vue-cli官方配置文档](http://vuejs-templates.github.io/webpack/commands.html)\n\n[vue-cli脚手架](https://cli.vuejs.org/zh/guide/)\n\n### 一、cli2 和cli3的区别\n\n在介绍配置之前有必要先介绍一下，cli2和cli3的区别\n\n#### 目录的区别\n\n#### ![](https://z3.ax1x.com/2021/10/20/5BP1Re.png)\n\nvue-cli 3.0的项目摈弃了 **config 、 build 、 static** 目录，新增了 **public** 目录，将根目录下的 index.html 放置在 public 目录下。\n\n新增 **webpack** 的配置文件 **vue.config.js** ，可以在该文件中进行webpack的相关配置，例如 **loader、开发环境**等等。\n\n新增 .**browserslistrc** 文件，指定了项目的目标浏览器的范围，用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀，可以理解为浏览器兼容。\n\n新增 **babel.config.js** 替代原先的**.babelrc**，具备和原先.babelrc一样的作用。\n\nsrc文件夹中多了 views 文件夹，相比2.0，在 index.js 变为了 router.js\n\n2.0版本相比3.0版本 有build和config文件夹等，src文件夹中有router文件夹，里面有index.js\n\n#### 启动项目\n\n3.x启动项目：\n\n```undefined\nnpm run serve\n```\n\n2.x启动项目：\n\n```undefined\nnpm run dev  或   npm run start\n```\n\n#### 配置项\n\n![](https://z3.ax1x.com/2021/10/20/5BApy4.png)\n\nvue-cli2.0的域名配置，分为开发环境和生产环境，所以配置域名时，需要在**config中的dev.env.js和prod.env.js中分别配置**\n\n前面说过，到了3.0 config文件已经被移除，但是多了.env.production和env.development文件，除了文件位置，实际配置起来和2.0没什么不同\n\n当然，没了config文件，**跨域需要配置域名时，从config/index.js 挪到了vue.config.js中，配置方法不变**\n\n### 二、vue.config.js配置\n\nvue-cli 3.x 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，**需要手动在根目录中创建 vue.config.js**。vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。\n\n```bash\nmodule.exports = {\n    // 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath\n    // baseUrl: process.env.NODE_ENV === 'production' ? './' : '/' \n    publicPath: process.env.NODE_ENV === 'production' ? '/public/' : './',\n    // 输出文件目录：在npm run build时，生成文件的目录名称 \n    outputDir: 'dist',\n    // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 \n    assetsDir: \"assets\",\n    // 是否在构建生产包时生成 sourceMap 文件，false将提高构建速度 \n    productionSourceMap: false,\n    // 默认情况下，生成的静态资源在它们的文件名中包含了 hash 以便更好的控制缓存，你可以通过将这个选项设为 false 来关闭文件名哈希。(false的时候就是让原来的文件名不改变)\n    filenameHashing: false,\n    // 代码保存时进行eslint检测\n    lintOnSave: false,\n    // webpack-dev-server 相关配置\n    devServer: {\n        // 自动打开浏览器\n        open: true,\n        host: 'localhost',\n        // 端口\n        port: 9930,\n        // https\n        https: false,\n        // 热更新\n        hotOnly: false,\n        // 使用代理\n        proxy: {\n            '/api': {\n                // 目标代理服务器地址\n                target: 'http://47.100.47.3/',\n                // 开启代理，本地创建一个虚拟服务器 允许跨域\n                changeOrigin: true, \n            },\n        },\n    },\n}\n```\n\n### 三、cli2设置多个反向代理\n\n设置\n\n```bash\nproxyTable: {\n  sencod: {\n    target: 'https://cnodejs.org/',     //这里只是例子\n        filter(pathname, req) {\n          // console.info('pathname',pathname)\n          const isApi = pathname.indexOf('/api') == 0;   //这里的abc是和后台商量好=>api\n          const ret = isApi;\n          return ret;\n        },\n        changeOrigin: true,\n    },\n  three: {\n    target: ' https://easy-mock.com/mock/59d78f3b9d/', //另外的一个接口例如mock的\n        filter(pathname, req) {\n          // console.info('pathname',pathname)\n          const isApi = pathname.indexOf('/baseapi') == 0;   //这里的abc是和后台商量好=>baseapi\n          const ret = isApi;\n          return ret;\n        },\n        changeOrigin: true,\n      },\n    },\n```\n\n调用\n\n```bash\nmethods: {\n      getData() {\n        axios.get('/api/v1/topics', { //cnodejs的接口\n          params: {\n            page: 20,\n            limit: 10\n          }\n        })\n          .then(function (response) {\n            //console.log(response);\n          })\n          .catch(function (error) {\n            //console.log(error);\n          });\n      },\n      getDatathree() {\n        axios.get('/baseapi/table') //easy-mock的模拟出来的接口\n          .then(function (response) {\n            console.log(response);\n          })\n          .catch(function (error) {\n            console.log(error);\n          });\n      }\n    },\n```\n\n### 四、cli3设置多个反向代理\n\n设置\n\n```bash\nmodule.exports = {\n    publicPath: '/',\n    outputDir: 'dist',\n    assetsDir: 'static',\n    filenameHashing: true,\n    devServer: {\n      open: true,  // 自动打开浏览器\n      host: '127.0.0.1',\n      port: 8081,\n      https: false,\n      hotOnly: false,\n      disableHostCheck: true,\n      proxy: {\n          \"/api\": {\n              target: 'http://xxxxxxx', // 这个地址结尾我原本加了一个‘/’,然后一直报404，去掉就好了\n              changeOrigin: true,\n              pathRewrite: {\n                  '^/api': '/'\n              }\n          },\n          '/bpi': {\n              target: \"http://xxxxxx\", // 目标地址\n              ws: true,  // 是否启用websockets\n              changeOrigin: true, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题\n              pathRewrite: {\n                '^/bpi': '/'  //这里重写路径\n            }\n          },\n          '/cpi': {\n              target: 'http://',\n              changeOrigin: true,\n              pathRewrite: {\n                '^/cpi': '/'\n            }\n          }\n      },\n  \n      before: app => {\n      }\n    },\n    // 构建时开启多进程处理 babel 编译\n    parallel: require('os').cpus().length > 1,\n  \n    // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa\n    pwa: {},\n  \n    // 第三方插件配置\n    pluginOptions: {}\n  };\n```\n\n调用\n\n1. 在main.js里面，设置baseURL，Vue.prototype.$http=axios; 这里根据实际需要设置请求头之类的\n\n```bash\nthis.$http({\n    method: 'post',\n    url: '/api/xxx/xxx',\n    data: params\n}).then(res => {\n    console.log(res.data)\n}).catch(error => {\n    console.log(error)\n})\n```\n\n### 五、一句话总结\n\n配置多个反向代理需要前端或后端约定,url中判断出区别从而代理到不同的接口\n\n### 六、其他\n\n#### 一、产生原因\n\n- 跨域是a页面想要获取b页面资源，如果a,b页面的协议、域名、端口号、子域名不同，所进行的访问都是跨域的，而浏览器一般为了安全都限制了跨域访问，也就是不允许跨域访问资源。\n\n#### 二、解决办法\n\n##### 1.JSONP\n\n- JSONP是一个非官方协议，它允许在服务器端集成script tags返回至客户端，通过javascript callback的形式实现跨域访问。\n- 基本思想：网页通过添加一个`<script>`元素，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。\n\n\n\n```xml\n    <script type=\"text/javascript\">\n        function jsonpCallback(result){\n            //alert(result);\n            for(var i in result){\n                alert(i + \":\" + result[i]);     //循环输出\n            }\n        }\n        var JSONP = document.createElement(\"script\");\n        JSONP.type = \"text/javascript\";\n        JSONP.src = \"http://crossdomain.com/services.php?callback=jsonpCallback\";\n        document.getElementsByTagName(\"head\")[0].appendChild(JSONP);\n    </script>\n```\n\n##### 2.window.name\n\n- window.name+iframe需要目标服务器响应window.name，window对象有一个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window. name都有读写的权利，window.name 是持久存在一个窗口载入过的所有页面中的！\n\n##### 3.window.postMessage\n\n- HTML5引入了一个全新的API：跨文档消息传输Cross Document Messaging 。它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略对web sockets不适用）\n- web sockets原理：在JS创建了web sockets之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockets协议。\n- `otherWindow.postMessage(message, targetOrigin)`\n   otherWindow：指目标窗口，也就是给哪个窗口发消息，是window.frames属性的成员或者由window.open方法创建的窗口。\n   参数说明：\n   (1)message：是要发送的消息，类型为string，object\n   (2)targetOrigin：是限定消息接收范围，不限制使用“ * ”\n\n##### 4.CORS\n\n- 基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。\n\n##### 5.web sockets\n\n- web sockets是浏览器的一种API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)\n- web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。\n\n","slug":"vue-cli配置说明","published":1,"updated":"2022-11-20T05:15:37.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvex0005b0gihmkpa5m0","content":"<h3 id=\"vue-cli中配置多个代理\"><a href=\"#vue-cli中配置多个代理\" class=\"headerlink\" title=\"vue-cli中配置多个代理\"></a>vue-cli中配置多个代理</h3><p>如果要研究vue-cli工具，一定要仔细阅读官方文档</p>\n<p><a href=\"http://vuejs-templates.github.io/webpack/commands.html\">vue-cli官方配置文档</a></p>\n<p><a href=\"https://cli.vuejs.org/zh/guide/\">vue-cli脚手架</a></p>\n<h3 id=\"一、cli2-和cli3的区别\"><a href=\"#一、cli2-和cli3的区别\" class=\"headerlink\" title=\"一、cli2 和cli3的区别\"></a>一、cli2 和cli3的区别</h3><p>在介绍配置之前有必要先介绍一下，cli2和cli3的区别</p>\n<h4 id=\"目录的区别\"><a href=\"#目录的区别\" class=\"headerlink\" title=\"目录的区别\"></a>目录的区别</h4><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://z3.ax1x.com/2021/10/20/5BP1Re.png\"></h4><p>vue-cli 3.0的项目摈弃了 <strong>config 、 build 、 static</strong> 目录，新增了 <strong>public</strong> 目录，将根目录下的 index.html 放置在 public 目录下。</p>\n<p>新增 <strong>webpack</strong> 的配置文件 <strong>vue.config.js</strong> ，可以在该文件中进行webpack的相关配置，例如 <strong>loader、开发环境</strong>等等。</p>\n<p>新增 .<strong>browserslistrc</strong> 文件，指定了项目的目标浏览器的范围，用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀，可以理解为浏览器兼容。</p>\n<p>新增 <strong>babel.config.js</strong> 替代原先的**.babelrc**，具备和原先.babelrc一样的作用。</p>\n<p>src文件夹中多了 views 文件夹，相比2.0，在 index.js 变为了 router.js</p>\n<p>2.0版本相比3.0版本 有build和config文件夹等，src文件夹中有router文件夹，里面有index.js</p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p>3.x启动项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">npm run serve<br></code></pre></td></tr></table></figure>\n\n<p>2.x启动项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">npm run dev  或   npm run start<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"配置项\"><a href=\"#配置项\" class=\"headerlink\" title=\"配置项\"></a>配置项</h4><p><img src=\"https://z3.ax1x.com/2021/10/20/5BApy4.png\"></p>\n<p>vue-cli2.0的域名配置，分为开发环境和生产环境，所以配置域名时，需要在<strong>config中的dev.env.js和prod.env.js中分别配置</strong></p>\n<p>前面说过，到了3.0 config文件已经被移除，但是多了.env.production和env.development文件，除了文件位置，实际配置起来和2.0没什么不同</p>\n<p>当然，没了config文件，<strong>跨域需要配置域名时，从config/index.js 挪到了vue.config.js中，配置方法不变</strong></p>\n<h3 id=\"二、vue-config-js配置\"><a href=\"#二、vue-config-js配置\" class=\"headerlink\" title=\"二、vue.config.js配置\"></a>二、vue.config.js配置</h3><p>vue-cli 3.x 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，<strong>需要手动在根目录中创建 vue.config.js</strong>。vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">module.exports = &#123;<br>    // 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath<br>    // baseUrl: process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;production&#x27;</span> ? <span class=\"hljs-string\">&#x27;./&#x27;</span> : <span class=\"hljs-string\">&#x27;/&#x27;</span> <br>    publicPath: process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;production&#x27;</span> ? <span class=\"hljs-string\">&#x27;/public/&#x27;</span> : <span class=\"hljs-string\">&#x27;./&#x27;</span>,<br>    // 输出文件目录：在npm run build时，生成文件的目录名称 <br>    outputDir: <span class=\"hljs-string\">&#x27;dist&#x27;</span>,<br>    // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 <br>    assetsDir: <span class=\"hljs-string\">&quot;assets&quot;</span>,<br>    // 是否在构建生产包时生成 sourceMap 文件，<span class=\"hljs-literal\">false</span>将提高构建速度 <br>    productionSourceMap: <span class=\"hljs-literal\">false</span>,<br>    // 默认情况下，生成的静态资源在它们的文件名中包含了 <span class=\"hljs-built_in\">hash</span> 以便更好的控制缓存，你可以通过将这个选项设为 <span class=\"hljs-literal\">false</span> 来关闭文件名哈希。(<span class=\"hljs-literal\">false</span>的时候就是让原来的文件名不改变)<br>    filenameHashing: <span class=\"hljs-literal\">false</span>,<br>    // 代码保存时进行eslint检测<br>    lintOnSave: <span class=\"hljs-literal\">false</span>,<br>    // webpack-dev-server 相关配置<br>    devServer: &#123;<br>        // 自动打开浏览器<br>        open: <span class=\"hljs-literal\">true</span>,<br>        host: <span class=\"hljs-string\">&#x27;localhost&#x27;</span>,<br>        // 端口<br>        port: 9930,<br>        // https<br>        https: <span class=\"hljs-literal\">false</span>,<br>        // 热更新<br>        hotOnly: <span class=\"hljs-literal\">false</span>,<br>        // 使用代理<br>        proxy: &#123;<br>            <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>                // 目标代理服务器地址<br>                target: <span class=\"hljs-string\">&#x27;http://47.100.47.3/&#x27;</span>,<br>                // 开启代理，本地创建一个虚拟服务器 允许跨域<br>                changeOrigin: <span class=\"hljs-literal\">true</span>, <br>            &#125;,<br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"三、cli2设置多个反向代理\"><a href=\"#三、cli2设置多个反向代理\" class=\"headerlink\" title=\"三、cli2设置多个反向代理\"></a>三、cli2设置多个反向代理</h3><p>设置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">proxyTable: &#123;<br>  sencod: &#123;<br>    target: <span class=\"hljs-string\">&#x27;https://cnodejs.org/&#x27;</span>,     //这里只是例子<br>        filter(pathname, req) &#123;<br>          // console.info(<span class=\"hljs-string\">&#x27;pathname&#x27;</span>,pathname)<br>          const isApi = pathname.indexOf(<span class=\"hljs-string\">&#x27;/api&#x27;</span>) == 0;   //这里的abc是和后台商量好=&gt;api<br>          const ret = isApi;<br>          <span class=\"hljs-built_in\">return</span> ret;<br>        &#125;,<br>        changeOrigin: <span class=\"hljs-literal\">true</span>,<br>    &#125;,<br>  three: &#123;<br>    target: <span class=\"hljs-string\">&#x27; https://easy-mock.com/mock/59d78f3b9d/&#x27;</span>, //另外的一个接口例如mock的<br>        filter(pathname, req) &#123;<br>          // console.info(<span class=\"hljs-string\">&#x27;pathname&#x27;</span>,pathname)<br>          const isApi = pathname.indexOf(<span class=\"hljs-string\">&#x27;/baseapi&#x27;</span>) == 0;   //这里的abc是和后台商量好=&gt;baseapi<br>          const ret = isApi;<br>          <span class=\"hljs-built_in\">return</span> ret;<br>        &#125;,<br>        changeOrigin: <span class=\"hljs-literal\">true</span>,<br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure>\n\n<p>调用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">methods: &#123;<br>      <span class=\"hljs-function\"><span class=\"hljs-title\">getData</span></span>() &#123;<br>        axios.get(<span class=\"hljs-string\">&#x27;/api/v1/topics&#x27;</span>, &#123; //cnodejs的接口<br>          params: &#123;<br>            page: 20,<br>            <span class=\"hljs-built_in\">limit</span>: 10<br>          &#125;<br>        &#125;)<br>          .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-keyword\">function</span> (response) &#123;<br>            //console.log(response);<br>          &#125;)<br>          .catch(<span class=\"hljs-keyword\">function</span> (error) &#123;<br>            //console.log(error);<br>          &#125;);<br>      &#125;,<br>      <span class=\"hljs-function\"><span class=\"hljs-title\">getDatathree</span></span>() &#123;<br>        axios.get(<span class=\"hljs-string\">&#x27;/baseapi/table&#x27;</span>) //easy-mock的模拟出来的接口<br>          .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-keyword\">function</span> (response) &#123;<br>            console.log(response);<br>          &#125;)<br>          .catch(<span class=\"hljs-keyword\">function</span> (error) &#123;<br>            console.log(error);<br>          &#125;);<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"四、cli3设置多个反向代理\"><a href=\"#四、cli3设置多个反向代理\" class=\"headerlink\" title=\"四、cli3设置多个反向代理\"></a>四、cli3设置多个反向代理</h3><p>设置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">module.exports = &#123;<br>    publicPath: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>    outputDir: <span class=\"hljs-string\">&#x27;dist&#x27;</span>,<br>    assetsDir: <span class=\"hljs-string\">&#x27;static&#x27;</span>,<br>    filenameHashing: <span class=\"hljs-literal\">true</span>,<br>    devServer: &#123;<br>      open: <span class=\"hljs-literal\">true</span>,  // 自动打开浏览器<br>      host: <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>,<br>      port: 8081,<br>      https: <span class=\"hljs-literal\">false</span>,<br>      hotOnly: <span class=\"hljs-literal\">false</span>,<br>      disableHostCheck: <span class=\"hljs-literal\">true</span>,<br>      proxy: &#123;<br>          <span class=\"hljs-string\">&quot;/api&quot;</span>: &#123;<br>              target: <span class=\"hljs-string\">&#x27;http://xxxxxxx&#x27;</span>, // 这个地址结尾我原本加了一个‘/’,然后一直报404，去掉就好了<br>              changeOrigin: <span class=\"hljs-literal\">true</span>,<br>              pathRewrite: &#123;<br>                  <span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span><br>              &#125;<br>          &#125;,<br>          <span class=\"hljs-string\">&#x27;/bpi&#x27;</span>: &#123;<br>              target: <span class=\"hljs-string\">&quot;http://xxxxxx&quot;</span>, // 目标地址<br>              ws: <span class=\"hljs-literal\">true</span>,  // 是否启用websockets<br>              changeOrigin: <span class=\"hljs-literal\">true</span>, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题<br>              pathRewrite: &#123;<br>                <span class=\"hljs-string\">&#x27;^/bpi&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>  //这里重写路径<br>            &#125;<br>          &#125;,<br>          <span class=\"hljs-string\">&#x27;/cpi&#x27;</span>: &#123;<br>              target: <span class=\"hljs-string\">&#x27;http://&#x27;</span>,<br>              changeOrigin: <span class=\"hljs-literal\">true</span>,<br>              pathRewrite: &#123;<br>                <span class=\"hljs-string\">&#x27;^/cpi&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span><br>            &#125;<br>          &#125;<br>      &#125;,<br>  <br>      before: app =&gt; &#123;<br>      &#125;<br>    &#125;,<br>    // 构建时开启多进程处理 babel 编译<br>    parallel: require(<span class=\"hljs-string\">&#x27;os&#x27;</span>).cpus().length &gt; 1,<br>  <br>    // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa<br>    pwa: &#123;&#125;,<br>  <br>    // 第三方插件配置<br>    pluginOptions: &#123;&#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>调用</p>\n<ol>\n<li>在main.js里面，设置baseURL，Vue.prototype.$http=axios; 这里根据实际需要设置请求头之类的</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">this.<span class=\"hljs-variable\">$http</span>(&#123;<br>    method: <span class=\"hljs-string\">&#x27;post&#x27;</span>,<br>    url: <span class=\"hljs-string\">&#x27;/api/xxx/xxx&#x27;</span>,<br>    data: params<br>&#125;).<span class=\"hljs-keyword\">then</span>(res =&gt; &#123;<br>    console.log(res.data)<br>&#125;).catch(error =&gt; &#123;<br>    console.log(error)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"五、一句话总结\"><a href=\"#五、一句话总结\" class=\"headerlink\" title=\"五、一句话总结\"></a>五、一句话总结</h3><p>配置多个反向代理需要前端或后端约定,url中判断出区别从而代理到不同的接口</p>\n<h3 id=\"六、其他\"><a href=\"#六、其他\" class=\"headerlink\" title=\"六、其他\"></a>六、其他</h3><h4 id=\"一、产生原因\"><a href=\"#一、产生原因\" class=\"headerlink\" title=\"一、产生原因\"></a>一、产生原因</h4><ul>\n<li>跨域是a页面想要获取b页面资源，如果a,b页面的协议、域名、端口号、子域名不同，所进行的访问都是跨域的，而浏览器一般为了安全都限制了跨域访问，也就是不允许跨域访问资源。</li>\n</ul>\n<h4 id=\"二、解决办法\"><a href=\"#二、解决办法\" class=\"headerlink\" title=\"二、解决办法\"></a>二、解决办法</h4><h5 id=\"1-JSONP\"><a href=\"#1-JSONP\" class=\"headerlink\" title=\"1.JSONP\"></a>1.JSONP</h5><ul>\n<li>JSONP是一个非官方协议，它允许在服务器端集成script tags返回至客户端，通过javascript callback的形式实现跨域访问。</li>\n<li>基本思想：网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonpCallback</span>(<span class=\"hljs-params\">result</span>)</span>&#123;</span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//alert(result);</span></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> result)&#123;</span><br><span class=\"javascript\">            alert(i + <span class=\"hljs-string\">&quot;:&quot;</span> + result[i]);     <span class=\"hljs-comment\">//循环输出</span></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">    &#125;</span><br><span class=\"javascript\">    <span class=\"hljs-keyword\">var</span> JSONP = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;script&quot;</span>);</span><br><span class=\"javascript\">    JSONP.type = <span class=\"hljs-string\">&quot;text/javascript&quot;</span>;</span><br><span class=\"javascript\">    JSONP.src = <span class=\"hljs-string\">&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;</span>;</span><br><span class=\"javascript\">    <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">&quot;head&quot;</span>)[<span class=\"hljs-number\">0</span>].appendChild(JSONP);</span><br><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-window-name\"><a href=\"#2-window-name\" class=\"headerlink\" title=\"2.window.name\"></a>2.window.name</h5><ul>\n<li>window.name+iframe需要目标服务器响应window.name，window对象有一个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window. name都有读写的权利，window.name 是持久存在一个窗口载入过的所有页面中的！</li>\n</ul>\n<h5 id=\"3-window-postMessage\"><a href=\"#3-window-postMessage\" class=\"headerlink\" title=\"3.window.postMessage\"></a>3.window.postMessage</h5><ul>\n<li>HTML5引入了一个全新的API：跨文档消息传输Cross Document Messaging 。它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略对web sockets不适用）</li>\n<li>web sockets原理：在JS创建了web sockets之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockets协议。</li>\n<li><code>otherWindow.postMessage(message, targetOrigin)</code><br> otherWindow：指目标窗口，也就是给哪个窗口发消息，是window.frames属性的成员或者由window.open方法创建的窗口。<br> 参数说明：<br> (1)message：是要发送的消息，类型为string，object<br> (2)targetOrigin：是限定消息接收范围，不限制使用“ * ”</li>\n</ul>\n<h5 id=\"4-CORS\"><a href=\"#4-CORS\" class=\"headerlink\" title=\"4.CORS\"></a>4.CORS</h5><ul>\n<li>基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</li>\n</ul>\n<h5 id=\"5-web-sockets\"><a href=\"#5-web-sockets\" class=\"headerlink\" title=\"5.web sockets\"></a>5.web sockets</h5><ul>\n<li>web sockets是浏览器的一种API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</li>\n<li>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</li>\n</ul>\n","site":{"data":{}},"wordcount":6059,"excerpt":"","more":"<h3 id=\"vue-cli中配置多个代理\"><a href=\"#vue-cli中配置多个代理\" class=\"headerlink\" title=\"vue-cli中配置多个代理\"></a>vue-cli中配置多个代理</h3><p>如果要研究vue-cli工具，一定要仔细阅读官方文档</p>\n<p><a href=\"http://vuejs-templates.github.io/webpack/commands.html\">vue-cli官方配置文档</a></p>\n<p><a href=\"https://cli.vuejs.org/zh/guide/\">vue-cli脚手架</a></p>\n<h3 id=\"一、cli2-和cli3的区别\"><a href=\"#一、cli2-和cli3的区别\" class=\"headerlink\" title=\"一、cli2 和cli3的区别\"></a>一、cli2 和cli3的区别</h3><p>在介绍配置之前有必要先介绍一下，cli2和cli3的区别</p>\n<h4 id=\"目录的区别\"><a href=\"#目录的区别\" class=\"headerlink\" title=\"目录的区别\"></a>目录的区别</h4><h4 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a><img src=\"https://z3.ax1x.com/2021/10/20/5BP1Re.png\"></h4><p>vue-cli 3.0的项目摈弃了 <strong>config 、 build 、 static</strong> 目录，新增了 <strong>public</strong> 目录，将根目录下的 index.html 放置在 public 目录下。</p>\n<p>新增 <strong>webpack</strong> 的配置文件 <strong>vue.config.js</strong> ，可以在该文件中进行webpack的相关配置，例如 <strong>loader、开发环境</strong>等等。</p>\n<p>新增 .<strong>browserslistrc</strong> 文件，指定了项目的目标浏览器的范围，用来确定需要转译的 JavaScript 特性和需要添加的 CSS 浏览器前缀，可以理解为浏览器兼容。</p>\n<p>新增 <strong>babel.config.js</strong> 替代原先的**.babelrc**，具备和原先.babelrc一样的作用。</p>\n<p>src文件夹中多了 views 文件夹，相比2.0，在 index.js 变为了 router.js</p>\n<p>2.0版本相比3.0版本 有build和config文件夹等，src文件夹中有router文件夹，里面有index.js</p>\n<h4 id=\"启动项目\"><a href=\"#启动项目\" class=\"headerlink\" title=\"启动项目\"></a>启动项目</h4><p>3.x启动项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">npm run serve<br></code></pre></td></tr></table></figure>\n\n<p>2.x启动项目：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs undefined\">npm run dev  或   npm run start<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"配置项\"><a href=\"#配置项\" class=\"headerlink\" title=\"配置项\"></a>配置项</h4><p><img src=\"https://z3.ax1x.com/2021/10/20/5BApy4.png\"></p>\n<p>vue-cli2.0的域名配置，分为开发环境和生产环境，所以配置域名时，需要在<strong>config中的dev.env.js和prod.env.js中分别配置</strong></p>\n<p>前面说过，到了3.0 config文件已经被移除，但是多了.env.production和env.development文件，除了文件位置，实际配置起来和2.0没什么不同</p>\n<p>当然，没了config文件，<strong>跨域需要配置域名时，从config/index.js 挪到了vue.config.js中，配置方法不变</strong></p>\n<h3 id=\"二、vue-config-js配置\"><a href=\"#二、vue-config-js配置\" class=\"headerlink\" title=\"二、vue.config.js配置\"></a>二、vue.config.js配置</h3><p>vue-cli 3.x 脚手架搭建完成后，项目目录中没有 vue.config.js 文件，<strong>需要手动在根目录中创建 vue.config.js</strong>。vue.config.js 是一个可选的配置文件，如果项目的 (和 package.json 同级的) 根目录中存在这个文件，那么它会被 @vue/cli-service 自动加载。你也可以使用 package.json 中的 vue 字段，但是注意这种写法需要你严格遵照 JSON 的格式来写。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">module.exports = &#123;<br>    // 部署生产环境和开发环境下的URL：可对当前环境进行区分，baseUrl 从 Vue CLI 3.3 起已弃用，要使用publicPath<br>    // baseUrl: process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;production&#x27;</span> ? <span class=\"hljs-string\">&#x27;./&#x27;</span> : <span class=\"hljs-string\">&#x27;/&#x27;</span> <br>    publicPath: process.env.NODE_ENV === <span class=\"hljs-string\">&#x27;production&#x27;</span> ? <span class=\"hljs-string\">&#x27;/public/&#x27;</span> : <span class=\"hljs-string\">&#x27;./&#x27;</span>,<br>    // 输出文件目录：在npm run build时，生成文件的目录名称 <br>    outputDir: <span class=\"hljs-string\">&#x27;dist&#x27;</span>,<br>    // 放置生成的静态资源 (js、css、img、fonts) 的 (相对于 outputDir 的) 目录 <br>    assetsDir: <span class=\"hljs-string\">&quot;assets&quot;</span>,<br>    // 是否在构建生产包时生成 sourceMap 文件，<span class=\"hljs-literal\">false</span>将提高构建速度 <br>    productionSourceMap: <span class=\"hljs-literal\">false</span>,<br>    // 默认情况下，生成的静态资源在它们的文件名中包含了 <span class=\"hljs-built_in\">hash</span> 以便更好的控制缓存，你可以通过将这个选项设为 <span class=\"hljs-literal\">false</span> 来关闭文件名哈希。(<span class=\"hljs-literal\">false</span>的时候就是让原来的文件名不改变)<br>    filenameHashing: <span class=\"hljs-literal\">false</span>,<br>    // 代码保存时进行eslint检测<br>    lintOnSave: <span class=\"hljs-literal\">false</span>,<br>    // webpack-dev-server 相关配置<br>    devServer: &#123;<br>        // 自动打开浏览器<br>        open: <span class=\"hljs-literal\">true</span>,<br>        host: <span class=\"hljs-string\">&#x27;localhost&#x27;</span>,<br>        // 端口<br>        port: 9930,<br>        // https<br>        https: <span class=\"hljs-literal\">false</span>,<br>        // 热更新<br>        hotOnly: <span class=\"hljs-literal\">false</span>,<br>        // 使用代理<br>        proxy: &#123;<br>            <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>                // 目标代理服务器地址<br>                target: <span class=\"hljs-string\">&#x27;http://47.100.47.3/&#x27;</span>,<br>                // 开启代理，本地创建一个虚拟服务器 允许跨域<br>                changeOrigin: <span class=\"hljs-literal\">true</span>, <br>            &#125;,<br>        &#125;,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"三、cli2设置多个反向代理\"><a href=\"#三、cli2设置多个反向代理\" class=\"headerlink\" title=\"三、cli2设置多个反向代理\"></a>三、cli2设置多个反向代理</h3><p>设置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">proxyTable: &#123;<br>  sencod: &#123;<br>    target: <span class=\"hljs-string\">&#x27;https://cnodejs.org/&#x27;</span>,     //这里只是例子<br>        filter(pathname, req) &#123;<br>          // console.info(<span class=\"hljs-string\">&#x27;pathname&#x27;</span>,pathname)<br>          const isApi = pathname.indexOf(<span class=\"hljs-string\">&#x27;/api&#x27;</span>) == 0;   //这里的abc是和后台商量好=&gt;api<br>          const ret = isApi;<br>          <span class=\"hljs-built_in\">return</span> ret;<br>        &#125;,<br>        changeOrigin: <span class=\"hljs-literal\">true</span>,<br>    &#125;,<br>  three: &#123;<br>    target: <span class=\"hljs-string\">&#x27; https://easy-mock.com/mock/59d78f3b9d/&#x27;</span>, //另外的一个接口例如mock的<br>        filter(pathname, req) &#123;<br>          // console.info(<span class=\"hljs-string\">&#x27;pathname&#x27;</span>,pathname)<br>          const isApi = pathname.indexOf(<span class=\"hljs-string\">&#x27;/baseapi&#x27;</span>) == 0;   //这里的abc是和后台商量好=&gt;baseapi<br>          const ret = isApi;<br>          <span class=\"hljs-built_in\">return</span> ret;<br>        &#125;,<br>        changeOrigin: <span class=\"hljs-literal\">true</span>,<br>      &#125;,<br>    &#125;,<br></code></pre></td></tr></table></figure>\n\n<p>调用</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">methods: &#123;<br>      <span class=\"hljs-function\"><span class=\"hljs-title\">getData</span></span>() &#123;<br>        axios.get(<span class=\"hljs-string\">&#x27;/api/v1/topics&#x27;</span>, &#123; //cnodejs的接口<br>          params: &#123;<br>            page: 20,<br>            <span class=\"hljs-built_in\">limit</span>: 10<br>          &#125;<br>        &#125;)<br>          .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-keyword\">function</span> (response) &#123;<br>            //console.log(response);<br>          &#125;)<br>          .catch(<span class=\"hljs-keyword\">function</span> (error) &#123;<br>            //console.log(error);<br>          &#125;);<br>      &#125;,<br>      <span class=\"hljs-function\"><span class=\"hljs-title\">getDatathree</span></span>() &#123;<br>        axios.get(<span class=\"hljs-string\">&#x27;/baseapi/table&#x27;</span>) //easy-mock的模拟出来的接口<br>          .<span class=\"hljs-keyword\">then</span>(<span class=\"hljs-keyword\">function</span> (response) &#123;<br>            console.log(response);<br>          &#125;)<br>          .catch(<span class=\"hljs-keyword\">function</span> (error) &#123;<br>            console.log(error);<br>          &#125;);<br>      &#125;<br>    &#125;,<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"四、cli3设置多个反向代理\"><a href=\"#四、cli3设置多个反向代理\" class=\"headerlink\" title=\"四、cli3设置多个反向代理\"></a>四、cli3设置多个反向代理</h3><p>设置</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">module.exports = &#123;<br>    publicPath: <span class=\"hljs-string\">&#x27;/&#x27;</span>,<br>    outputDir: <span class=\"hljs-string\">&#x27;dist&#x27;</span>,<br>    assetsDir: <span class=\"hljs-string\">&#x27;static&#x27;</span>,<br>    filenameHashing: <span class=\"hljs-literal\">true</span>,<br>    devServer: &#123;<br>      open: <span class=\"hljs-literal\">true</span>,  // 自动打开浏览器<br>      host: <span class=\"hljs-string\">&#x27;127.0.0.1&#x27;</span>,<br>      port: 8081,<br>      https: <span class=\"hljs-literal\">false</span>,<br>      hotOnly: <span class=\"hljs-literal\">false</span>,<br>      disableHostCheck: <span class=\"hljs-literal\">true</span>,<br>      proxy: &#123;<br>          <span class=\"hljs-string\">&quot;/api&quot;</span>: &#123;<br>              target: <span class=\"hljs-string\">&#x27;http://xxxxxxx&#x27;</span>, // 这个地址结尾我原本加了一个‘/’,然后一直报404，去掉就好了<br>              changeOrigin: <span class=\"hljs-literal\">true</span>,<br>              pathRewrite: &#123;<br>                  <span class=\"hljs-string\">&#x27;^/api&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span><br>              &#125;<br>          &#125;,<br>          <span class=\"hljs-string\">&#x27;/bpi&#x27;</span>: &#123;<br>              target: <span class=\"hljs-string\">&quot;http://xxxxxx&quot;</span>, // 目标地址<br>              ws: <span class=\"hljs-literal\">true</span>,  // 是否启用websockets<br>              changeOrigin: <span class=\"hljs-literal\">true</span>, //开启代理：在本地会创建一个虚拟服务端，然后发送请求的数据，并同时接收请求的数据，这样服务端和服务端进行数据的交互就不会有跨域问题<br>              pathRewrite: &#123;<br>                <span class=\"hljs-string\">&#x27;^/bpi&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span>  //这里重写路径<br>            &#125;<br>          &#125;,<br>          <span class=\"hljs-string\">&#x27;/cpi&#x27;</span>: &#123;<br>              target: <span class=\"hljs-string\">&#x27;http://&#x27;</span>,<br>              changeOrigin: <span class=\"hljs-literal\">true</span>,<br>              pathRewrite: &#123;<br>                <span class=\"hljs-string\">&#x27;^/cpi&#x27;</span>: <span class=\"hljs-string\">&#x27;/&#x27;</span><br>            &#125;<br>          &#125;<br>      &#125;,<br>  <br>      before: app =&gt; &#123;<br>      &#125;<br>    &#125;,<br>    // 构建时开启多进程处理 babel 编译<br>    parallel: require(<span class=\"hljs-string\">&#x27;os&#x27;</span>).cpus().length &gt; 1,<br>  <br>    // https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa<br>    pwa: &#123;&#125;,<br>  <br>    // 第三方插件配置<br>    pluginOptions: &#123;&#125;<br>  &#125;;<br></code></pre></td></tr></table></figure>\n\n<p>调用</p>\n<ol>\n<li>在main.js里面，设置baseURL，Vue.prototype.$http=axios; 这里根据实际需要设置请求头之类的</li>\n</ol>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">this.<span class=\"hljs-variable\">$http</span>(&#123;<br>    method: <span class=\"hljs-string\">&#x27;post&#x27;</span>,<br>    url: <span class=\"hljs-string\">&#x27;/api/xxx/xxx&#x27;</span>,<br>    data: params<br>&#125;).<span class=\"hljs-keyword\">then</span>(res =&gt; &#123;<br>    console.log(res.data)<br>&#125;).catch(error =&gt; &#123;<br>    console.log(error)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"五、一句话总结\"><a href=\"#五、一句话总结\" class=\"headerlink\" title=\"五、一句话总结\"></a>五、一句话总结</h3><p>配置多个反向代理需要前端或后端约定,url中判断出区别从而代理到不同的接口</p>\n<h3 id=\"六、其他\"><a href=\"#六、其他\" class=\"headerlink\" title=\"六、其他\"></a>六、其他</h3><h4 id=\"一、产生原因\"><a href=\"#一、产生原因\" class=\"headerlink\" title=\"一、产生原因\"></a>一、产生原因</h4><ul>\n<li>跨域是a页面想要获取b页面资源，如果a,b页面的协议、域名、端口号、子域名不同，所进行的访问都是跨域的，而浏览器一般为了安全都限制了跨域访问，也就是不允许跨域访问资源。</li>\n</ul>\n<h4 id=\"二、解决办法\"><a href=\"#二、解决办法\" class=\"headerlink\" title=\"二、解决办法\"></a>二、解决办法</h4><h5 id=\"1-JSONP\"><a href=\"#1-JSONP\" class=\"headerlink\" title=\"1.JSONP\"></a>1.JSONP</h5><ul>\n<li>JSONP是一个非官方协议，它允许在服务器端集成script tags返回至客户端，通过javascript callback的形式实现跨域访问。</li>\n<li>基本思想：网页通过添加一个<code>&lt;script&gt;</code>元素，向服务器请求JSON数据，这种做法不受同源策略限制；服务器收到请求后，将数据放在一个指定名字的回调函数里传回来。</li>\n</ul>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text/javascript&quot;</span>&gt;</span><span class=\"javascript\"></span><br><span class=\"javascript\">    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">jsonpCallback</span>(<span class=\"hljs-params\">result</span>)</span>&#123;</span><br><span class=\"javascript\">        <span class=\"hljs-comment\">//alert(result);</span></span><br><span class=\"javascript\">        <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> result)&#123;</span><br><span class=\"javascript\">            alert(i + <span class=\"hljs-string\">&quot;:&quot;</span> + result[i]);     <span class=\"hljs-comment\">//循环输出</span></span><br><span class=\"javascript\">        &#125;</span><br><span class=\"javascript\">    &#125;</span><br><span class=\"javascript\">    <span class=\"hljs-keyword\">var</span> JSONP = <span class=\"hljs-built_in\">document</span>.createElement(<span class=\"hljs-string\">&quot;script&quot;</span>);</span><br><span class=\"javascript\">    JSONP.type = <span class=\"hljs-string\">&quot;text/javascript&quot;</span>;</span><br><span class=\"javascript\">    JSONP.src = <span class=\"hljs-string\">&quot;http://crossdomain.com/services.php?callback=jsonpCallback&quot;</span>;</span><br><span class=\"javascript\">    <span class=\"hljs-built_in\">document</span>.getElementsByTagName(<span class=\"hljs-string\">&quot;head&quot;</span>)[<span class=\"hljs-number\">0</span>].appendChild(JSONP);</span><br><span class=\"javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<h5 id=\"2-window-name\"><a href=\"#2-window-name\" class=\"headerlink\" title=\"2.window.name\"></a>2.window.name</h5><ul>\n<li>window.name+iframe需要目标服务器响应window.name，window对象有一个name属性，该属性有个特征：即在一个窗口（window）的生命周期内，窗口载入的所有的页面都是共享一个window.name的，每个页面对window. name都有读写的权利，window.name 是持久存在一个窗口载入过的所有页面中的！</li>\n</ul>\n<h5 id=\"3-window-postMessage\"><a href=\"#3-window-postMessage\" class=\"headerlink\" title=\"3.window.postMessage\"></a>3.window.postMessage</h5><ul>\n<li>HTML5引入了一个全新的API：跨文档消息传输Cross Document Messaging 。它的目标是在一个单独的持久连接上提供全双工、双向通信。（同源策略对web sockets不适用）</li>\n<li>web sockets原理：在JS创建了web sockets之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockets协议。</li>\n<li><code>otherWindow.postMessage(message, targetOrigin)</code><br> otherWindow：指目标窗口，也就是给哪个窗口发消息，是window.frames属性的成员或者由window.open方法创建的窗口。<br> 参数说明：<br> (1)message：是要发送的消息，类型为string，object<br> (2)targetOrigin：是限定消息接收范围，不限制使用“ * ”</li>\n</ul>\n<h5 id=\"4-CORS\"><a href=\"#4-CORS\" class=\"headerlink\" title=\"4.CORS\"></a>4.CORS</h5><ul>\n<li>基本思想：使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功，还是应该失败。</li>\n</ul>\n<h5 id=\"5-web-sockets\"><a href=\"#5-web-sockets\" class=\"headerlink\" title=\"5.web sockets\"></a>5.web sockets</h5><ul>\n<li>web sockets是浏览器的一种API，它的目标是在一个单独的持久连接上提供全双工、双向通信。(同源策略对web sockets不适用)</li>\n<li>web sockets原理：在JS创建了web socket之后，会有一个HTTP请求发送到浏览器以发起连接。取得服务器响应后，建立的连接会使用HTTP升级从HTTP协议交换为web sockt协议。</li>\n</ul>\n"},{"title":"vue2中常用属性","date":"2021-10-18T06:11:52.000Z","_content":"\n## Vue中$set的用法\n\n由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以**属性必须在 data 对象上存在**时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出想数据变化，页面不变的情况。此时需要用到$set。\n\n```bash\n<!--先看一个例子-->\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>vue $set</title>\n<script src=\"https://static.runoob.com/assets/vue/1.0.11/vue.min.js\"></script>\n</head>\n<body>\n<div id=\"app\">\n  姓名：{{ name }}<br>\n    年龄：{{age}}<br>\n    性别：{{sex}}<br>\n    说明：{{info.content}}\n</div>\n<!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） -->\n<script>\nvar data = {\n    name: \"简书\",\n    age: '3',\n    info: {\n        content: 'my name is test'\n    }\n}    \nvar key = 'content';\nvar vm = new Vue({\n    el:'#app',\n    data: data,\n    ready: function(){\n        //Vue.set(data,'sex', '男')\n        //this.$set('info.'+key, 'what is this?');\n    }\n});\n<!--如果直接新增sex属性，就会出现下图情况-->\ndata.sex = '男'；\n</script>\n</body>\n```\n\n在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；\n\n***vue中双向绑定的值，直接赋值的话，无法再次被改变。这时需要使用$set再次激活***\n\n在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；\n\n![](https://z3.ax1x.com/2021/10/18/5Nzzb4.png)\n\n解决办法\n\n数组：\n\n```kotlin\nthis.$set(Array, index, newValue)\n```\n\n```bash\n由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n解决：用$set方法\n当你修改数组的长度时，例如：vm.items.length = newLength\n解决：vm.items.splice(newLength)\n```\n\n对象：\n\n```csharp\nthis.$set(Object, key, value)\n```\n\n```dart\n有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。\n但是，添加到对象上的新属性不会触发更新。\n在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n","source":"_posts/vue2中常用属性.md","raw":"---\ntitle: vue2中常用属性\ndate: 2021-10-18 14:11:52\ntags: vue2\ncategories:\n- 知识复习\n---\n\n## Vue中$set的用法\n\n由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以**属性必须在 data 对象上存在**时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出想数据变化，页面不变的情况。此时需要用到$set。\n\n```bash\n<!--先看一个例子-->\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>vue $set</title>\n<script src=\"https://static.runoob.com/assets/vue/1.0.11/vue.min.js\"></script>\n</head>\n<body>\n<div id=\"app\">\n  姓名：{{ name }}<br>\n    年龄：{{age}}<br>\n    性别：{{sex}}<br>\n    说明：{{info.content}}\n</div>\n<!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） -->\n<script>\nvar data = {\n    name: \"简书\",\n    age: '3',\n    info: {\n        content: 'my name is test'\n    }\n}    \nvar key = 'content';\nvar vm = new Vue({\n    el:'#app',\n    data: data,\n    ready: function(){\n        //Vue.set(data,'sex', '男')\n        //this.$set('info.'+key, 'what is this?');\n    }\n});\n<!--如果直接新增sex属性，就会出现下图情况-->\ndata.sex = '男'；\n</script>\n</body>\n```\n\n在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；\n\n***vue中双向绑定的值，直接赋值的话，无法再次被改变。这时需要使用$set再次激活***\n\n在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；\n\n![](https://z3.ax1x.com/2021/10/18/5Nzzb4.png)\n\n解决办法\n\n数组：\n\n```kotlin\nthis.$set(Array, index, newValue)\n```\n\n```bash\n由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue\n解决：用$set方法\n当你修改数组的长度时，例如：vm.items.length = newLength\n解决：vm.items.splice(newLength)\n```\n\n对象：\n\n```csharp\nthis.$set(Object, key, value)\n```\n\n```dart\n有时你想向已有对象上添加一些属性，例如使用 Object.assign() 或 _.extend() 方法来添加属性。\n但是，添加到对象上的新属性不会触发更新。\n在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：\n\nthis.someObject = Object.assign({}, this.someObject, { a: 1, b: 2 })\n```\n\n","slug":"vue2中常用属性","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvey0006b0gi3h5xa5qw","content":"<h2 id=\"Vue中-set的用法\"><a href=\"#Vue中-set的用法\" class=\"headerlink\" title=\"Vue中$set的用法\"></a>Vue中$set的用法</h2><p>由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以<strong>属性必须在 data 对象上存在</strong>时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出想数据变化，页面不变的情况。此时需要用到$set。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;!--先看一个例子--&gt;<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;vue <span class=\"hljs-variable\">$set</span>&lt;/title&gt;<br>&lt;script src=<span class=\"hljs-string\">&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  姓名：&#123;&#123; name &#125;&#125;&lt;br&gt;<br>    年龄：&#123;&#123;age&#125;&#125;&lt;br&gt;<br>    性别：&#123;&#123;sex&#125;&#125;&lt;br&gt;<br>    说明：&#123;&#123;info.content&#125;&#125;<br>&lt;/div&gt;<br>&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;<br>&lt;script&gt;<br>var data = &#123;<br>    name: <span class=\"hljs-string\">&quot;简书&quot;</span>,<br>    age: <span class=\"hljs-string\">&#x27;3&#x27;</span>,<br>    info: &#123;<br>        content: <span class=\"hljs-string\">&#x27;my name is test&#x27;</span><br>    &#125;<br>&#125;    <br>var key = <span class=\"hljs-string\">&#x27;content&#x27;</span>;<br>var vm = new Vue(&#123;<br>    el:<span class=\"hljs-string\">&#x27;#app&#x27;</span>,<br>    data: data,<br>    ready: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>()&#123;<br>        //Vue.set(data,<span class=\"hljs-string\">&#x27;sex&#x27;</span>, <span class=\"hljs-string\">&#x27;男&#x27;</span>)<br>        //this.<span class=\"hljs-variable\">$set</span>(<span class=\"hljs-string\">&#x27;info.&#x27;</span>+key, <span class=\"hljs-string\">&#x27;what is this?&#x27;</span>);<br>    &#125;<br>&#125;);<br>&lt;!--如果直接新增sex属性，就会出现下图情况--&gt;<br>data.sex = <span class=\"hljs-string\">&#x27;男&#x27;</span>；<br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<p>在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；</p>\n<p><em><strong>vue中双向绑定的值，直接赋值的话，无法再次被改变。这时需要使用$set再次激活</strong></em></p>\n<p>在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/18/5Nzzb4.png\"></p>\n<p>解决办法</p>\n<p>数组：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(Array, index, newValue)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue<br>解决：用<span class=\"hljs-variable\">$set</span>方法<br>当你修改数组的长度时，例如：vm.items.length = newLength<br>解决：vm.items.splice(newLength)<br></code></pre></td></tr></table></figure>\n\n<p>对象：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(Object, key, <span class=\"hljs-keyword\">value</span>)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">有时你想向已有对象上添加一些属性，例如使用 <span class=\"hljs-built_in\">Object</span>.assign() 或 _.extend() 方法来添加属性。<br>但是，添加到对象上的新属性不会触发更新。<br>在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：<br><br><span class=\"hljs-keyword\">this</span>.someObject = <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;, <span class=\"hljs-keyword\">this</span>.someObject, &#123; a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":1761,"excerpt":"","more":"<h2 id=\"Vue中-set的用法\"><a href=\"#Vue中-set的用法\" class=\"headerlink\" title=\"Vue中$set的用法\"></a>Vue中$set的用法</h2><p>由于 Vue 会在初始化实例时进行双向数据绑定，使用Object.defineProperty()对属性遍历添加 getter/setter 方法，所以<strong>属性必须在 data 对象上存在</strong>时才能进行上述过程 ，这样才能让它是响应的。如果要给对象添加新的属性，此时新属性没有进行过上述过程，不是响应式的，所以会出想数据变化，页面不变的情况。此时需要用到$set。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;!--先看一个例子--&gt;<br><br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;meta charset=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;<br>&lt;title&gt;vue <span class=\"hljs-variable\">$set</span>&lt;/title&gt;<br>&lt;script src=<span class=\"hljs-string\">&quot;https://static.runoob.com/assets/vue/1.0.11/vue.min.js&quot;</span>&gt;&lt;/script&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;div id=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;<br>  姓名：&#123;&#123; name &#125;&#125;&lt;br&gt;<br>    年龄：&#123;&#123;age&#125;&#125;&lt;br&gt;<br>    性别：&#123;&#123;sex&#125;&#125;&lt;br&gt;<br>    说明：&#123;&#123;info.content&#125;&#125;<br>&lt;/div&gt;<br>&lt;!-- JavaScript 代码需要放在尾部（指定的HTML元素之后） --&gt;<br>&lt;script&gt;<br>var data = &#123;<br>    name: <span class=\"hljs-string\">&quot;简书&quot;</span>,<br>    age: <span class=\"hljs-string\">&#x27;3&#x27;</span>,<br>    info: &#123;<br>        content: <span class=\"hljs-string\">&#x27;my name is test&#x27;</span><br>    &#125;<br>&#125;    <br>var key = <span class=\"hljs-string\">&#x27;content&#x27;</span>;<br>var vm = new Vue(&#123;<br>    el:<span class=\"hljs-string\">&#x27;#app&#x27;</span>,<br>    data: data,<br>    ready: <span class=\"hljs-function\"><span class=\"hljs-title\">function</span></span>()&#123;<br>        //Vue.set(data,<span class=\"hljs-string\">&#x27;sex&#x27;</span>, <span class=\"hljs-string\">&#x27;男&#x27;</span>)<br>        //this.<span class=\"hljs-variable\">$set</span>(<span class=\"hljs-string\">&#x27;info.&#x27;</span>+key, <span class=\"hljs-string\">&#x27;what is this?&#x27;</span>);<br>    &#125;<br>&#125;);<br>&lt;!--如果直接新增sex属性，就会出现下图情况--&gt;<br>data.sex = <span class=\"hljs-string\">&#x27;男&#x27;</span>；<br>&lt;/script&gt;<br>&lt;/body&gt;<br></code></pre></td></tr></table></figure>\n\n<p>在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；</p>\n<p><em><strong>vue中双向绑定的值，直接赋值的话，无法再次被改变。这时需要使用$set再次激活</strong></em></p>\n<p>在age及name都有get和set方法,但是在sex里面并没有这两个方法，因此，设置了sex值后vue并不会自动更新视图；</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/18/5Nzzb4.png\"></p>\n<p>解决办法</p>\n<p>数组：</p>\n<figure class=\"highlight kotlin\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs kotlin\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(Array, index, newValue)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">由于 JavaScript 的限制，Vue 不能检测以下变动的数组：<br>当你利用索引直接设置一个项时，例如：vm.items[indexOfItem] = newValue<br>解决：用<span class=\"hljs-variable\">$set</span>方法<br>当你修改数组的长度时，例如：vm.items.length = newLength<br>解决：vm.items.splice(newLength)<br></code></pre></td></tr></table></figure>\n\n<p>对象：</p>\n<figure class=\"highlight csharp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs csharp\"><span class=\"hljs-keyword\">this</span>.$<span class=\"hljs-keyword\">set</span>(Object, key, <span class=\"hljs-keyword\">value</span>)<br></code></pre></td></tr></table></figure>\n\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">有时你想向已有对象上添加一些属性，例如使用 <span class=\"hljs-built_in\">Object</span>.assign() 或 _.extend() 方法来添加属性。<br>但是，添加到对象上的新属性不会触发更新。<br>在这种情况下可以创建一个新的对象，让它包含原对象的属性和新的属性：<br><br><span class=\"hljs-keyword\">this</span>.someObject = <span class=\"hljs-built_in\">Object</span>.assign(&#123;&#125;, <span class=\"hljs-keyword\">this</span>.someObject, &#123; a: <span class=\"hljs-number\">1</span>, b: <span class=\"hljs-number\">2</span> &#125;)<br></code></pre></td></tr></table></figure>\n\n"},{"title":"Npm包管理工具私有化","date":"2021-10-10T17:18:58.000Z","_content":"\n[![5VST3D.png](https://z3.ax1x.com/2021/10/11/5VST3D.png)](https://imgtu.com/i/5VST3D)\n\n## 一、前言\n\n在工作中，我们常常会开发很多通用性的代码，比如UI库，工具类，公用业务逻辑代码等。随着前端队伍越来越壮大，为了快速的进行模块化开发提高复用性，项目间共享代码就变得尤为必要。常用的框架/类库没必要在每个项目都放一份，团队内部产出的公共模块也需要有合理的共享机制。现在，用npm管理前端代码已经是业界趋势。通常我们可能会将代码发布到npm，需要的项目npm/yarn安装引入，但是npm无法保证源码的私密性，这时我们就需要使用到私有的npm仓库。 \n\n## 二、私有npm仓库优势\n\n- 只能在公司的局域网(内网)使用，保证了代码的私密性\n- 因为使用局域网，依赖包下载更快\n- 可以将发布和安装npm的包进行权限设置，利于npm仓库的维护\n- 修改了第三方npm包，但是发布包的作者未将PR合并到master，导致该功能无法在安装包后引用，这时我们可以将第三方包源码修改，发布于私有仓库，即可下载安装，而不用在node_modules中更改源码\n- 微前端框架（qiankun，single-spa）可以弥补js沙盒隔离的问题，更便于公司产品化\n- 利于公司前端的技术沉淀\n\n## 三、工具选择\n\nCNPM 私服：需要占用服务器资源，有些公司可能还需要 DevOps 同事的支持\n\nNexus 私服：[Nexus](https://link.jianshu.com/?t=https://www.sonatype.com/nexus-repository-oss) 对 Maven 包管理的私服工具，其实他还支持 npm 、docker 、yum 等等。\n\nSinopia：[sɪ'nəʊpɪə]]：已经停止维护\n\nVerdaccio (威尔达乔): Sinopia停更后社区在维护\n\n## 四、服务端搭建\n\nVerdaccio 是一个 **Node.js**创建的**轻量的私有npm proxy registry** （推荐使用）\n\n基于 windows10 进行搭建\n\n```\n// 安装 verdaccio\nnpm install -g verdaccio\n\n// 加上–unsafe-perm的原因是防止报 grywarn 权限的错\nnpm install -g verdaccio --unsafe-perm\n\n// 启动\nverdaccio\n\n```\n\n##  五、客户端使用\n\n```\n// 更换 npm 库\nnpm set registry http://localhost:4873/\n\n```\n\ntips：\n\n① 推荐使用 npr 对 npm registry 进行统一管理，具体使用如下\n\n```\n// 安装 nrm\nnpm install -g nrm\n\n// 添加地址到 nrm 中\nnrm add [registry name] [registry address] \nnrm add verdaccio http://localhost:4873/\n\n// 查看 nrm 镜像源地址\nnrm ls\n\n* npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n  taobao - https://registry.npm.taobao.org/\n  nj ----- https://registry.nodejitsu.com/\n  rednpm - http://registry.mirror.cqupt.edu.cn/\n  npmMirror  https://skimdb.npmjs.com/registry/\n  edunpm - http://registry.enpmjs.org/ \n  verdaccio --- http://localhost:4873/\n\n// nrm 切换 registry 地址\nnrm use verdaccio\n\n```\n\n② 推荐使用 pm2 对 verdaccio 进行托管\n\n```\n// 安装 pm2\nnpm install -g pm2 --unsafe-perm\n\n// 使用 pm2 启动 verdaccio\npm2 start verdaccio\n\n// 查看 pm2 守护下的进程 verdaccio 的实时日志\npm2 show verdaccio \n\n```\n\n## 六、发布\n\n```\n// 注册\nnpm adduser --registry http://localhost:4873/\n\n// orr\nnpm adduser\n// 输入用户名、密码、账号 \n\n// if you use HTTPS, add an appropriate CA information (\"null\" means get CA list from OS)\nnpm set ca null\n\n```\n\n现有一 npm-test 文件夹需要打包至私有仓库，如何执行？\n\n```\n// 在 npm-test 文件夹根目录下执行 npm init, 初始化包填写信息\nnpm init\n\n// 已经切换到我们私服地址的情况下\nnpm publish         \n\n// 未切换到我们的私服时，直接加后缀可以发布到私服上\nnpm publish --registry http://localhost:4873/ \n\n// 还可以在 package.json 中加入 publishConfig，就可以直接发布，无需设置仓库\n\"publishConfig\": {\n    \"registry\": \"http://localhost:4873/\"\n}\n\n```\n\n## 七、下载\n\n```\nnpm install npm-test\n```\n\n## 八、其他设置\n\n由于官网访问比较慢且表述不容易读懂这里推荐,如权限管理，如何做运维，docker部署等等都有相关说明\n\n[阿西河](https://www.axihe.com/npm/verdaccio/home.html)\n\n[Verdaccio官网](https://verdaccio.org/)\n","source":"_posts/Npm包管理工具私有化.md","raw":"---\ntitle: Npm包管理工具私有化\ndate: 2021-10-11 01:18:58\ntags: 工具\ncategories:\n- 工具的使用\n---\n\n[![5VST3D.png](https://z3.ax1x.com/2021/10/11/5VST3D.png)](https://imgtu.com/i/5VST3D)\n\n## 一、前言\n\n在工作中，我们常常会开发很多通用性的代码，比如UI库，工具类，公用业务逻辑代码等。随着前端队伍越来越壮大，为了快速的进行模块化开发提高复用性，项目间共享代码就变得尤为必要。常用的框架/类库没必要在每个项目都放一份，团队内部产出的公共模块也需要有合理的共享机制。现在，用npm管理前端代码已经是业界趋势。通常我们可能会将代码发布到npm，需要的项目npm/yarn安装引入，但是npm无法保证源码的私密性，这时我们就需要使用到私有的npm仓库。 \n\n## 二、私有npm仓库优势\n\n- 只能在公司的局域网(内网)使用，保证了代码的私密性\n- 因为使用局域网，依赖包下载更快\n- 可以将发布和安装npm的包进行权限设置，利于npm仓库的维护\n- 修改了第三方npm包，但是发布包的作者未将PR合并到master，导致该功能无法在安装包后引用，这时我们可以将第三方包源码修改，发布于私有仓库，即可下载安装，而不用在node_modules中更改源码\n- 微前端框架（qiankun，single-spa）可以弥补js沙盒隔离的问题，更便于公司产品化\n- 利于公司前端的技术沉淀\n\n## 三、工具选择\n\nCNPM 私服：需要占用服务器资源，有些公司可能还需要 DevOps 同事的支持\n\nNexus 私服：[Nexus](https://link.jianshu.com/?t=https://www.sonatype.com/nexus-repository-oss) 对 Maven 包管理的私服工具，其实他还支持 npm 、docker 、yum 等等。\n\nSinopia：[sɪ'nəʊpɪə]]：已经停止维护\n\nVerdaccio (威尔达乔): Sinopia停更后社区在维护\n\n## 四、服务端搭建\n\nVerdaccio 是一个 **Node.js**创建的**轻量的私有npm proxy registry** （推荐使用）\n\n基于 windows10 进行搭建\n\n```\n// 安装 verdaccio\nnpm install -g verdaccio\n\n// 加上–unsafe-perm的原因是防止报 grywarn 权限的错\nnpm install -g verdaccio --unsafe-perm\n\n// 启动\nverdaccio\n\n```\n\n##  五、客户端使用\n\n```\n// 更换 npm 库\nnpm set registry http://localhost:4873/\n\n```\n\ntips：\n\n① 推荐使用 npr 对 npm registry 进行统一管理，具体使用如下\n\n```\n// 安装 nrm\nnpm install -g nrm\n\n// 添加地址到 nrm 中\nnrm add [registry name] [registry address] \nnrm add verdaccio http://localhost:4873/\n\n// 查看 nrm 镜像源地址\nnrm ls\n\n* npm ---- https://registry.npmjs.org/\n  cnpm --- http://r.cnpmjs.org/\n  taobao - https://registry.npm.taobao.org/\n  nj ----- https://registry.nodejitsu.com/\n  rednpm - http://registry.mirror.cqupt.edu.cn/\n  npmMirror  https://skimdb.npmjs.com/registry/\n  edunpm - http://registry.enpmjs.org/ \n  verdaccio --- http://localhost:4873/\n\n// nrm 切换 registry 地址\nnrm use verdaccio\n\n```\n\n② 推荐使用 pm2 对 verdaccio 进行托管\n\n```\n// 安装 pm2\nnpm install -g pm2 --unsafe-perm\n\n// 使用 pm2 启动 verdaccio\npm2 start verdaccio\n\n// 查看 pm2 守护下的进程 verdaccio 的实时日志\npm2 show verdaccio \n\n```\n\n## 六、发布\n\n```\n// 注册\nnpm adduser --registry http://localhost:4873/\n\n// orr\nnpm adduser\n// 输入用户名、密码、账号 \n\n// if you use HTTPS, add an appropriate CA information (\"null\" means get CA list from OS)\nnpm set ca null\n\n```\n\n现有一 npm-test 文件夹需要打包至私有仓库，如何执行？\n\n```\n// 在 npm-test 文件夹根目录下执行 npm init, 初始化包填写信息\nnpm init\n\n// 已经切换到我们私服地址的情况下\nnpm publish         \n\n// 未切换到我们的私服时，直接加后缀可以发布到私服上\nnpm publish --registry http://localhost:4873/ \n\n// 还可以在 package.json 中加入 publishConfig，就可以直接发布，无需设置仓库\n\"publishConfig\": {\n    \"registry\": \"http://localhost:4873/\"\n}\n\n```\n\n## 七、下载\n\n```\nnpm install npm-test\n```\n\n## 八、其他设置\n\n由于官网访问比较慢且表述不容易读懂这里推荐,如权限管理，如何做运维，docker部署等等都有相关说明\n\n[阿西河](https://www.axihe.com/npm/verdaccio/home.html)\n\n[Verdaccio官网](https://verdaccio.org/)\n","slug":"Npm包管理工具私有化","published":1,"updated":"2022-11-20T05:15:37.977Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvez0007b0gi1pn8g9ye","content":"<p><a href=\"https://imgtu.com/i/5VST3D\"><img src=\"https://z3.ax1x.com/2021/10/11/5VST3D.png\" alt=\"5VST3D.png\"></a></p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在工作中，我们常常会开发很多通用性的代码，比如UI库，工具类，公用业务逻辑代码等。随着前端队伍越来越壮大，为了快速的进行模块化开发提高复用性，项目间共享代码就变得尤为必要。常用的框架/类库没必要在每个项目都放一份，团队内部产出的公共模块也需要有合理的共享机制。现在，用npm管理前端代码已经是业界趋势。通常我们可能会将代码发布到npm，需要的项目npm/yarn安装引入，但是npm无法保证源码的私密性，这时我们就需要使用到私有的npm仓库。 </p>\n<h2 id=\"二、私有npm仓库优势\"><a href=\"#二、私有npm仓库优势\" class=\"headerlink\" title=\"二、私有npm仓库优势\"></a>二、私有npm仓库优势</h2><ul>\n<li>只能在公司的局域网(内网)使用，保证了代码的私密性</li>\n<li>因为使用局域网，依赖包下载更快</li>\n<li>可以将发布和安装npm的包进行权限设置，利于npm仓库的维护</li>\n<li>修改了第三方npm包，但是发布包的作者未将PR合并到master，导致该功能无法在安装包后引用，这时我们可以将第三方包源码修改，发布于私有仓库，即可下载安装，而不用在node_modules中更改源码</li>\n<li>微前端框架（qiankun，single-spa）可以弥补js沙盒隔离的问题，更便于公司产品化</li>\n<li>利于公司前端的技术沉淀</li>\n</ul>\n<h2 id=\"三、工具选择\"><a href=\"#三、工具选择\" class=\"headerlink\" title=\"三、工具选择\"></a>三、工具选择</h2><p>CNPM 私服：需要占用服务器资源，有些公司可能还需要 DevOps 同事的支持</p>\n<p>Nexus 私服：<a href=\"https://link.jianshu.com/?t=https://www.sonatype.com/nexus-repository-oss\">Nexus</a> 对 Maven 包管理的私服工具，其实他还支持 npm 、docker 、yum 等等。</p>\n<p>Sinopia：[sɪ’nəʊpɪə]]：已经停止维护</p>\n<p>Verdaccio (威尔达乔): Sinopia停更后社区在维护</p>\n<h2 id=\"四、服务端搭建\"><a href=\"#四、服务端搭建\" class=\"headerlink\" title=\"四、服务端搭建\"></a>四、服务端搭建</h2><p>Verdaccio 是一个 <strong>Node.js</strong>创建的<strong>轻量的私有npm proxy registry</strong> （推荐使用）</p>\n<p>基于 windows10 进行搭建</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 verdaccio<br>npm install -g verdaccio<br><br><span class=\"hljs-regexp\">//</span> 加上–unsafe-perm的原因是防止报 grywarn 权限的错<br>npm install -g verdaccio --unsafe-perm<br><br><span class=\"hljs-regexp\">//</span> 启动<br>verdaccio<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"五、客户端使用\"><a href=\"#五、客户端使用\" class=\"headerlink\" title=\"五、客户端使用\"></a>五、客户端使用</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 更换 npm 库<br>npm set registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br></code></pre></td></tr></table></figure>\n\n<p>tips：</p>\n<p>① 推荐使用 npr 对 npm registry 进行统一管理，具体使用如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 nrm<br>npm install -g nrm<br><br><span class=\"hljs-regexp\">//</span> 添加地址到 nrm 中<br>nrm add [registry name] [registry address] <br>nrm add verdaccio http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> 查看 nrm 镜像源地址<br>nrm ls<br><br>* npm ---- https:<span class=\"hljs-regexp\">//</span>registry.npmjs.org/<br>  cnpm --- http:<span class=\"hljs-regexp\">//</span>r.cnpmjs.org/<br>  taobao - https:<span class=\"hljs-regexp\">//</span>registry.npm.taobao.org/<br>  nj ----- https:<span class=\"hljs-regexp\">//</span>registry.nodejitsu.com/<br>  rednpm - http:<span class=\"hljs-regexp\">//</span>registry.mirror.cqupt.edu.cn/<br>  npmMirror  https:<span class=\"hljs-regexp\">//</span>skimdb.npmjs.com<span class=\"hljs-regexp\">/registry/</span><br>  edunpm - http:<span class=\"hljs-regexp\">//</span>registry.enpmjs.org/ <br>  verdaccio --- http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> nrm 切换 registry 地址<br>nrm use verdaccio<br><br></code></pre></td></tr></table></figure>\n\n<p>② 推荐使用 pm2 对 verdaccio 进行托管</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 pm2<br>npm install -g pm2 --unsafe-perm<br><br><span class=\"hljs-regexp\">//</span> 使用 pm2 启动 verdaccio<br>pm2 start verdaccio<br><br><span class=\"hljs-regexp\">//</span> 查看 pm2 守护下的进程 verdaccio 的实时日志<br>pm2 show verdaccio <br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、发布\"><a href=\"#六、发布\" class=\"headerlink\" title=\"六、发布\"></a>六、发布</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 注册<br>npm adduser --registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> orr<br>npm adduser<br><span class=\"hljs-regexp\">//</span> 输入用户名、密码、账号 <br><br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">if</span> you use HTTPS, add an appropriate CA information (<span class=\"hljs-string\">&quot;null&quot;</span> means get CA list from OS)<br>npm set ca null<br><br></code></pre></td></tr></table></figure>\n\n<p>现有一 npm-test 文件夹需要打包至私有仓库，如何执行？</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 在 npm-test 文件夹根目录下执行 npm init, 初始化包填写信息<br>npm init<br><br><span class=\"hljs-regexp\">//</span> 已经切换到我们私服地址的情况下<br>npm publish         <br><br><span class=\"hljs-regexp\">//</span> 未切换到我们的私服时，直接加后缀可以发布到私服上<br>npm publish --registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/ <br><br><span class=\"hljs-regexp\">//</span> 还可以在 package.json 中加入 publishConfig，就可以直接发布，无需设置仓库<br><span class=\"hljs-string\">&quot;publishConfig&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;registry&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:4873/&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、下载\"><a href=\"#七、下载\" class=\"headerlink\" title=\"七、下载\"></a>七、下载</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">npm <span class=\"hljs-keyword\">install</span> npm-<span class=\"hljs-keyword\">test</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、其他设置\"><a href=\"#八、其他设置\" class=\"headerlink\" title=\"八、其他设置\"></a>八、其他设置</h2><p>由于官网访问比较慢且表述不容易读懂这里推荐,如权限管理，如何做运维，docker部署等等都有相关说明</p>\n<p><a href=\"https://www.axihe.com/npm/verdaccio/home.html\">阿西河</a></p>\n<p><a href=\"https://verdaccio.org/\">Verdaccio官网</a></p>\n","site":{"data":{}},"wordcount":2136,"excerpt":"","more":"<p><a href=\"https://imgtu.com/i/5VST3D\"><img src=\"https://z3.ax1x.com/2021/10/11/5VST3D.png\" alt=\"5VST3D.png\"></a></p>\n<h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>在工作中，我们常常会开发很多通用性的代码，比如UI库，工具类，公用业务逻辑代码等。随着前端队伍越来越壮大，为了快速的进行模块化开发提高复用性，项目间共享代码就变得尤为必要。常用的框架/类库没必要在每个项目都放一份，团队内部产出的公共模块也需要有合理的共享机制。现在，用npm管理前端代码已经是业界趋势。通常我们可能会将代码发布到npm，需要的项目npm/yarn安装引入，但是npm无法保证源码的私密性，这时我们就需要使用到私有的npm仓库。 </p>\n<h2 id=\"二、私有npm仓库优势\"><a href=\"#二、私有npm仓库优势\" class=\"headerlink\" title=\"二、私有npm仓库优势\"></a>二、私有npm仓库优势</h2><ul>\n<li>只能在公司的局域网(内网)使用，保证了代码的私密性</li>\n<li>因为使用局域网，依赖包下载更快</li>\n<li>可以将发布和安装npm的包进行权限设置，利于npm仓库的维护</li>\n<li>修改了第三方npm包，但是发布包的作者未将PR合并到master，导致该功能无法在安装包后引用，这时我们可以将第三方包源码修改，发布于私有仓库，即可下载安装，而不用在node_modules中更改源码</li>\n<li>微前端框架（qiankun，single-spa）可以弥补js沙盒隔离的问题，更便于公司产品化</li>\n<li>利于公司前端的技术沉淀</li>\n</ul>\n<h2 id=\"三、工具选择\"><a href=\"#三、工具选择\" class=\"headerlink\" title=\"三、工具选择\"></a>三、工具选择</h2><p>CNPM 私服：需要占用服务器资源，有些公司可能还需要 DevOps 同事的支持</p>\n<p>Nexus 私服：<a href=\"https://link.jianshu.com/?t=https://www.sonatype.com/nexus-repository-oss\">Nexus</a> 对 Maven 包管理的私服工具，其实他还支持 npm 、docker 、yum 等等。</p>\n<p>Sinopia：[sɪ’nəʊpɪə]]：已经停止维护</p>\n<p>Verdaccio (威尔达乔): Sinopia停更后社区在维护</p>\n<h2 id=\"四、服务端搭建\"><a href=\"#四、服务端搭建\" class=\"headerlink\" title=\"四、服务端搭建\"></a>四、服务端搭建</h2><p>Verdaccio 是一个 <strong>Node.js</strong>创建的<strong>轻量的私有npm proxy registry</strong> （推荐使用）</p>\n<p>基于 windows10 进行搭建</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 verdaccio<br>npm install -g verdaccio<br><br><span class=\"hljs-regexp\">//</span> 加上–unsafe-perm的原因是防止报 grywarn 权限的错<br>npm install -g verdaccio --unsafe-perm<br><br><span class=\"hljs-regexp\">//</span> 启动<br>verdaccio<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"五、客户端使用\"><a href=\"#五、客户端使用\" class=\"headerlink\" title=\"五、客户端使用\"></a>五、客户端使用</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 更换 npm 库<br>npm set registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br></code></pre></td></tr></table></figure>\n\n<p>tips：</p>\n<p>① 推荐使用 npr 对 npm registry 进行统一管理，具体使用如下</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 nrm<br>npm install -g nrm<br><br><span class=\"hljs-regexp\">//</span> 添加地址到 nrm 中<br>nrm add [registry name] [registry address] <br>nrm add verdaccio http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> 查看 nrm 镜像源地址<br>nrm ls<br><br>* npm ---- https:<span class=\"hljs-regexp\">//</span>registry.npmjs.org/<br>  cnpm --- http:<span class=\"hljs-regexp\">//</span>r.cnpmjs.org/<br>  taobao - https:<span class=\"hljs-regexp\">//</span>registry.npm.taobao.org/<br>  nj ----- https:<span class=\"hljs-regexp\">//</span>registry.nodejitsu.com/<br>  rednpm - http:<span class=\"hljs-regexp\">//</span>registry.mirror.cqupt.edu.cn/<br>  npmMirror  https:<span class=\"hljs-regexp\">//</span>skimdb.npmjs.com<span class=\"hljs-regexp\">/registry/</span><br>  edunpm - http:<span class=\"hljs-regexp\">//</span>registry.enpmjs.org/ <br>  verdaccio --- http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> nrm 切换 registry 地址<br>nrm use verdaccio<br><br></code></pre></td></tr></table></figure>\n\n<p>② 推荐使用 pm2 对 verdaccio 进行托管</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 安装 pm2<br>npm install -g pm2 --unsafe-perm<br><br><span class=\"hljs-regexp\">//</span> 使用 pm2 启动 verdaccio<br>pm2 start verdaccio<br><br><span class=\"hljs-regexp\">//</span> 查看 pm2 守护下的进程 verdaccio 的实时日志<br>pm2 show verdaccio <br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、发布\"><a href=\"#六、发布\" class=\"headerlink\" title=\"六、发布\"></a>六、发布</h2><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 注册<br>npm adduser --registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/<br><br><span class=\"hljs-regexp\">//</span> orr<br>npm adduser<br><span class=\"hljs-regexp\">//</span> 输入用户名、密码、账号 <br><br><span class=\"hljs-regexp\">//</span> <span class=\"hljs-keyword\">if</span> you use HTTPS, add an appropriate CA information (<span class=\"hljs-string\">&quot;null&quot;</span> means get CA list from OS)<br>npm set ca null<br><br></code></pre></td></tr></table></figure>\n\n<p>现有一 npm-test 文件夹需要打包至私有仓库，如何执行？</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-regexp\">//</span> 在 npm-test 文件夹根目录下执行 npm init, 初始化包填写信息<br>npm init<br><br><span class=\"hljs-regexp\">//</span> 已经切换到我们私服地址的情况下<br>npm publish         <br><br><span class=\"hljs-regexp\">//</span> 未切换到我们的私服时，直接加后缀可以发布到私服上<br>npm publish --registry http:<span class=\"hljs-regexp\">//</span>localhost:<span class=\"hljs-number\">4873</span>/ <br><br><span class=\"hljs-regexp\">//</span> 还可以在 package.json 中加入 publishConfig，就可以直接发布，无需设置仓库<br><span class=\"hljs-string\">&quot;publishConfig&quot;</span>: &#123;<br>    <span class=\"hljs-string\">&quot;registry&quot;</span>: <span class=\"hljs-string\">&quot;http://localhost:4873/&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、下载\"><a href=\"#七、下载\" class=\"headerlink\" title=\"七、下载\"></a>七、下载</h2><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs cmake\">npm <span class=\"hljs-keyword\">install</span> npm-<span class=\"hljs-keyword\">test</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"八、其他设置\"><a href=\"#八、其他设置\" class=\"headerlink\" title=\"八、其他设置\"></a>八、其他设置</h2><p>由于官网访问比较慢且表述不容易读懂这里推荐,如权限管理，如何做运维，docker部署等等都有相关说明</p>\n<p><a href=\"https://www.axihe.com/npm/verdaccio/home.html\">阿西河</a></p>\n<p><a href=\"https://verdaccio.org/\">Verdaccio官网</a></p>\n"},{"title":"yapi的使用","date":"2021-09-25T18:19:39.000Z","_content":"\n旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API\n\n## 快速上手Yapi\n\n## 首页\n\n登录后进入首页，首页展示了分组与项目。\n\n此时你作为新用户，没有任何分组与项目的权限，因此只能搜索、浏览 “公开项目” 的接口，如果在首页找不到任何项目，请联系管理员将你加入对应项目。\n\n1首页头部展示了当前所在的位置、搜索框、新建项目、查看文档和用户信息。\n\n2首页左侧展示分组信息，“分组”是“项目”的集合，只有超级管理员可以管理分组。\n\n3首页右侧是分组下的项目和成员列表，点击左侧的某个分组，右侧会出现该分组下的项目和成员信息。\n\n4点击项目右上角的星星即可关注项目，关注的项目可以在“我的关注”页面查看。\n\n![](https://hellosean1025.github.io/yapi/documents/images/usage/index.png)\n\n## 项目页\n\n点击一个项目，进入项目页，项目页展示了属于该项目的全部接口，并提供项目、接口的全部操作。\n\n此时你作为新用户，只能浏览接口信息，不可以编辑项目或接口，如果需要编辑，请联系管理员将你加入该项目。\n\n1项目页左侧的 “接口列表” 展示了该项目下的所有接口，右侧默认显示该项目下所有接口的列表。\n\n2点击左侧的某个接口，右侧会出现“预览”、“编辑”和“运行”。\n\n3点击左侧的 “测试集合” 使用[测试集](https://hellosean1025.github.io/yapi/documents/case.html)功能。\n\n4点击二级导航的“设置”，项目组长即可编辑项目信息和管理成员列表。\n\n5点击二级导航的“动态”，即可查看项目的操作日志。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/project.png)\n\n## 个人中心\n\n鼠标移动到右上角的用户头像或用户名上，即可点击“个人中心”查看个人信息。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/hover.png)\n\n在个人信息页面可以查看并修改自己的用户名、密码等信息。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/user.png)\n\n<iframe style=\"width: 100%; height: 500px;\" src=\"//player.bilibili.com/player.html?aid=333709146&bvid=BV1hw411f75H&cid=357038179&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n","source":"_posts/yapi的使用.md","raw":"---\ntitle: yapi的使用\ndate: 2021-09-26 02:19:39\ntags: 工具\ncategories:\n- 工具的使用\n---\n\n旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API\n\n## 快速上手Yapi\n\n## 首页\n\n登录后进入首页，首页展示了分组与项目。\n\n此时你作为新用户，没有任何分组与项目的权限，因此只能搜索、浏览 “公开项目” 的接口，如果在首页找不到任何项目，请联系管理员将你加入对应项目。\n\n1首页头部展示了当前所在的位置、搜索框、新建项目、查看文档和用户信息。\n\n2首页左侧展示分组信息，“分组”是“项目”的集合，只有超级管理员可以管理分组。\n\n3首页右侧是分组下的项目和成员列表，点击左侧的某个分组，右侧会出现该分组下的项目和成员信息。\n\n4点击项目右上角的星星即可关注项目，关注的项目可以在“我的关注”页面查看。\n\n![](https://hellosean1025.github.io/yapi/documents/images/usage/index.png)\n\n## 项目页\n\n点击一个项目，进入项目页，项目页展示了属于该项目的全部接口，并提供项目、接口的全部操作。\n\n此时你作为新用户，只能浏览接口信息，不可以编辑项目或接口，如果需要编辑，请联系管理员将你加入该项目。\n\n1项目页左侧的 “接口列表” 展示了该项目下的所有接口，右侧默认显示该项目下所有接口的列表。\n\n2点击左侧的某个接口，右侧会出现“预览”、“编辑”和“运行”。\n\n3点击左侧的 “测试集合” 使用[测试集](https://hellosean1025.github.io/yapi/documents/case.html)功能。\n\n4点击二级导航的“设置”，项目组长即可编辑项目信息和管理成员列表。\n\n5点击二级导航的“动态”，即可查看项目的操作日志。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/project.png)\n\n## 个人中心\n\n鼠标移动到右上角的用户头像或用户名上，即可点击“个人中心”查看个人信息。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/hover.png)\n\n在个人信息页面可以查看并修改自己的用户名、密码等信息。\n\n![img](https://hellosean1025.github.io/yapi/documents/images/usage/user.png)\n\n<iframe style=\"width: 100%; height: 500px;\" src=\"//player.bilibili.com/player.html?aid=333709146&bvid=BV1hw411f75H&cid=357038179&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n","slug":"yapi的使用","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf0000bb0gi76m79epv","content":"<p>旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API</p>\n<h2 id=\"快速上手Yapi\"><a href=\"#快速上手Yapi\" class=\"headerlink\" title=\"快速上手Yapi\"></a>快速上手Yapi</h2><h2 id=\"首页\"><a href=\"#首页\" class=\"headerlink\" title=\"首页\"></a>首页</h2><p>登录后进入首页，首页展示了分组与项目。</p>\n<p>此时你作为新用户，没有任何分组与项目的权限，因此只能搜索、浏览 “公开项目” 的接口，如果在首页找不到任何项目，请联系管理员将你加入对应项目。</p>\n<p>1首页头部展示了当前所在的位置、搜索框、新建项目、查看文档和用户信息。</p>\n<p>2首页左侧展示分组信息，“分组”是“项目”的集合，只有超级管理员可以管理分组。</p>\n<p>3首页右侧是分组下的项目和成员列表，点击左侧的某个分组，右侧会出现该分组下的项目和成员信息。</p>\n<p>4点击项目右上角的星星即可关注项目，关注的项目可以在“我的关注”页面查看。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/index.png\"></p>\n<h2 id=\"项目页\"><a href=\"#项目页\" class=\"headerlink\" title=\"项目页\"></a>项目页</h2><p>点击一个项目，进入项目页，项目页展示了属于该项目的全部接口，并提供项目、接口的全部操作。</p>\n<p>此时你作为新用户，只能浏览接口信息，不可以编辑项目或接口，如果需要编辑，请联系管理员将你加入该项目。</p>\n<p>1项目页左侧的 “接口列表” 展示了该项目下的所有接口，右侧默认显示该项目下所有接口的列表。</p>\n<p>2点击左侧的某个接口，右侧会出现“预览”、“编辑”和“运行”。</p>\n<p>3点击左侧的 “测试集合” 使用<a href=\"https://hellosean1025.github.io/yapi/documents/case.html\">测试集</a>功能。</p>\n<p>4点击二级导航的“设置”，项目组长即可编辑项目信息和管理成员列表。</p>\n<p>5点击二级导航的“动态”，即可查看项目的操作日志。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/project.png\" alt=\"img\"></p>\n<h2 id=\"个人中心\"><a href=\"#个人中心\" class=\"headerlink\" title=\"个人中心\"></a>个人中心</h2><p>鼠标移动到右上角的用户头像或用户名上，即可点击“个人中心”查看个人信息。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/hover.png\" alt=\"img\"></p>\n<p>在个人信息页面可以查看并修改自己的用户名、密码等信息。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/user.png\" alt=\"img\"></p>\n<iframe style=\"width: 100%; height: 500px;\" src=\"//player.bilibili.com/player.html?aid=333709146&bvid=BV1hw411f75H&cid=357038179&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n","site":{"data":{}},"wordcount":618,"excerpt":"","more":"<p>旨在为开发、产品、测试人员提供更优雅的接口管理服务。可以帮助开发者轻松创建、发布、维护 API</p>\n<h2 id=\"快速上手Yapi\"><a href=\"#快速上手Yapi\" class=\"headerlink\" title=\"快速上手Yapi\"></a>快速上手Yapi</h2><h2 id=\"首页\"><a href=\"#首页\" class=\"headerlink\" title=\"首页\"></a>首页</h2><p>登录后进入首页，首页展示了分组与项目。</p>\n<p>此时你作为新用户，没有任何分组与项目的权限，因此只能搜索、浏览 “公开项目” 的接口，如果在首页找不到任何项目，请联系管理员将你加入对应项目。</p>\n<p>1首页头部展示了当前所在的位置、搜索框、新建项目、查看文档和用户信息。</p>\n<p>2首页左侧展示分组信息，“分组”是“项目”的集合，只有超级管理员可以管理分组。</p>\n<p>3首页右侧是分组下的项目和成员列表，点击左侧的某个分组，右侧会出现该分组下的项目和成员信息。</p>\n<p>4点击项目右上角的星星即可关注项目，关注的项目可以在“我的关注”页面查看。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/index.png\"></p>\n<h2 id=\"项目页\"><a href=\"#项目页\" class=\"headerlink\" title=\"项目页\"></a>项目页</h2><p>点击一个项目，进入项目页，项目页展示了属于该项目的全部接口，并提供项目、接口的全部操作。</p>\n<p>此时你作为新用户，只能浏览接口信息，不可以编辑项目或接口，如果需要编辑，请联系管理员将你加入该项目。</p>\n<p>1项目页左侧的 “接口列表” 展示了该项目下的所有接口，右侧默认显示该项目下所有接口的列表。</p>\n<p>2点击左侧的某个接口，右侧会出现“预览”、“编辑”和“运行”。</p>\n<p>3点击左侧的 “测试集合” 使用<a href=\"https://hellosean1025.github.io/yapi/documents/case.html\">测试集</a>功能。</p>\n<p>4点击二级导航的“设置”，项目组长即可编辑项目信息和管理成员列表。</p>\n<p>5点击二级导航的“动态”，即可查看项目的操作日志。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/project.png\" alt=\"img\"></p>\n<h2 id=\"个人中心\"><a href=\"#个人中心\" class=\"headerlink\" title=\"个人中心\"></a>个人中心</h2><p>鼠标移动到右上角的用户头像或用户名上，即可点击“个人中心”查看个人信息。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/hover.png\" alt=\"img\"></p>\n<p>在个人信息页面可以查看并修改自己的用户名、密码等信息。</p>\n<p><img src=\"https://hellosean1025.github.io/yapi/documents/images/usage/user.png\" alt=\"img\"></p>\n<iframe style=\"width: 100%; height: 500px;\" src=\"//player.bilibili.com/player.html?aid=333709146&bvid=BV1hw411f75H&cid=357038179&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\"> </iframe>\n"},{"title":"vue中引入外部js文件","date":"2021-10-28T08:39:03.000Z","ags":"vue2","_content":"\n今天被前同事问到vue中引入js文件报错的问题\n\n[![5L3qu8.png](https://z3.ax1x.com/2021/10/28/5L3qu8.png)](https://imgtu.com/i/5L3qu8)\n\n大多数情况下习惯了通过/</script/>/标签在public中的index.html引入js文件，但是在vue中通常引入，依然会报错\n\n在es6或者在vue中不会直接支持\n\n一、自己写的代码引入\n\n[![5L822q.png](https://z3.ax1x.com/2021/10/28/5L822q.png)](https://imgtu.com/i/5L822q)\n\n下面举个例子\n\n```dart\nfunction textMessage(){\n\talert(\"This is what I want say\")\n}\n\nexport {\n    textMessage\n}\n```\n\n我们在宿主那里，我们引入改文件\n\n```dart\n<template>  \n    <div class=\"teslist\">  \n        <button @click=\"methods1\">显示console</button>  \n    </div>  \n</template>  \n<script src=\"../../lib/textMessage.js\"></script>  \n<script>  \n    import { textMessage } from '../../lib/textMessage.js'  \n    export default {  \n        methods:{\n　         methods1:function(){  \n              textMessage();  \n           }  \n    }}  \n</script>  \n<style>  \n    .teslist {  \n    }  \n</style> \n```\n\n二、直接引入的 不能用npm下载的\n\n[![5Lt6mV.png](https://z3.ax1x.com/2021/10/28/5Lt6mV.png)](https://imgtu.com/i/5Lt6mV)\n\n在view.vue中的代码这样写：\n\n```dart\n<template>\n...\n</template>\n<script>\nimport swiper from './swiper.js'\nimport common from '../common.vue'\nexport default {\n    data(){\n        return{\n        }\n    },\n    mounted:function(){\n        this.swippertab();\n    },\n    methods:{\n        swippertab(){\n             var swiper = new Swiper('.swiper-container', {\n                pagination: '.swiper-pagination',\n                slidesPerView: 3,\n                paginationClickable: true,\n                spaceBetween: 30\n            });\n        },\n    } \n}\n</script>\n<style scoped>\n@import './swiper.css';\n</style>\n```\n\n**注意一下的就是在swiper.js中需要改一下代码，在最后面改成用export导出Swiper,并且代码原有的amd格式的导出需要注释掉**\n\n未完待续\n","source":"_posts/vue中引入外部js文件.md","raw":"---\ntitle: vue中引入外部js文件\ndate: 2021-10-28 16:39:03\nags: vue2\ncategories:\n- 知识复习\n\n\n---\n\n今天被前同事问到vue中引入js文件报错的问题\n\n[![5L3qu8.png](https://z3.ax1x.com/2021/10/28/5L3qu8.png)](https://imgtu.com/i/5L3qu8)\n\n大多数情况下习惯了通过/</script/>/标签在public中的index.html引入js文件，但是在vue中通常引入，依然会报错\n\n在es6或者在vue中不会直接支持\n\n一、自己写的代码引入\n\n[![5L822q.png](https://z3.ax1x.com/2021/10/28/5L822q.png)](https://imgtu.com/i/5L822q)\n\n下面举个例子\n\n```dart\nfunction textMessage(){\n\talert(\"This is what I want say\")\n}\n\nexport {\n    textMessage\n}\n```\n\n我们在宿主那里，我们引入改文件\n\n```dart\n<template>  \n    <div class=\"teslist\">  \n        <button @click=\"methods1\">显示console</button>  \n    </div>  \n</template>  \n<script src=\"../../lib/textMessage.js\"></script>  \n<script>  \n    import { textMessage } from '../../lib/textMessage.js'  \n    export default {  \n        methods:{\n　         methods1:function(){  \n              textMessage();  \n           }  \n    }}  \n</script>  \n<style>  \n    .teslist {  \n    }  \n</style> \n```\n\n二、直接引入的 不能用npm下载的\n\n[![5Lt6mV.png](https://z3.ax1x.com/2021/10/28/5Lt6mV.png)](https://imgtu.com/i/5Lt6mV)\n\n在view.vue中的代码这样写：\n\n```dart\n<template>\n...\n</template>\n<script>\nimport swiper from './swiper.js'\nimport common from '../common.vue'\nexport default {\n    data(){\n        return{\n        }\n    },\n    mounted:function(){\n        this.swippertab();\n    },\n    methods:{\n        swippertab(){\n             var swiper = new Swiper('.swiper-container', {\n                pagination: '.swiper-pagination',\n                slidesPerView: 3,\n                paginationClickable: true,\n                spaceBetween: 30\n            });\n        },\n    } \n}\n</script>\n<style scoped>\n@import './swiper.css';\n</style>\n```\n\n**注意一下的就是在swiper.js中需要改一下代码，在最后面改成用export导出Swiper,并且代码原有的amd格式的导出需要注释掉**\n\n未完待续\n","slug":"vue中引入外部js文件","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf0000cb0gif5ni7y3k","content":"<p>今天被前同事问到vue中引入js文件报错的问题</p>\n<p><a href=\"https://imgtu.com/i/5L3qu8\"><img src=\"https://z3.ax1x.com/2021/10/28/5L3qu8.png\" alt=\"5L3qu8.png\"></a></p>\n<p>大多数情况下习惯了通过/&lt;/script/&gt;/标签在public中的index.html引入js文件，但是在vue中通常引入，依然会报错</p>\n<p>在es6或者在vue中不会直接支持</p>\n<p>一、自己写的代码引入</p>\n<p><a href=\"https://imgtu.com/i/5L822q\"><img src=\"https://z3.ax1x.com/2021/10/28/5L822q.png\" alt=\"5L822q.png\"></a></p>\n<p>下面举个例子</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">function textMessage()&#123;<br>\talert(<span class=\"hljs-string\">&quot;This is what I want say&quot;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> &#123;<br>    textMessage<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们在宿主那里，我们引入改文件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&lt;template&gt;  <br>    &lt;div <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>=&quot;<span class=\"hljs-title\">teslist</span>&quot;&gt;  </span><br><span class=\"hljs-class\">        &lt;<span class=\"hljs-title\">button</span> @<span class=\"hljs-title\">click</span>=&quot;<span class=\"hljs-title\">methods1</span>&quot;&gt;显示<span class=\"hljs-title\">console</span>&lt;/<span class=\"hljs-title\">button</span>&gt;  </span><br><span class=\"hljs-class\">    &lt;/<span class=\"hljs-title\">div</span>&gt;  </span><br><span class=\"hljs-class\">&lt;/<span class=\"hljs-title\">template</span>&gt;  </span><br><span class=\"hljs-class\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-title\">src</span>=&quot;../../<span class=\"hljs-title\">lib</span>/<span class=\"hljs-title\">textMessage</span>.<span class=\"hljs-title\">js</span>&quot;&gt;&lt;/<span class=\"hljs-title\">script</span>&gt;  </span><br><span class=\"hljs-class\">&lt;<span class=\"hljs-title\">script</span>&gt;  </span><br><span class=\"hljs-class\">    <span class=\"hljs-title\">import</span> </span>&#123; textMessage &#125; from <span class=\"hljs-string\">&#x27;../../lib/textMessage.js&#x27;</span>  <br>    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;  <br>        methods:&#123;<br>　         methods1:function()&#123;  <br>              textMessage();  <br>           &#125;  <br>    &#125;&#125;  <br>&lt;/script&gt;  <br>&lt;style&gt;  <br>    .teslist &#123;  <br>    &#125;  <br>&lt;/style&gt; <br></code></pre></td></tr></table></figure>\n\n<p>二、直接引入的 不能用npm下载的</p>\n<p><a href=\"https://imgtu.com/i/5Lt6mV\"><img src=\"https://z3.ax1x.com/2021/10/28/5Lt6mV.png\" alt=\"5Lt6mV.png\"></a></p>\n<p>在view.vue中的代码这样写：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&lt;template&gt;<br>...<br>&lt;/template&gt;<br>&lt;script&gt;<br><span class=\"hljs-keyword\">import</span> swiper from <span class=\"hljs-string\">&#x27;./swiper.js&#x27;</span><br><span class=\"hljs-keyword\">import</span> common from <span class=\"hljs-string\">&#x27;../common.vue&#x27;</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    data()&#123;<br>        <span class=\"hljs-keyword\">return</span>&#123;<br>        &#125;<br>    &#125;,<br>    mounted:function()&#123;<br>        <span class=\"hljs-keyword\">this</span>.swippertab();<br>    &#125;,<br>    methods:&#123;<br>        swippertab()&#123;<br>             <span class=\"hljs-keyword\">var</span> swiper = <span class=\"hljs-keyword\">new</span> Swiper(<span class=\"hljs-string\">&#x27;.swiper-container&#x27;</span>, &#123;<br>                pagination: <span class=\"hljs-string\">&#x27;.swiper-pagination&#x27;</span>,<br>                slidesPerView: <span class=\"hljs-number\">3</span>,<br>                paginationClickable: <span class=\"hljs-keyword\">true</span>,<br>                spaceBetween: <span class=\"hljs-number\">30</span><br>            &#125;);<br>        &#125;,<br>    &#125; <br>&#125;<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br><span class=\"hljs-meta\">@import</span> <span class=\"hljs-string\">&#x27;./swiper.css&#x27;</span>;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意一下的就是在swiper.js中需要改一下代码，在最后面改成用export导出Swiper,并且代码原有的amd格式的导出需要注释掉</strong></p>\n<p>未完待续</p>\n","site":{"data":{}},"wordcount":1412,"excerpt":"","more":"<p>今天被前同事问到vue中引入js文件报错的问题</p>\n<p><a href=\"https://imgtu.com/i/5L3qu8\"><img src=\"https://z3.ax1x.com/2021/10/28/5L3qu8.png\" alt=\"5L3qu8.png\"></a></p>\n<p>大多数情况下习惯了通过/&lt;/script/&gt;/标签在public中的index.html引入js文件，但是在vue中通常引入，依然会报错</p>\n<p>在es6或者在vue中不会直接支持</p>\n<p>一、自己写的代码引入</p>\n<p><a href=\"https://imgtu.com/i/5L822q\"><img src=\"https://z3.ax1x.com/2021/10/28/5L822q.png\" alt=\"5L822q.png\"></a></p>\n<p>下面举个例子</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">function textMessage()&#123;<br>\talert(<span class=\"hljs-string\">&quot;This is what I want say&quot;</span>)<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> &#123;<br>    textMessage<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>我们在宿主那里，我们引入改文件</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&lt;template&gt;  <br>    &lt;div <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span>=&quot;<span class=\"hljs-title\">teslist</span>&quot;&gt;  </span><br><span class=\"hljs-class\">        &lt;<span class=\"hljs-title\">button</span> @<span class=\"hljs-title\">click</span>=&quot;<span class=\"hljs-title\">methods1</span>&quot;&gt;显示<span class=\"hljs-title\">console</span>&lt;/<span class=\"hljs-title\">button</span>&gt;  </span><br><span class=\"hljs-class\">    &lt;/<span class=\"hljs-title\">div</span>&gt;  </span><br><span class=\"hljs-class\">&lt;/<span class=\"hljs-title\">template</span>&gt;  </span><br><span class=\"hljs-class\">&lt;<span class=\"hljs-title\">script</span> <span class=\"hljs-title\">src</span>=&quot;../../<span class=\"hljs-title\">lib</span>/<span class=\"hljs-title\">textMessage</span>.<span class=\"hljs-title\">js</span>&quot;&gt;&lt;/<span class=\"hljs-title\">script</span>&gt;  </span><br><span class=\"hljs-class\">&lt;<span class=\"hljs-title\">script</span>&gt;  </span><br><span class=\"hljs-class\">    <span class=\"hljs-title\">import</span> </span>&#123; textMessage &#125; from <span class=\"hljs-string\">&#x27;../../lib/textMessage.js&#x27;</span>  <br>    <span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;  <br>        methods:&#123;<br>　         methods1:function()&#123;  <br>              textMessage();  <br>           &#125;  <br>    &#125;&#125;  <br>&lt;/script&gt;  <br>&lt;style&gt;  <br>    .teslist &#123;  <br>    &#125;  <br>&lt;/style&gt; <br></code></pre></td></tr></table></figure>\n\n<p>二、直接引入的 不能用npm下载的</p>\n<p><a href=\"https://imgtu.com/i/5Lt6mV\"><img src=\"https://z3.ax1x.com/2021/10/28/5Lt6mV.png\" alt=\"5Lt6mV.png\"></a></p>\n<p>在view.vue中的代码这样写：</p>\n<figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dart\">&lt;template&gt;<br>...<br>&lt;/template&gt;<br>&lt;script&gt;<br><span class=\"hljs-keyword\">import</span> swiper from <span class=\"hljs-string\">&#x27;./swiper.js&#x27;</span><br><span class=\"hljs-keyword\">import</span> common from <span class=\"hljs-string\">&#x27;../common.vue&#x27;</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> &#123;<br>    data()&#123;<br>        <span class=\"hljs-keyword\">return</span>&#123;<br>        &#125;<br>    &#125;,<br>    mounted:function()&#123;<br>        <span class=\"hljs-keyword\">this</span>.swippertab();<br>    &#125;,<br>    methods:&#123;<br>        swippertab()&#123;<br>             <span class=\"hljs-keyword\">var</span> swiper = <span class=\"hljs-keyword\">new</span> Swiper(<span class=\"hljs-string\">&#x27;.swiper-container&#x27;</span>, &#123;<br>                pagination: <span class=\"hljs-string\">&#x27;.swiper-pagination&#x27;</span>,<br>                slidesPerView: <span class=\"hljs-number\">3</span>,<br>                paginationClickable: <span class=\"hljs-keyword\">true</span>,<br>                spaceBetween: <span class=\"hljs-number\">30</span><br>            &#125;);<br>        &#125;,<br>    &#125; <br>&#125;<br>&lt;/script&gt;<br>&lt;style scoped&gt;<br><span class=\"hljs-meta\">@import</span> <span class=\"hljs-string\">&#x27;./swiper.css&#x27;</span>;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure>\n\n<p><strong>注意一下的就是在swiper.js中需要改一下代码，在最后面改成用export导出Swiper,并且代码原有的amd格式的导出需要注释掉</strong></p>\n<p>未完待续</p>\n"},{"title":"关于Tomcat无法加载jsp标签原因排查及说明","date":"2023-03-05T17:06:22.000Z","_content":"\n1. 问题说明\n\n程序war包发布到服务器之后，用浏览器访问带有\n\n```bash\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n```\n\n标签的jsp页面时，会出现服务响应500的情况\n\n2. 解决流程\n\n   1）Servlet和Tomact的版本确认，然后再根据版本使用对应jsp解析的jar包，也就是jstl.jar；\n\n[![ppmVuHH.png](https://s1.ax1x.com/2023/03/08/ppmVuHH.png)](https://imgse.com/i/ppmVuHH)\n\n​    2）控制变量法将不能访问的jsp页面中的<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>标签删除，随后再次发包，页面能够再次打开并能访问，但是出现了一些接口响应404，也就是服务器没有对应的接口资源；\n\n​    3）在/WebRoot/WEB-INF下新建一个文件夹，用于存放jsp应用的资源，然后将不能访问的jsp页面中，将<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>标签复原，随后再次发包，此时此前不能访问的jsp面能再次访问，并且接口都是正常响应。\n\n[![ppmVl4I.png](https://s1.ax1x.com/2023/03/08/ppmVl4I.png)](https://imgse.com/i/ppmVl4I) \n\n3. 最后说明\n\n导致的原因为，Tomcat跳过了加载jstl.jar包中，相应解析jsp的依赖，后续访问jsp页面时，由于jsp标签没有引用，就会相应500；将对应的依赖放置于新建的文件中，会让Tomcat二次加载。\n","source":"_posts/关于Tomcat无法加载jsp标签原因排查及说明.md","raw":"---\ntitle: 关于Tomcat无法加载jsp标签原因排查及说明\ndate: 2023-03-06 01:06:22\ntags: 工作中问题 \ncategories:\n- 报错解决集合\n---\n\n1. 问题说明\n\n程序war包发布到服务器之后，用浏览器访问带有\n\n```bash\n<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>\n```\n\n标签的jsp页面时，会出现服务响应500的情况\n\n2. 解决流程\n\n   1）Servlet和Tomact的版本确认，然后再根据版本使用对应jsp解析的jar包，也就是jstl.jar；\n\n[![ppmVuHH.png](https://s1.ax1x.com/2023/03/08/ppmVuHH.png)](https://imgse.com/i/ppmVuHH)\n\n​    2）控制变量法将不能访问的jsp页面中的<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>标签删除，随后再次发包，页面能够再次打开并能访问，但是出现了一些接口响应404，也就是服务器没有对应的接口资源；\n\n​    3）在/WebRoot/WEB-INF下新建一个文件夹，用于存放jsp应用的资源，然后将不能访问的jsp页面中，将<%@ taglib uri=\"http://java.sun.com/jsp/jstl/core\" prefix=\"c\"%>标签复原，随后再次发包，此时此前不能访问的jsp面能再次访问，并且接口都是正常响应。\n\n[![ppmVl4I.png](https://s1.ax1x.com/2023/03/08/ppmVl4I.png)](https://imgse.com/i/ppmVl4I) \n\n3. 最后说明\n\n导致的原因为，Tomcat跳过了加载jstl.jar包中，相应解析jsp的依赖，后续访问jsp页面时，由于jsp标签没有引用，就会相应500；将对应的依赖放置于新建的文件中，会让Tomcat二次加载。\n","slug":"关于Tomcat无法加载jsp标签原因排查及说明","published":1,"updated":"2023-05-03T16:45:43.687Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf1000hb0giat2e1wh0","content":"<ol>\n<li>问题说明</li>\n</ol>\n<p>程序war包发布到服务器之后，用浏览器访问带有</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;%@ taglib uri=<span class=\"hljs-string\">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class=\"hljs-string\">&quot;c&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>\n\n<p>标签的jsp页面时，会出现服务响应500的情况</p>\n<ol start=\"2\">\n<li><p>解决流程</p>\n<p>1）Servlet和Tomact的版本确认，然后再根据版本使用对应jsp解析的jar包，也就是jstl.jar；</p>\n</li>\n</ol>\n<p><a href=\"https://imgse.com/i/ppmVuHH\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVuHH.png\" alt=\"ppmVuHH.png\"></a></p>\n<p>​    2）控制变量法将不能访问的jsp页面中的&lt;%@ taglib uri=”<a href=\"http://java.sun.com/jsp/jstl/core&quot;\">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;标签删除，随后再次发包，页面能够再次打开并能访问，但是出现了一些接口响应404，也就是服务器没有对应的接口资源；</p>\n<p>​    3）在/WebRoot/WEB-INF下新建一个文件夹，用于存放jsp应用的资源，然后将不能访问的jsp页面中，将&lt;%@ taglib uri=”<a href=\"http://java.sun.com/jsp/jstl/core&quot;\">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;标签复原，随后再次发包，此时此前不能访问的jsp面能再次访问，并且接口都是正常响应。</p>\n<p><a href=\"https://imgse.com/i/ppmVl4I\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVl4I.png\" alt=\"ppmVl4I.png\"></a> </p>\n<ol start=\"3\">\n<li>最后说明</li>\n</ol>\n<p>导致的原因为，Tomcat跳过了加载jstl.jar包中，相应解析jsp的依赖，后续访问jsp页面时，由于jsp标签没有引用，就会相应500；将对应的依赖放置于新建的文件中，会让Tomcat二次加载。</p>\n","site":{"data":{}},"wordcount":620,"excerpt":"","more":"<ol>\n<li>问题说明</li>\n</ol>\n<p>程序war包发布到服务器之后，用浏览器访问带有</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">&lt;%@ taglib uri=<span class=\"hljs-string\">&quot;http://java.sun.com/jsp/jstl/core&quot;</span> prefix=<span class=\"hljs-string\">&quot;c&quot;</span>%&gt;<br></code></pre></td></tr></table></figure>\n\n<p>标签的jsp页面时，会出现服务响应500的情况</p>\n<ol start=\"2\">\n<li><p>解决流程</p>\n<p>1）Servlet和Tomact的版本确认，然后再根据版本使用对应jsp解析的jar包，也就是jstl.jar；</p>\n</li>\n</ol>\n<p><a href=\"https://imgse.com/i/ppmVuHH\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVuHH.png\" alt=\"ppmVuHH.png\"></a></p>\n<p>​    2）控制变量法将不能访问的jsp页面中的&lt;%@ taglib uri=”<a href=\"http://java.sun.com/jsp/jstl/core&quot;\">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;标签删除，随后再次发包，页面能够再次打开并能访问，但是出现了一些接口响应404，也就是服务器没有对应的接口资源；</p>\n<p>​    3）在/WebRoot/WEB-INF下新建一个文件夹，用于存放jsp应用的资源，然后将不能访问的jsp页面中，将&lt;%@ taglib uri=”<a href=\"http://java.sun.com/jsp/jstl/core&quot;\">http://java.sun.com/jsp/jstl/core&quot;</a> prefix=”c”%&gt;标签复原，随后再次发包，此时此前不能访问的jsp面能再次访问，并且接口都是正常响应。</p>\n<p><a href=\"https://imgse.com/i/ppmVl4I\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVl4I.png\" alt=\"ppmVl4I.png\"></a> </p>\n<ol start=\"3\">\n<li>最后说明</li>\n</ol>\n<p>导致的原因为，Tomcat跳过了加载jstl.jar包中，相应解析jsp的依赖，后续访问jsp页面时，由于jsp标签没有引用，就会相应500；将对应的依赖放置于新建的文件中，会让Tomcat二次加载。</p>\n"},{"title":"前端监控","date":"2022-06-01T07:30:34.000Z","comment":"twikoo","_content":"\n## 什么是前端监控？\n\n它指的是通过一定的手段来获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，为产品优化指明方向，为用户提供更加精确、完善的服务。\n\n## 前端监控\n\n一般来讲一个成熟的产品，运营与产品团队需要关注用户在产品内的行为记录，通过用户的行为记录来优化产品，研发与测试团队则需要关注产品的性能以及异常，确保产品的性能体验以及安全迭代。\n\n**「所以前端监控一般也分为三大类：」**\n\n### 数据监控（监控用户行为）\n\n- PV/UV: PV(page view)：即页面浏览量或点击量；UV（unique visitor）：指访问某个站点或点击某条新闻的不同 IP 地址的人数\n- 用户在每一个页面的停留时间\n- 用户通过什么入口来访问该网页\n- 用户在相应的页面中触发的行为，等...\n\n统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。\n\n### 性能监控（监控页面性能）\n\n- 不同用户，不同机型和不同系统下的首屏加载时间\n- 白屏时间\n- http 等请求的响应时间\n- 静态资源整体下载时间\n- 页面渲染时间\n- 页面交互动画完成时间，等...\n\n这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，尽可能的提高用户体验。\n\n### 异常监控（监控产品、系统异常）\n\n及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 `try catch` 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：\n\n- Javascript 的异常监控\n- 样式丢失的异常监控\n\n## 数据采集\n\n![img](https://s1.ax1x.com/2022/04/24/L40t3R.png)\n\n### Performance --- 前端性能监控\n\n一、什么是performance\nperformance可以获取到当前页面中与性能相关的信息，可以检测到白屏时间、首屏时间、用户可操作的时间节点、页面总下载的时间、DNS查询的时间、TCP链接的时间等。\n\n二、前端性能主要测试点\n白屏时间：从打开网站到有内容渲染出来的时间点\n首屏时间：首屏内容渲染完毕的时间节点\n用户可操作时间节点：domready触发节点\n总下载时间：window.onload的触发节点\n新建个[demo.html](https://doc.roadtel.top/download/attachments/1082328/demo.html?version=1&modificationDate=1650785189325&api=v2)\n\n其中 memory 是和内存相关的，navigation 是指来源相关的，timing是关键点时间。\n\nperformance.memory 含义是显示此刻内存占用的情况\n\njsHeapSizeLimit 表示内存大小的限制\n\ntotalJSHeapSize 表示总内存的大小\n\nusedJSHeapSize 表示可使用的内存大小\n\n如果 usedJSHeadSize 大于 totalJSHeadSize 的话，那么会出现内存泄露的问题，因此不允许出现这种情况\n\nperformance.navigation 含义是页面的来源信息\n\nredirectCount 如果有重定向，页面通过几次重定向跳转而来，默认为0\n\ntype 表示页面打开方式，默认为0，可取值为0、1、2、255\n\n0 (TYPE_NAVIGATE) 表示正常进入该页面（非刷新、非重定向）\n\n1 (TYPE_RELOAD) 表示通过window.location.reload刷新的页面\n\n2 (TYPE_BACK_FORWARD) 表示通过浏览器的前进、后退按钮进入的页面\n\n255 (TYPE_RESERVED) 表示非以上方式进入页面\n\nperformance.onresourcetimingbufferfull 一个回调函数，会在浏览器的资源时间性能缓冲区满了的时候执行\n\nperformance.timeOrigin 是一系列时间点的基准点，精确到万分之一毫秒，动态的，刷新页面会改变\n\nperformance.timing 是一系列关键时间点，包含网络、解析等一系列时间数据\n\nnavigationStart 同一个浏览器上一个页面卸载结束时的时间戳。如果没有上一个页面，那么该值会和fetchStart的值相同\n\nredirectStart 第一个http重定向开始的时间戳，如果没有重定向，或重定向到同一个不同的源，那么返回0\n\nredirectEnd 最后一个http重定向完成时的时间戳。如果没有重定向，或重定向到一个不同的源，那么返回为0\n\nfetchStart 浏览器准备好使用http请求抓取文档的时间（发生在检查本地缓存之前）\n\ndomainLookupStart DNS域名查询开始时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同\n\ndomainLookupEnd DNS域名查询结束时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同\n\nconnectStart http开始建立连接的时间，如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间\n\nsecureConnectionStart https链接开始的时间，如果不是安全链接，则值为0\n\nconnectEnd http完成建立链接的时间（完成握手），如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间\n\nrequestStart http请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时\n\nresponseStart 开始接收到响应的时间（获取到第一个字节的时候），包括从本地读取缓存\n\nresponseEnd http响应全部接收完成时的时间（获取到最后一个字节）包括从本地读取缓存\n\nunloadEventStart 前一个网页（和当前页面同域）unload的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为0\n\nunloadEventEnd 与unloadEventStart对应，返回是前一个网页unload事件绑定的回调函数执行完毕时间戳\n\ndomLoading 开始解析渲染DOM树的时间\n\ndomInteractive 完成解析DOM树的时间（只是DOM树解析完成，但是并没有开始加载网页的资源）\n\ndomContentLoadedEventStart DOM解析完成后，网页内资源加载开始的时间\n\ndomContentLoadedEventEnd DOM解析完成后，网页内资源加载完成的时间\n\ndomComplete DOM树解析完成，且资源也准备就绪的时间。Document.readyState变为complete，并将抛出readystatechange相关事件\n\nloadEventStart load事件发送给文档。也即load回调函数开始执行的时间，如果没有绑定load事件，则该值为0\n\nloadEventEnd load事件的回调函数执行完毕时间，如果没有绑定load事件，该值为0\n\n\n\n测试点代码\n\n重定向耗时 = redirectEnd - redirectStart\nDNS查询耗时 = domainLookupEnd - domainLookupStart\nTCP链接耗时 = connectEnd - connectStart\nHTTP请求耗时 = responseEnd - responseStart\n解析dom树耗时 = domComplete - domInteractive\n白屏时间 = responseStart - navigationStart\nDOMready时间 = domContentLoadedEventEnd - navigationStart\nonload时间 = loadEventEnd - navigationStart\n\n## 埋点上报\n\n![img](https://s1.ax1x.com/2022/04/24/L4dm5j.png)\n\nOK，上面我们说到了前端监控的三个分类，了解了一个产品需要监控哪些内容以及为什么需要监控这些内容，那么我们应该怎么实现前端监控呢？\n\n实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台进行入库，最后再给数据分析组进行数据分析，最后处理好的数据再同步给运营或者是产品。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。\n\n现在常见的埋点上报方法有三种：`手动埋点`、`可视化埋点`、`无埋点`\n\n### 手动埋点\n\n手动埋点，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像**[友盟]**、**[百度统计]**等第三方数据统计服务商大都采用这种方案。手动埋点让使用者可以方便地设置自定义属性、自定义事件；所以当你需要深入下钻，并精细化自定义分析时，比较适合使用手动埋点。\n\n手动埋点的缺陷就是，项目工程量大，需要埋点的位置太多，而且需要产品开发运营之间相互反复沟通，容易出现手动差错，如果错误，重新埋点的成本也很高。\n\n### 可视化埋点\n\n通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。\n\n可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。\n\n### 无埋点\n\n无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，缺点是流量和采集的数据过于庞大，服务器性能压力山大。\n\n\n\n![img](https://s1.ax1x.com/2022/04/24/L4aqv6.png)\n\n\n\n## 标准化埋点数据\n\n![img](https://s1.ax1x.com/2022/04/24/L4weOK.png)\n\n\n\n## 日志存储\n\n1.上传到服务器\n\n- 日志量过大，可能导致传输、存储、查询速度等问题\n- 过于频繁上报、会增加服务器压力\n- 网络传输，容易导致日志丢失等问题\n- 消耗前端资源，影响主业务\n\n2.本地存储\n\n- 需要引导用户手动提交日志\n- 通过后台下发命令拉取日志\n\n\n\n## 为什么都用GIF来做埋点？\n\n### 发现过程\n\n首先说一下我是怎么发现的，前一段时间，产品提了个需求，说我们现在的书籍曝光上报规范并不是他们想要的数据，并且以后所有页面的书籍上报都统一成最新规范。\n\n曝光规范：\n\n- 书籍出现在可视区并停留1秒，算作有效曝光\n- 书籍不能重复曝光，假如它一直在可视区滚动时只能上报一次\n- 当它移出可视区后再回到可视区，再按第一点进行曝光\n\nOK，既然要所有页面统一，那就只能封装成通用库来使用了，这里实现逻辑就不贴了，想看的私聊我发你，主要的难点就是停留时长计算，以及曝光标记。\n\n```\nconst exposeReportClass = new exposeReport({\n      scrollDom: \"\",  // 滚动容器，建议指定一个滚动容器，不传默认为window\n      watchDom: \".bookitem\", // 监听的dom,建议使用class类，标签也支持\n      time: 1000             // 停留有效时长ms\n});\n// 提供两个上报方法\nexposeReportClass.didReport(()=>{\n  // 手动上报\n  //callback\n})\nexposeReportClass.scrollReport(()=>{\n  // 滚动上报\n  //callback\n})\n// \n```\n\n具体业务逻辑之需要放在对应的callback里面，而上报逻辑开发者无需考虑，因为我底层已经统一处理好了。\n\n然后我再测试的时候就发现，上报发的请求居然是通过图片发起的，并不是我们认为的接口上报。\n\n![img](https://s1.ax1x.com/2022/04/24/L4wR7F.png)\n\n然后我去查了下资料，发现很多大厂的上报都是这么干的！\n\n### 使用GIF上报的原因\n\n向服务器端上报数据，可以通过请求接口，请求普通文件，或者请求图片资源的方式进行。**只要能上报数据，无论是请求GIF文件还是请求其他普通文件(JS)或者是请求接口，服务器端其实并不关心具体的上报方式。**那为什么所有系统都统一使用了请求GIF图片的方式上报数据呢？\n\n**「防止跨域」**\n\n一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。但图片的src属性并不会跨域，并且同样可以发起请求。（排除接口上报）\n\n**「防止阻塞页面加载，影响用户体验」**\n\n通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。\n\n但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。（排除文件方式）\n\n**「相比PNG/JPG，GIF的体积最小」**\n\n最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。\n\n同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。\n\n1兆字节(mb)=1048576字节(b)\n\n1048576/43 ≈ 24385\n\n**「并且大多采用的是1\\*1像素的透明GIF来上报」**\n\n1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。\n","source":"_posts/前端监控.md","raw":"---\ntitle: 前端监控\ndate: 2022-06-01 15:30:34\ntags: js\ncomment: 'twikoo'\ncategories:\n- 前端监控\n---\n\n## 什么是前端监控？\n\n它指的是通过一定的手段来获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，为产品优化指明方向，为用户提供更加精确、完善的服务。\n\n## 前端监控\n\n一般来讲一个成熟的产品，运营与产品团队需要关注用户在产品内的行为记录，通过用户的行为记录来优化产品，研发与测试团队则需要关注产品的性能以及异常，确保产品的性能体验以及安全迭代。\n\n**「所以前端监控一般也分为三大类：」**\n\n### 数据监控（监控用户行为）\n\n- PV/UV: PV(page view)：即页面浏览量或点击量；UV（unique visitor）：指访问某个站点或点击某条新闻的不同 IP 地址的人数\n- 用户在每一个页面的停留时间\n- 用户通过什么入口来访问该网页\n- 用户在相应的页面中触发的行为，等...\n\n统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。\n\n### 性能监控（监控页面性能）\n\n- 不同用户，不同机型和不同系统下的首屏加载时间\n- 白屏时间\n- http 等请求的响应时间\n- 静态资源整体下载时间\n- 页面渲染时间\n- 页面交互动画完成时间，等...\n\n这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，尽可能的提高用户体验。\n\n### 异常监控（监控产品、系统异常）\n\n及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 `try catch` 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：\n\n- Javascript 的异常监控\n- 样式丢失的异常监控\n\n## 数据采集\n\n![img](https://s1.ax1x.com/2022/04/24/L40t3R.png)\n\n### Performance --- 前端性能监控\n\n一、什么是performance\nperformance可以获取到当前页面中与性能相关的信息，可以检测到白屏时间、首屏时间、用户可操作的时间节点、页面总下载的时间、DNS查询的时间、TCP链接的时间等。\n\n二、前端性能主要测试点\n白屏时间：从打开网站到有内容渲染出来的时间点\n首屏时间：首屏内容渲染完毕的时间节点\n用户可操作时间节点：domready触发节点\n总下载时间：window.onload的触发节点\n新建个[demo.html](https://doc.roadtel.top/download/attachments/1082328/demo.html?version=1&modificationDate=1650785189325&api=v2)\n\n其中 memory 是和内存相关的，navigation 是指来源相关的，timing是关键点时间。\n\nperformance.memory 含义是显示此刻内存占用的情况\n\njsHeapSizeLimit 表示内存大小的限制\n\ntotalJSHeapSize 表示总内存的大小\n\nusedJSHeapSize 表示可使用的内存大小\n\n如果 usedJSHeadSize 大于 totalJSHeadSize 的话，那么会出现内存泄露的问题，因此不允许出现这种情况\n\nperformance.navigation 含义是页面的来源信息\n\nredirectCount 如果有重定向，页面通过几次重定向跳转而来，默认为0\n\ntype 表示页面打开方式，默认为0，可取值为0、1、2、255\n\n0 (TYPE_NAVIGATE) 表示正常进入该页面（非刷新、非重定向）\n\n1 (TYPE_RELOAD) 表示通过window.location.reload刷新的页面\n\n2 (TYPE_BACK_FORWARD) 表示通过浏览器的前进、后退按钮进入的页面\n\n255 (TYPE_RESERVED) 表示非以上方式进入页面\n\nperformance.onresourcetimingbufferfull 一个回调函数，会在浏览器的资源时间性能缓冲区满了的时候执行\n\nperformance.timeOrigin 是一系列时间点的基准点，精确到万分之一毫秒，动态的，刷新页面会改变\n\nperformance.timing 是一系列关键时间点，包含网络、解析等一系列时间数据\n\nnavigationStart 同一个浏览器上一个页面卸载结束时的时间戳。如果没有上一个页面，那么该值会和fetchStart的值相同\n\nredirectStart 第一个http重定向开始的时间戳，如果没有重定向，或重定向到同一个不同的源，那么返回0\n\nredirectEnd 最后一个http重定向完成时的时间戳。如果没有重定向，或重定向到一个不同的源，那么返回为0\n\nfetchStart 浏览器准备好使用http请求抓取文档的时间（发生在检查本地缓存之前）\n\ndomainLookupStart DNS域名查询开始时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同\n\ndomainLookupEnd DNS域名查询结束时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同\n\nconnectStart http开始建立连接的时间，如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间\n\nsecureConnectionStart https链接开始的时间，如果不是安全链接，则值为0\n\nconnectEnd http完成建立链接的时间（完成握手），如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间\n\nrequestStart http请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时\n\nresponseStart 开始接收到响应的时间（获取到第一个字节的时候），包括从本地读取缓存\n\nresponseEnd http响应全部接收完成时的时间（获取到最后一个字节）包括从本地读取缓存\n\nunloadEventStart 前一个网页（和当前页面同域）unload的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为0\n\nunloadEventEnd 与unloadEventStart对应，返回是前一个网页unload事件绑定的回调函数执行完毕时间戳\n\ndomLoading 开始解析渲染DOM树的时间\n\ndomInteractive 完成解析DOM树的时间（只是DOM树解析完成，但是并没有开始加载网页的资源）\n\ndomContentLoadedEventStart DOM解析完成后，网页内资源加载开始的时间\n\ndomContentLoadedEventEnd DOM解析完成后，网页内资源加载完成的时间\n\ndomComplete DOM树解析完成，且资源也准备就绪的时间。Document.readyState变为complete，并将抛出readystatechange相关事件\n\nloadEventStart load事件发送给文档。也即load回调函数开始执行的时间，如果没有绑定load事件，则该值为0\n\nloadEventEnd load事件的回调函数执行完毕时间，如果没有绑定load事件，该值为0\n\n\n\n测试点代码\n\n重定向耗时 = redirectEnd - redirectStart\nDNS查询耗时 = domainLookupEnd - domainLookupStart\nTCP链接耗时 = connectEnd - connectStart\nHTTP请求耗时 = responseEnd - responseStart\n解析dom树耗时 = domComplete - domInteractive\n白屏时间 = responseStart - navigationStart\nDOMready时间 = domContentLoadedEventEnd - navigationStart\nonload时间 = loadEventEnd - navigationStart\n\n## 埋点上报\n\n![img](https://s1.ax1x.com/2022/04/24/L4dm5j.png)\n\nOK，上面我们说到了前端监控的三个分类，了解了一个产品需要监控哪些内容以及为什么需要监控这些内容，那么我们应该怎么实现前端监控呢？\n\n实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台进行入库，最后再给数据分析组进行数据分析，最后处理好的数据再同步给运营或者是产品。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。\n\n现在常见的埋点上报方法有三种：`手动埋点`、`可视化埋点`、`无埋点`\n\n### 手动埋点\n\n手动埋点，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像**[友盟]**、**[百度统计]**等第三方数据统计服务商大都采用这种方案。手动埋点让使用者可以方便地设置自定义属性、自定义事件；所以当你需要深入下钻，并精细化自定义分析时，比较适合使用手动埋点。\n\n手动埋点的缺陷就是，项目工程量大，需要埋点的位置太多，而且需要产品开发运营之间相互反复沟通，容易出现手动差错，如果错误，重新埋点的成本也很高。\n\n### 可视化埋点\n\n通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。\n\n可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。\n\n### 无埋点\n\n无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，缺点是流量和采集的数据过于庞大，服务器性能压力山大。\n\n\n\n![img](https://s1.ax1x.com/2022/04/24/L4aqv6.png)\n\n\n\n## 标准化埋点数据\n\n![img](https://s1.ax1x.com/2022/04/24/L4weOK.png)\n\n\n\n## 日志存储\n\n1.上传到服务器\n\n- 日志量过大，可能导致传输、存储、查询速度等问题\n- 过于频繁上报、会增加服务器压力\n- 网络传输，容易导致日志丢失等问题\n- 消耗前端资源，影响主业务\n\n2.本地存储\n\n- 需要引导用户手动提交日志\n- 通过后台下发命令拉取日志\n\n\n\n## 为什么都用GIF来做埋点？\n\n### 发现过程\n\n首先说一下我是怎么发现的，前一段时间，产品提了个需求，说我们现在的书籍曝光上报规范并不是他们想要的数据，并且以后所有页面的书籍上报都统一成最新规范。\n\n曝光规范：\n\n- 书籍出现在可视区并停留1秒，算作有效曝光\n- 书籍不能重复曝光，假如它一直在可视区滚动时只能上报一次\n- 当它移出可视区后再回到可视区，再按第一点进行曝光\n\nOK，既然要所有页面统一，那就只能封装成通用库来使用了，这里实现逻辑就不贴了，想看的私聊我发你，主要的难点就是停留时长计算，以及曝光标记。\n\n```\nconst exposeReportClass = new exposeReport({\n      scrollDom: \"\",  // 滚动容器，建议指定一个滚动容器，不传默认为window\n      watchDom: \".bookitem\", // 监听的dom,建议使用class类，标签也支持\n      time: 1000             // 停留有效时长ms\n});\n// 提供两个上报方法\nexposeReportClass.didReport(()=>{\n  // 手动上报\n  //callback\n})\nexposeReportClass.scrollReport(()=>{\n  // 滚动上报\n  //callback\n})\n// \n```\n\n具体业务逻辑之需要放在对应的callback里面，而上报逻辑开发者无需考虑，因为我底层已经统一处理好了。\n\n然后我再测试的时候就发现，上报发的请求居然是通过图片发起的，并不是我们认为的接口上报。\n\n![img](https://s1.ax1x.com/2022/04/24/L4wR7F.png)\n\n然后我去查了下资料，发现很多大厂的上报都是这么干的！\n\n### 使用GIF上报的原因\n\n向服务器端上报数据，可以通过请求接口，请求普通文件，或者请求图片资源的方式进行。**只要能上报数据，无论是请求GIF文件还是请求其他普通文件(JS)或者是请求接口，服务器端其实并不关心具体的上报方式。**那为什么所有系统都统一使用了请求GIF图片的方式上报数据呢？\n\n**「防止跨域」**\n\n一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。但图片的src属性并不会跨域，并且同样可以发起请求。（排除接口上报）\n\n**「防止阻塞页面加载，影响用户体验」**\n\n通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。\n\n但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。（排除文件方式）\n\n**「相比PNG/JPG，GIF的体积最小」**\n\n最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。\n\n同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。\n\n1兆字节(mb)=1048576字节(b)\n\n1048576/43 ≈ 24385\n\n**「并且大多采用的是1\\*1像素的透明GIF来上报」**\n\n1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。\n","slug":"前端监控","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf2000jb0gicg6m3qtv","content":"<h2 id=\"什么是前端监控？\"><a href=\"#什么是前端监控？\" class=\"headerlink\" title=\"什么是前端监控？\"></a>什么是前端监控？</h2><p>它指的是通过一定的手段来获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，为产品优化指明方向，为用户提供更加精确、完善的服务。</p>\n<h2 id=\"前端监控\"><a href=\"#前端监控\" class=\"headerlink\" title=\"前端监控\"></a>前端监控</h2><p>一般来讲一个成熟的产品，运营与产品团队需要关注用户在产品内的行为记录，通过用户的行为记录来优化产品，研发与测试团队则需要关注产品的性能以及异常，确保产品的性能体验以及安全迭代。</p>\n<p><strong>「所以前端监控一般也分为三大类：」</strong></p>\n<h3 id=\"数据监控（监控用户行为）\"><a href=\"#数据监控（监控用户行为）\" class=\"headerlink\" title=\"数据监控（监控用户行为）\"></a>数据监控（监控用户行为）</h3><ul>\n<li>PV/UV: PV(page view)：即页面浏览量或点击量；UV（unique visitor）：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>\n<li>用户在每一个页面的停留时间</li>\n<li>用户通过什么入口来访问该网页</li>\n<li>用户在相应的页面中触发的行为，等…</li>\n</ul>\n<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>\n<h3 id=\"性能监控（监控页面性能）\"><a href=\"#性能监控（监控页面性能）\" class=\"headerlink\" title=\"性能监控（监控页面性能）\"></a>性能监控（监控页面性能）</h3><ul>\n<li>不同用户，不同机型和不同系统下的首屏加载时间</li>\n<li>白屏时间</li>\n<li>http 等请求的响应时间</li>\n<li>静态资源整体下载时间</li>\n<li>页面渲染时间</li>\n<li>页面交互动画完成时间，等…</li>\n</ul>\n<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，尽可能的提高用户体验。</p>\n<h3 id=\"异常监控（监控产品、系统异常）\"><a href=\"#异常监控（监控产品、系统异常）\" class=\"headerlink\" title=\"异常监控（监控产品、系统异常）\"></a>异常监控（监控产品、系统异常）</h3><p>及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 <code>try catch</code> 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>\n<ul>\n<li>Javascript 的异常监控</li>\n<li>样式丢失的异常监控</li>\n</ul>\n<h2 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L40t3R.png\" alt=\"img\"></p>\n<h3 id=\"Performance-—-前端性能监控\"><a href=\"#Performance-—-前端性能监控\" class=\"headerlink\" title=\"Performance — 前端性能监控\"></a>Performance — 前端性能监控</h3><p>一、什么是performance<br>performance可以获取到当前页面中与性能相关的信息，可以检测到白屏时间、首屏时间、用户可操作的时间节点、页面总下载的时间、DNS查询的时间、TCP链接的时间等。</p>\n<p>二、前端性能主要测试点<br>白屏时间：从打开网站到有内容渲染出来的时间点<br>首屏时间：首屏内容渲染完毕的时间节点<br>用户可操作时间节点：domready触发节点<br>总下载时间：window.onload的触发节点<br>新建个<a href=\"https://doc.roadtel.top/download/attachments/1082328/demo.html?version=1&modificationDate=1650785189325&api=v2\">demo.html</a></p>\n<p>其中 memory 是和内存相关的，navigation 是指来源相关的，timing是关键点时间。</p>\n<p>performance.memory 含义是显示此刻内存占用的情况</p>\n<p>jsHeapSizeLimit 表示内存大小的限制</p>\n<p>totalJSHeapSize 表示总内存的大小</p>\n<p>usedJSHeapSize 表示可使用的内存大小</p>\n<p>如果 usedJSHeadSize 大于 totalJSHeadSize 的话，那么会出现内存泄露的问题，因此不允许出现这种情况</p>\n<p>performance.navigation 含义是页面的来源信息</p>\n<p>redirectCount 如果有重定向，页面通过几次重定向跳转而来，默认为0</p>\n<p>type 表示页面打开方式，默认为0，可取值为0、1、2、255</p>\n<p>0 (TYPE_NAVIGATE) 表示正常进入该页面（非刷新、非重定向）</p>\n<p>1 (TYPE_RELOAD) 表示通过window.location.reload刷新的页面</p>\n<p>2 (TYPE_BACK_FORWARD) 表示通过浏览器的前进、后退按钮进入的页面</p>\n<p>255 (TYPE_RESERVED) 表示非以上方式进入页面</p>\n<p>performance.onresourcetimingbufferfull 一个回调函数，会在浏览器的资源时间性能缓冲区满了的时候执行</p>\n<p>performance.timeOrigin 是一系列时间点的基准点，精确到万分之一毫秒，动态的，刷新页面会改变</p>\n<p>performance.timing 是一系列关键时间点，包含网络、解析等一系列时间数据</p>\n<p>navigationStart 同一个浏览器上一个页面卸载结束时的时间戳。如果没有上一个页面，那么该值会和fetchStart的值相同</p>\n<p>redirectStart 第一个http重定向开始的时间戳，如果没有重定向，或重定向到同一个不同的源，那么返回0</p>\n<p>redirectEnd 最后一个http重定向完成时的时间戳。如果没有重定向，或重定向到一个不同的源，那么返回为0</p>\n<p>fetchStart 浏览器准备好使用http请求抓取文档的时间（发生在检查本地缓存之前）</p>\n<p>domainLookupStart DNS域名查询开始时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同</p>\n<p>domainLookupEnd DNS域名查询结束时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同</p>\n<p>connectStart http开始建立连接的时间，如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间</p>\n<p>secureConnectionStart https链接开始的时间，如果不是安全链接，则值为0</p>\n<p>connectEnd http完成建立链接的时间（完成握手），如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间</p>\n<p>requestStart http请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时</p>\n<p>responseStart 开始接收到响应的时间（获取到第一个字节的时候），包括从本地读取缓存</p>\n<p>responseEnd http响应全部接收完成时的时间（获取到最后一个字节）包括从本地读取缓存</p>\n<p>unloadEventStart 前一个网页（和当前页面同域）unload的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为0</p>\n<p>unloadEventEnd 与unloadEventStart对应，返回是前一个网页unload事件绑定的回调函数执行完毕时间戳</p>\n<p>domLoading 开始解析渲染DOM树的时间</p>\n<p>domInteractive 完成解析DOM树的时间（只是DOM树解析完成，但是并没有开始加载网页的资源）</p>\n<p>domContentLoadedEventStart DOM解析完成后，网页内资源加载开始的时间</p>\n<p>domContentLoadedEventEnd DOM解析完成后，网页内资源加载完成的时间</p>\n<p>domComplete DOM树解析完成，且资源也准备就绪的时间。Document.readyState变为complete，并将抛出readystatechange相关事件</p>\n<p>loadEventStart load事件发送给文档。也即load回调函数开始执行的时间，如果没有绑定load事件，则该值为0</p>\n<p>loadEventEnd load事件的回调函数执行完毕时间，如果没有绑定load事件，该值为0</p>\n<p>测试点代码</p>\n<p>重定向耗时 = redirectEnd - redirectStart<br>DNS查询耗时 = domainLookupEnd - domainLookupStart<br>TCP链接耗时 = connectEnd - connectStart<br>HTTP请求耗时 = responseEnd - responseStart<br>解析dom树耗时 = domComplete - domInteractive<br>白屏时间 = responseStart - navigationStart<br>DOMready时间 = domContentLoadedEventEnd - navigationStart<br>onload时间 = loadEventEnd - navigationStart</p>\n<h2 id=\"埋点上报\"><a href=\"#埋点上报\" class=\"headerlink\" title=\"埋点上报\"></a>埋点上报</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L4dm5j.png\" alt=\"img\"></p>\n<p>OK，上面我们说到了前端监控的三个分类，了解了一个产品需要监控哪些内容以及为什么需要监控这些内容，那么我们应该怎么实现前端监控呢？</p>\n<p>实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台进行入库，最后再给数据分析组进行数据分析，最后处理好的数据再同步给运营或者是产品。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</p>\n<p>现在常见的埋点上报方法有三种：<code>手动埋点</code>、<code>可视化埋点</code>、<code>无埋点</code></p>\n<h3 id=\"手动埋点\"><a href=\"#手动埋点\" class=\"headerlink\" title=\"手动埋点\"></a>手动埋点</h3><p>手动埋点，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像**[友盟]<strong>、</strong>[百度统计]**等第三方数据统计服务商大都采用这种方案。手动埋点让使用者可以方便地设置自定义属性、自定义事件；所以当你需要深入下钻，并精细化自定义分析时，比较适合使用手动埋点。</p>\n<p>手动埋点的缺陷就是，项目工程量大，需要埋点的位置太多，而且需要产品开发运营之间相互反复沟通，容易出现手动差错，如果错误，重新埋点的成本也很高。</p>\n<h3 id=\"可视化埋点\"><a href=\"#可视化埋点\" class=\"headerlink\" title=\"可视化埋点\"></a>可视化埋点</h3><p>通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。</p>\n<p>可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。</p>\n<h3 id=\"无埋点\"><a href=\"#无埋点\" class=\"headerlink\" title=\"无埋点\"></a>无埋点</h3><p>无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，缺点是流量和采集的数据过于庞大，服务器性能压力山大。</p>\n<p><img src=\"https://s1.ax1x.com/2022/04/24/L4aqv6.png\" alt=\"img\"></p>\n<h2 id=\"标准化埋点数据\"><a href=\"#标准化埋点数据\" class=\"headerlink\" title=\"标准化埋点数据\"></a>标准化埋点数据</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L4weOK.png\" alt=\"img\"></p>\n<h2 id=\"日志存储\"><a href=\"#日志存储\" class=\"headerlink\" title=\"日志存储\"></a>日志存储</h2><p>1.上传到服务器</p>\n<ul>\n<li>日志量过大，可能导致传输、存储、查询速度等问题</li>\n<li>过于频繁上报、会增加服务器压力</li>\n<li>网络传输，容易导致日志丢失等问题</li>\n<li>消耗前端资源，影响主业务</li>\n</ul>\n<p>2.本地存储</p>\n<ul>\n<li>需要引导用户手动提交日志</li>\n<li>通过后台下发命令拉取日志</li>\n</ul>\n<h2 id=\"为什么都用GIF来做埋点？\"><a href=\"#为什么都用GIF来做埋点？\" class=\"headerlink\" title=\"为什么都用GIF来做埋点？\"></a>为什么都用GIF来做埋点？</h2><h3 id=\"发现过程\"><a href=\"#发现过程\" class=\"headerlink\" title=\"发现过程\"></a>发现过程</h3><p>首先说一下我是怎么发现的，前一段时间，产品提了个需求，说我们现在的书籍曝光上报规范并不是他们想要的数据，并且以后所有页面的书籍上报都统一成最新规范。</p>\n<p>曝光规范：</p>\n<ul>\n<li>书籍出现在可视区并停留1秒，算作有效曝光</li>\n<li>书籍不能重复曝光，假如它一直在可视区滚动时只能上报一次</li>\n<li>当它移出可视区后再回到可视区，再按第一点进行曝光</li>\n</ul>\n<p>OK，既然要所有页面统一，那就只能封装成通用库来使用了，这里实现逻辑就不贴了，想看的私聊我发你，主要的难点就是停留时长计算，以及曝光标记。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const exposeReportClass = new exposeReport(&#123;<br>      scrollDom: <span class=\"hljs-string\">&quot;&quot;</span>,  <span class=\"hljs-regexp\">//</span> 滚动容器，建议指定一个滚动容器，不传默认为window<br>      watchDom: <span class=\"hljs-string\">&quot;.bookitem&quot;</span>, <span class=\"hljs-regexp\">//</span> 监听的dom,建议使用class类，标签也支持<br>      time: <span class=\"hljs-number\">1000</span>             <span class=\"hljs-regexp\">//</span> 停留有效时长ms<br>&#125;);<br><span class=\"hljs-regexp\">//</span> 提供两个上报方法<br>exposeReportClass.didReport(()=&gt;&#123;<br>  <span class=\"hljs-regexp\">//</span> 手动上报<br>  <span class=\"hljs-regexp\">//</span>callback<br>&#125;)<br>exposeReportClass.scrollReport(()=&gt;&#123;<br>  <span class=\"hljs-regexp\">//</span> 滚动上报<br>  <span class=\"hljs-regexp\">//</span>callback<br>&#125;)<br><span class=\"hljs-regexp\">//</span> <br></code></pre></td></tr></table></figure>\n\n<p>具体业务逻辑之需要放在对应的callback里面，而上报逻辑开发者无需考虑，因为我底层已经统一处理好了。</p>\n<p>然后我再测试的时候就发现，上报发的请求居然是通过图片发起的，并不是我们认为的接口上报。</p>\n<p><img src=\"https://s1.ax1x.com/2022/04/24/L4wR7F.png\" alt=\"img\"></p>\n<p>然后我去查了下资料，发现很多大厂的上报都是这么干的！</p>\n<h3 id=\"使用GIF上报的原因\"><a href=\"#使用GIF上报的原因\" class=\"headerlink\" title=\"使用GIF上报的原因\"></a>使用GIF上报的原因</h3><p>向服务器端上报数据，可以通过请求接口，请求普通文件，或者请求图片资源的方式进行。<strong>只要能上报数据，无论是请求GIF文件还是请求其他普通文件(JS)或者是请求接口，服务器端其实并不关心具体的上报方式。</strong>那为什么所有系统都统一使用了请求GIF图片的方式上报数据呢？</p>\n<p><strong>「防止跨域」</strong></p>\n<p>一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。但图片的src属性并不会跨域，并且同样可以发起请求。（排除接口上报）</p>\n<p><strong>「防止阻塞页面加载，影响用户体验」</strong></p>\n<p>通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。</p>\n<p>但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。（排除文件方式）</p>\n<p><strong>「相比PNG/JPG，GIF的体积最小」</strong></p>\n<p>最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。</p>\n<p>同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。</p>\n<p>1兆字节(mb)=1048576字节(b)</p>\n<p>1048576/43 ≈ 24385</p>\n<p><strong>「并且大多采用的是1*1像素的透明GIF来上报」</strong></p>\n<p>1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。</p>\n","site":{"data":{}},"wordcount":5237,"excerpt":"","more":"<h2 id=\"什么是前端监控？\"><a href=\"#什么是前端监控？\" class=\"headerlink\" title=\"什么是前端监控？\"></a>什么是前端监控？</h2><p>它指的是通过一定的手段来获取用户行为以及跟踪产品在用户端的使用情况，并以监控数据为基础，为产品优化指明方向，为用户提供更加精确、完善的服务。</p>\n<h2 id=\"前端监控\"><a href=\"#前端监控\" class=\"headerlink\" title=\"前端监控\"></a>前端监控</h2><p>一般来讲一个成熟的产品，运营与产品团队需要关注用户在产品内的行为记录，通过用户的行为记录来优化产品，研发与测试团队则需要关注产品的性能以及异常，确保产品的性能体验以及安全迭代。</p>\n<p><strong>「所以前端监控一般也分为三大类：」</strong></p>\n<h3 id=\"数据监控（监控用户行为）\"><a href=\"#数据监控（监控用户行为）\" class=\"headerlink\" title=\"数据监控（监控用户行为）\"></a>数据监控（监控用户行为）</h3><ul>\n<li>PV/UV: PV(page view)：即页面浏览量或点击量；UV（unique visitor）：指访问某个站点或点击某条新闻的不同 IP 地址的人数</li>\n<li>用户在每一个页面的停留时间</li>\n<li>用户通过什么入口来访问该网页</li>\n<li>用户在相应的页面中触发的行为，等…</li>\n</ul>\n<p>统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。</p>\n<h3 id=\"性能监控（监控页面性能）\"><a href=\"#性能监控（监控页面性能）\" class=\"headerlink\" title=\"性能监控（监控页面性能）\"></a>性能监控（监控页面性能）</h3><ul>\n<li>不同用户，不同机型和不同系统下的首屏加载时间</li>\n<li>白屏时间</li>\n<li>http 等请求的响应时间</li>\n<li>静态资源整体下载时间</li>\n<li>页面渲染时间</li>\n<li>页面交互动画完成时间，等…</li>\n</ul>\n<p>这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，尽可能的提高用户体验。</p>\n<h3 id=\"异常监控（监控产品、系统异常）\"><a href=\"#异常监控（监控产品、系统异常）\" class=\"headerlink\" title=\"异常监控（监控产品、系统异常）\"></a>异常监控（监控产品、系统异常）</h3><p>及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 <code>try catch</code> 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：</p>\n<ul>\n<li>Javascript 的异常监控</li>\n<li>样式丢失的异常监控</li>\n</ul>\n<h2 id=\"数据采集\"><a href=\"#数据采集\" class=\"headerlink\" title=\"数据采集\"></a>数据采集</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L40t3R.png\" alt=\"img\"></p>\n<h3 id=\"Performance-—-前端性能监控\"><a href=\"#Performance-—-前端性能监控\" class=\"headerlink\" title=\"Performance — 前端性能监控\"></a>Performance — 前端性能监控</h3><p>一、什么是performance<br>performance可以获取到当前页面中与性能相关的信息，可以检测到白屏时间、首屏时间、用户可操作的时间节点、页面总下载的时间、DNS查询的时间、TCP链接的时间等。</p>\n<p>二、前端性能主要测试点<br>白屏时间：从打开网站到有内容渲染出来的时间点<br>首屏时间：首屏内容渲染完毕的时间节点<br>用户可操作时间节点：domready触发节点<br>总下载时间：window.onload的触发节点<br>新建个<a href=\"https://doc.roadtel.top/download/attachments/1082328/demo.html?version=1&modificationDate=1650785189325&api=v2\">demo.html</a></p>\n<p>其中 memory 是和内存相关的，navigation 是指来源相关的，timing是关键点时间。</p>\n<p>performance.memory 含义是显示此刻内存占用的情况</p>\n<p>jsHeapSizeLimit 表示内存大小的限制</p>\n<p>totalJSHeapSize 表示总内存的大小</p>\n<p>usedJSHeapSize 表示可使用的内存大小</p>\n<p>如果 usedJSHeadSize 大于 totalJSHeadSize 的话，那么会出现内存泄露的问题，因此不允许出现这种情况</p>\n<p>performance.navigation 含义是页面的来源信息</p>\n<p>redirectCount 如果有重定向，页面通过几次重定向跳转而来，默认为0</p>\n<p>type 表示页面打开方式，默认为0，可取值为0、1、2、255</p>\n<p>0 (TYPE_NAVIGATE) 表示正常进入该页面（非刷新、非重定向）</p>\n<p>1 (TYPE_RELOAD) 表示通过window.location.reload刷新的页面</p>\n<p>2 (TYPE_BACK_FORWARD) 表示通过浏览器的前进、后退按钮进入的页面</p>\n<p>255 (TYPE_RESERVED) 表示非以上方式进入页面</p>\n<p>performance.onresourcetimingbufferfull 一个回调函数，会在浏览器的资源时间性能缓冲区满了的时候执行</p>\n<p>performance.timeOrigin 是一系列时间点的基准点，精确到万分之一毫秒，动态的，刷新页面会改变</p>\n<p>performance.timing 是一系列关键时间点，包含网络、解析等一系列时间数据</p>\n<p>navigationStart 同一个浏览器上一个页面卸载结束时的时间戳。如果没有上一个页面，那么该值会和fetchStart的值相同</p>\n<p>redirectStart 第一个http重定向开始的时间戳，如果没有重定向，或重定向到同一个不同的源，那么返回0</p>\n<p>redirectEnd 最后一个http重定向完成时的时间戳。如果没有重定向，或重定向到一个不同的源，那么返回为0</p>\n<p>fetchStart 浏览器准备好使用http请求抓取文档的时间（发生在检查本地缓存之前）</p>\n<p>domainLookupStart DNS域名查询开始时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同</p>\n<p>domainLookupEnd DNS域名查询结束时间，如果使用了本地缓存或持久链接，该值则与fetchStart相同</p>\n<p>connectStart http开始建立连接的时间，如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间</p>\n<p>secureConnectionStart https链接开始的时间，如果不是安全链接，则值为0</p>\n<p>connectEnd http完成建立链接的时间（完成握手），如果是持久链接的话，该值和fetchStart值相同，如果再在传输层发生了错误且需要重新建立链接的话，那么在这里显示的是新建立的链接开始时间</p>\n<p>requestStart http请求读取真实文档开始的时间，包括从本地读取缓存，链接错误重连时</p>\n<p>responseStart 开始接收到响应的时间（获取到第一个字节的时候），包括从本地读取缓存</p>\n<p>responseEnd http响应全部接收完成时的时间（获取到最后一个字节）包括从本地读取缓存</p>\n<p>unloadEventStart 前一个网页（和当前页面同域）unload的时间戳，如果没有前一个网页或前一个网页是不同的域的话，那么该值为0</p>\n<p>unloadEventEnd 与unloadEventStart对应，返回是前一个网页unload事件绑定的回调函数执行完毕时间戳</p>\n<p>domLoading 开始解析渲染DOM树的时间</p>\n<p>domInteractive 完成解析DOM树的时间（只是DOM树解析完成，但是并没有开始加载网页的资源）</p>\n<p>domContentLoadedEventStart DOM解析完成后，网页内资源加载开始的时间</p>\n<p>domContentLoadedEventEnd DOM解析完成后，网页内资源加载完成的时间</p>\n<p>domComplete DOM树解析完成，且资源也准备就绪的时间。Document.readyState变为complete，并将抛出readystatechange相关事件</p>\n<p>loadEventStart load事件发送给文档。也即load回调函数开始执行的时间，如果没有绑定load事件，则该值为0</p>\n<p>loadEventEnd load事件的回调函数执行完毕时间，如果没有绑定load事件，该值为0</p>\n<p>测试点代码</p>\n<p>重定向耗时 = redirectEnd - redirectStart<br>DNS查询耗时 = domainLookupEnd - domainLookupStart<br>TCP链接耗时 = connectEnd - connectStart<br>HTTP请求耗时 = responseEnd - responseStart<br>解析dom树耗时 = domComplete - domInteractive<br>白屏时间 = responseStart - navigationStart<br>DOMready时间 = domContentLoadedEventEnd - navigationStart<br>onload时间 = loadEventEnd - navigationStart</p>\n<h2 id=\"埋点上报\"><a href=\"#埋点上报\" class=\"headerlink\" title=\"埋点上报\"></a>埋点上报</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L4dm5j.png\" alt=\"img\"></p>\n<p>OK，上面我们说到了前端监控的三个分类，了解了一个产品需要监控哪些内容以及为什么需要监控这些内容，那么我们应该怎么实现前端监控呢？</p>\n<p>实现前端监控，第一步肯定是将我们要监控的事项（数据）给收集起来，再提交给后台进行入库，最后再给数据分析组进行数据分析，最后处理好的数据再同步给运营或者是产品。数据收集的丰富性和准确性会直接影响到我们做前端监控的质量，因为我们会以此为基础，为产品的未来发展指引方向。</p>\n<p>现在常见的埋点上报方法有三种：<code>手动埋点</code>、<code>可视化埋点</code>、<code>无埋点</code></p>\n<h3 id=\"手动埋点\"><a href=\"#手动埋点\" class=\"headerlink\" title=\"手动埋点\"></a>手动埋点</h3><p>手动埋点，也叫代码埋点，即纯手动写代码，调用埋点 SDK 的函数，在需要埋点的业务逻辑功能位置调用接口，上报埋点数据，像**[友盟]<strong>、</strong>[百度统计]**等第三方数据统计服务商大都采用这种方案。手动埋点让使用者可以方便地设置自定义属性、自定义事件；所以当你需要深入下钻，并精细化自定义分析时，比较适合使用手动埋点。</p>\n<p>手动埋点的缺陷就是，项目工程量大，需要埋点的位置太多，而且需要产品开发运营之间相互反复沟通，容易出现手动差错，如果错误，重新埋点的成本也很高。</p>\n<h3 id=\"可视化埋点\"><a href=\"#可视化埋点\" class=\"headerlink\" title=\"可视化埋点\"></a>可视化埋点</h3><p>通过可视化交互的手段，代替上述的代码埋点。将业务代码和埋点代码分离，提供一个可视化交互的页面，输入为业务代码，通过这个可视化系统，可以在业务代码中自定义的增加埋点事件等等，最后输出的代码耦合了业务代码和埋点代码。</p>\n<p>可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。</p>\n<h3 id=\"无埋点\"><a href=\"#无埋点\" class=\"headerlink\" title=\"无埋点\"></a>无埋点</h3><p>无埋点则是前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，缺点是流量和采集的数据过于庞大，服务器性能压力山大。</p>\n<p><img src=\"https://s1.ax1x.com/2022/04/24/L4aqv6.png\" alt=\"img\"></p>\n<h2 id=\"标准化埋点数据\"><a href=\"#标准化埋点数据\" class=\"headerlink\" title=\"标准化埋点数据\"></a>标准化埋点数据</h2><p><img src=\"https://s1.ax1x.com/2022/04/24/L4weOK.png\" alt=\"img\"></p>\n<h2 id=\"日志存储\"><a href=\"#日志存储\" class=\"headerlink\" title=\"日志存储\"></a>日志存储</h2><p>1.上传到服务器</p>\n<ul>\n<li>日志量过大，可能导致传输、存储、查询速度等问题</li>\n<li>过于频繁上报、会增加服务器压力</li>\n<li>网络传输，容易导致日志丢失等问题</li>\n<li>消耗前端资源，影响主业务</li>\n</ul>\n<p>2.本地存储</p>\n<ul>\n<li>需要引导用户手动提交日志</li>\n<li>通过后台下发命令拉取日志</li>\n</ul>\n<h2 id=\"为什么都用GIF来做埋点？\"><a href=\"#为什么都用GIF来做埋点？\" class=\"headerlink\" title=\"为什么都用GIF来做埋点？\"></a>为什么都用GIF来做埋点？</h2><h3 id=\"发现过程\"><a href=\"#发现过程\" class=\"headerlink\" title=\"发现过程\"></a>发现过程</h3><p>首先说一下我是怎么发现的，前一段时间，产品提了个需求，说我们现在的书籍曝光上报规范并不是他们想要的数据，并且以后所有页面的书籍上报都统一成最新规范。</p>\n<p>曝光规范：</p>\n<ul>\n<li>书籍出现在可视区并停留1秒，算作有效曝光</li>\n<li>书籍不能重复曝光，假如它一直在可视区滚动时只能上报一次</li>\n<li>当它移出可视区后再回到可视区，再按第一点进行曝光</li>\n</ul>\n<p>OK，既然要所有页面统一，那就只能封装成通用库来使用了，这里实现逻辑就不贴了，想看的私聊我发你，主要的难点就是停留时长计算，以及曝光标记。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\">const exposeReportClass = new exposeReport(&#123;<br>      scrollDom: <span class=\"hljs-string\">&quot;&quot;</span>,  <span class=\"hljs-regexp\">//</span> 滚动容器，建议指定一个滚动容器，不传默认为window<br>      watchDom: <span class=\"hljs-string\">&quot;.bookitem&quot;</span>, <span class=\"hljs-regexp\">//</span> 监听的dom,建议使用class类，标签也支持<br>      time: <span class=\"hljs-number\">1000</span>             <span class=\"hljs-regexp\">//</span> 停留有效时长ms<br>&#125;);<br><span class=\"hljs-regexp\">//</span> 提供两个上报方法<br>exposeReportClass.didReport(()=&gt;&#123;<br>  <span class=\"hljs-regexp\">//</span> 手动上报<br>  <span class=\"hljs-regexp\">//</span>callback<br>&#125;)<br>exposeReportClass.scrollReport(()=&gt;&#123;<br>  <span class=\"hljs-regexp\">//</span> 滚动上报<br>  <span class=\"hljs-regexp\">//</span>callback<br>&#125;)<br><span class=\"hljs-regexp\">//</span> <br></code></pre></td></tr></table></figure>\n\n<p>具体业务逻辑之需要放在对应的callback里面，而上报逻辑开发者无需考虑，因为我底层已经统一处理好了。</p>\n<p>然后我再测试的时候就发现，上报发的请求居然是通过图片发起的，并不是我们认为的接口上报。</p>\n<p><img src=\"https://s1.ax1x.com/2022/04/24/L4wR7F.png\" alt=\"img\"></p>\n<p>然后我去查了下资料，发现很多大厂的上报都是这么干的！</p>\n<h3 id=\"使用GIF上报的原因\"><a href=\"#使用GIF上报的原因\" class=\"headerlink\" title=\"使用GIF上报的原因\"></a>使用GIF上报的原因</h3><p>向服务器端上报数据，可以通过请求接口，请求普通文件，或者请求图片资源的方式进行。<strong>只要能上报数据，无论是请求GIF文件还是请求其他普通文件(JS)或者是请求接口，服务器端其实并不关心具体的上报方式。</strong>那为什么所有系统都统一使用了请求GIF图片的方式上报数据呢？</p>\n<p><strong>「防止跨域」</strong></p>\n<p>一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。但图片的src属性并不会跨域，并且同样可以发起请求。（排除接口上报）</p>\n<p><strong>「防止阻塞页面加载，影响用户体验」</strong></p>\n<p>通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。</p>\n<p>但是图片请求例外。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题，在没有js的浏览器环境中也能通过img标签正常打点，这是其他类型的资源请求所做不到的。（排除文件方式）</p>\n<p><strong>「相比PNG/JPG，GIF的体积最小」</strong></p>\n<p>最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。</p>\n<p>同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。</p>\n<p>1兆字节(mb)=1048576字节(b)</p>\n<p>1048576/43 ≈ 24385</p>\n<p><strong>「并且大多采用的是1*1像素的透明GIF来上报」</strong></p>\n<p>1x1像素是最小的合法图片。而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。</p>\n"},{"title":"同时安装一个包的多个版本","date":"2021-09-30T06:07:42.000Z","_content":"\n在Sass环境和私有化环境需要使用同一个依赖库的不同版本，不要问我为什么需要使用不同版本，而不是在依赖中抹平差异，依赖的提供方他不做啊。当时的第一反应是：应该不能同时安装同一个依赖的不同版本吧？结果查询了下，发现竟然可以，哈哈哈哈，果然是我孤陋寡闻了。\n\n安装的时候，重命名依赖名称，即可以轻松解决此问题。\n\n```js\nyarn add <alias>@npm:<packageName>@version\n```\n\n比如安装两个不同版本的lodash\n\n```js\nyarn add lodash@^4.0.0\nyarn add lodash-private@npm:lodash@3.0.0\n```\n\n安装后，node_modules目录中会有lodash和lodash-private两个目录\n\n然后，我们就可以在代码中，根据不同的环境去使用不同的依赖啦~\n\n如果你使用的是 npm 的话，那么可以这样安装：\n\n```js\nnpm install lodash@^4.0.0\nnpm install lodash-private@npm:lodash@3.0.0\n```\n\n","source":"_posts/同时安装一个包的多个版本.md","raw":"---\ntitle: 同时安装一个包的多个版本\ndate: 2021-09-30 14:07:42\ntags: 环境搭建\ncategories:\n- 环境搭建\n---\n\n在Sass环境和私有化环境需要使用同一个依赖库的不同版本，不要问我为什么需要使用不同版本，而不是在依赖中抹平差异，依赖的提供方他不做啊。当时的第一反应是：应该不能同时安装同一个依赖的不同版本吧？结果查询了下，发现竟然可以，哈哈哈哈，果然是我孤陋寡闻了。\n\n安装的时候，重命名依赖名称，即可以轻松解决此问题。\n\n```js\nyarn add <alias>@npm:<packageName>@version\n```\n\n比如安装两个不同版本的lodash\n\n```js\nyarn add lodash@^4.0.0\nyarn add lodash-private@npm:lodash@3.0.0\n```\n\n安装后，node_modules目录中会有lodash和lodash-private两个目录\n\n然后，我们就可以在代码中，根据不同的环境去使用不同的依赖啦~\n\n如果你使用的是 npm 的话，那么可以这样安装：\n\n```js\nnpm install lodash@^4.0.0\nnpm install lodash-private@npm:lodash@3.0.0\n```\n\n","slug":"同时安装一个包的多个版本","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf4000nb0gifiov7tcz","content":"<p>在Sass环境和私有化环境需要使用同一个依赖库的不同版本，不要问我为什么需要使用不同版本，而不是在依赖中抹平差异，依赖的提供方他不做啊。当时的第一反应是：应该不能同时安装同一个依赖的不同版本吧？结果查询了下，发现竟然可以，哈哈哈哈，果然是我孤陋寡闻了。</p>\n<p>安装的时候，重命名依赖名称，即可以轻松解决此问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">yarn add &lt;alias&gt;@npm:&lt;packageName&gt;@version<br></code></pre></td></tr></table></figure>\n\n<p>比如安装两个不同版本的lodash</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">yarn add lodash@^<span class=\"hljs-number\">4.0</span><span class=\"hljs-number\">.0</span><br>yarn add lodash-private@npm:lodash@<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n<p>安装后，node_modules目录中会有lodash和lodash-private两个目录</p>\n<p>然后，我们就可以在代码中，根据不同的环境去使用不同的依赖啦~</p>\n<p>如果你使用的是 npm 的话，那么可以这样安装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">npm install lodash@^<span class=\"hljs-number\">4.0</span><span class=\"hljs-number\">.0</span><br>npm install lodash-private@npm:lodash@<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n","site":{"data":{}},"wordcount":445,"excerpt":"","more":"<p>在Sass环境和私有化环境需要使用同一个依赖库的不同版本，不要问我为什么需要使用不同版本，而不是在依赖中抹平差异，依赖的提供方他不做啊。当时的第一反应是：应该不能同时安装同一个依赖的不同版本吧？结果查询了下，发现竟然可以，哈哈哈哈，果然是我孤陋寡闻了。</p>\n<p>安装的时候，重命名依赖名称，即可以轻松解决此问题。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">yarn add &lt;alias&gt;@npm:&lt;packageName&gt;@version<br></code></pre></td></tr></table></figure>\n\n<p>比如安装两个不同版本的lodash</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">yarn add lodash@^<span class=\"hljs-number\">4.0</span><span class=\"hljs-number\">.0</span><br>yarn add lodash-private@npm:lodash@<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n<p>安装后，node_modules目录中会有lodash和lodash-private两个目录</p>\n<p>然后，我们就可以在代码中，根据不同的环境去使用不同的依赖啦~</p>\n<p>如果你使用的是 npm 的话，那么可以这样安装：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">npm install lodash@^<span class=\"hljs-number\">4.0</span><span class=\"hljs-number\">.0</span><br>npm install lodash-private@npm:lodash@<span class=\"hljs-number\">3.0</span><span class=\"hljs-number\">.0</span><br></code></pre></td></tr></table></figure>\n\n"},{"title":"报错合集及解决办法","date":"2021-10-08T02:21:22.000Z","_content":"\n# 报错合集及解决办法\n\n## 一、安装使用报错\n\n## 1.1安装Verdaccio遇到问题\n\n在使用nrm时报错\n\n![](https://z3.ax1x.com/2021/10/08/59bPc4.png)\n\n检查报错的位置，找到cli.js 打开做代码替换\n\n![](https://z3.ax1x.com/2021/10/08/59ba8S.png)\n\n方便复制粘贴\n\n```js\n// const NRMRC = path.join(process.env.HOME, '.nrmrc');\nconst NRMRC = path.join(process.env[(process.platform == 'win32')?'USERPROFILE':'HOME'], '.nrmrc');\n\n```\n\n## 1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法\n\n**VSCode终端使用PowerShell，创建vue项目时，出现了以下错误导致创建失败：vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1**\n\n1.PowerShell的执行政策阻止了该操作。\n用 **`Get-ExecutionPolicy`** 查看发现执行策略为受限状态：\n\n[![5CCXzn.png](https://z3.ax1x.com/2021/10/08/5CCXzn.png)](https://imgtu.com/i/5CCXzn)\n\n同时PowerShell给出了我们解决问题的方法\n\n[![5CPii4.png](https://z3.ax1x.com/2021/10/08/5CPii4.png)](https://imgtu.com/i/5CPii4)\n\n2.此时我们按照要求输入**Set-ExecutionPolicy -Scope CurrentUser**命令，回车，在黑窗口中输入RemoteSigned解除受限[![5CPneK.png](https://z3.ax1x.com/2021/10/08/5CPneK.png)](https://imgtu.com/i/5CPneK)\n\n3.接下来我们查看受限状态 输入**get-ExecutionPolicy**，此时结果为RemoteSigned（受限移除），这样我们就可以正常创建了\n\n[![5CPNef.png](https://z3.ax1x.com/2021/10/08/5CPNef.png)](https://imgtu.com/i/5CPNef)\n\n \n","source":"_posts/报错合集及解决办法.md","raw":"---\ntitle: 报错合集及解决办法\ndate: 2021-10-08 10:21:22\ntags: 报错集合\ncategories:\n- 报错解决集合\n---\n\n# 报错合集及解决办法\n\n## 一、安装使用报错\n\n## 1.1安装Verdaccio遇到问题\n\n在使用nrm时报错\n\n![](https://z3.ax1x.com/2021/10/08/59bPc4.png)\n\n检查报错的位置，找到cli.js 打开做代码替换\n\n![](https://z3.ax1x.com/2021/10/08/59ba8S.png)\n\n方便复制粘贴\n\n```js\n// const NRMRC = path.join(process.env.HOME, '.nrmrc');\nconst NRMRC = path.join(process.env[(process.platform == 'win32')?'USERPROFILE':'HOME'], '.nrmrc');\n\n```\n\n## 1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法\n\n**VSCode终端使用PowerShell，创建vue项目时，出现了以下错误导致创建失败：vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1**\n\n1.PowerShell的执行政策阻止了该操作。\n用 **`Get-ExecutionPolicy`** 查看发现执行策略为受限状态：\n\n[![5CCXzn.png](https://z3.ax1x.com/2021/10/08/5CCXzn.png)](https://imgtu.com/i/5CCXzn)\n\n同时PowerShell给出了我们解决问题的方法\n\n[![5CPii4.png](https://z3.ax1x.com/2021/10/08/5CPii4.png)](https://imgtu.com/i/5CPii4)\n\n2.此时我们按照要求输入**Set-ExecutionPolicy -Scope CurrentUser**命令，回车，在黑窗口中输入RemoteSigned解除受限[![5CPneK.png](https://z3.ax1x.com/2021/10/08/5CPneK.png)](https://imgtu.com/i/5CPneK)\n\n3.接下来我们查看受限状态 输入**get-ExecutionPolicy**，此时结果为RemoteSigned（受限移除），这样我们就可以正常创建了\n\n[![5CPNef.png](https://z3.ax1x.com/2021/10/08/5CPNef.png)](https://imgtu.com/i/5CPNef)\n\n \n","slug":"报错合集及解决办法","published":1,"updated":"2022-11-20T05:15:37.978Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf4000pb0gi3on33zyy","content":"<h1 id=\"报错合集及解决办法\"><a href=\"#报错合集及解决办法\" class=\"headerlink\" title=\"报错合集及解决办法\"></a>报错合集及解决办法</h1><h2 id=\"一、安装使用报错\"><a href=\"#一、安装使用报错\" class=\"headerlink\" title=\"一、安装使用报错\"></a>一、安装使用报错</h2><h2 id=\"1-1安装Verdaccio遇到问题\"><a href=\"#1-1安装Verdaccio遇到问题\" class=\"headerlink\" title=\"1.1安装Verdaccio遇到问题\"></a>1.1安装Verdaccio遇到问题</h2><p>在使用nrm时报错</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/08/59bPc4.png\"></p>\n<p>检查报错的位置，找到cli.js 打开做代码替换</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/08/59ba8S.png\"></p>\n<p>方便复制粘贴</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;);</span><br><span class=\"hljs-keyword\">const</span> NRMRC = path.join(process.env[(process.platform == <span class=\"hljs-string\">&#x27;win32&#x27;</span>)?<span class=\"hljs-string\">&#x27;USERPROFILE&#x27;</span>:<span class=\"hljs-string\">&#x27;HOME&#x27;</span>], <span class=\"hljs-string\">&#x27;.nrmrc&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-vue-无法加载文件-F-nodejs-node-global-vue-ps1，因为在此系统上禁止运行脚本”的解决方法\"><a href=\"#1-2-vue-无法加载文件-F-nodejs-node-global-vue-ps1，因为在此系统上禁止运行脚本”的解决方法\" class=\"headerlink\" title=\"1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法\"></a>1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法</h2><p><strong>VSCode终端使用PowerShell，创建vue项目时，出现了以下错误导致创建失败：vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1</strong></p>\n<p>1.PowerShell的执行政策阻止了该操作。<br>用 <strong><code>Get-ExecutionPolicy</code></strong> 查看发现执行策略为受限状态：</p>\n<p><a href=\"https://imgtu.com/i/5CCXzn\"><img src=\"https://z3.ax1x.com/2021/10/08/5CCXzn.png\" alt=\"5CCXzn.png\"></a></p>\n<p>同时PowerShell给出了我们解决问题的方法</p>\n<p><a href=\"https://imgtu.com/i/5CPii4\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPii4.png\" alt=\"5CPii4.png\"></a></p>\n<p>2.此时我们按照要求输入<strong>Set-ExecutionPolicy -Scope CurrentUser</strong>命令，回车，在黑窗口中输入RemoteSigned解除受限<a href=\"https://imgtu.com/i/5CPneK\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPneK.png\" alt=\"5CPneK.png\"></a></p>\n<p>3.接下来我们查看受限状态 输入<strong>get-ExecutionPolicy</strong>，此时结果为RemoteSigned（受限移除），这样我们就可以正常创建了</p>\n<p><a href=\"https://imgtu.com/i/5CPNef\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPNef.png\" alt=\"5CPNef.png\"></a></p>\n","site":{"data":{}},"wordcount":644,"excerpt":"","more":"<h1 id=\"报错合集及解决办法\"><a href=\"#报错合集及解决办法\" class=\"headerlink\" title=\"报错合集及解决办法\"></a>报错合集及解决办法</h1><h2 id=\"一、安装使用报错\"><a href=\"#一、安装使用报错\" class=\"headerlink\" title=\"一、安装使用报错\"></a>一、安装使用报错</h2><h2 id=\"1-1安装Verdaccio遇到问题\"><a href=\"#1-1安装Verdaccio遇到问题\" class=\"headerlink\" title=\"1.1安装Verdaccio遇到问题\"></a>1.1安装Verdaccio遇到问题</h2><p>在使用nrm时报错</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/08/59bPc4.png\"></p>\n<p>检查报错的位置，找到cli.js 打开做代码替换</p>\n<p><img src=\"https://z3.ax1x.com/2021/10/08/59ba8S.png\"></p>\n<p>方便复制粘贴</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-comment\">// const NRMRC = path.join(process.env.HOME, &#x27;.nrmrc&#x27;);</span><br><span class=\"hljs-keyword\">const</span> NRMRC = path.join(process.env[(process.platform == <span class=\"hljs-string\">&#x27;win32&#x27;</span>)?<span class=\"hljs-string\">&#x27;USERPROFILE&#x27;</span>:<span class=\"hljs-string\">&#x27;HOME&#x27;</span>], <span class=\"hljs-string\">&#x27;.nrmrc&#x27;</span>);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"1-2-vue-无法加载文件-F-nodejs-node-global-vue-ps1，因为在此系统上禁止运行脚本”的解决方法\"><a href=\"#1-2-vue-无法加载文件-F-nodejs-node-global-vue-ps1，因为在此系统上禁止运行脚本”的解决方法\" class=\"headerlink\" title=\"1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法\"></a>1.2 vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1，因为在此系统上禁止运行脚本”的解决方法</h2><p><strong>VSCode终端使用PowerShell，创建vue项目时，出现了以下错误导致创建失败：vue : 无法加载文件 F:\\nodejs\\node_global\\vue.ps1</strong></p>\n<p>1.PowerShell的执行政策阻止了该操作。<br>用 <strong><code>Get-ExecutionPolicy</code></strong> 查看发现执行策略为受限状态：</p>\n<p><a href=\"https://imgtu.com/i/5CCXzn\"><img src=\"https://z3.ax1x.com/2021/10/08/5CCXzn.png\" alt=\"5CCXzn.png\"></a></p>\n<p>同时PowerShell给出了我们解决问题的方法</p>\n<p><a href=\"https://imgtu.com/i/5CPii4\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPii4.png\" alt=\"5CPii4.png\"></a></p>\n<p>2.此时我们按照要求输入<strong>Set-ExecutionPolicy -Scope CurrentUser</strong>命令，回车，在黑窗口中输入RemoteSigned解除受限<a href=\"https://imgtu.com/i/5CPneK\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPneK.png\" alt=\"5CPneK.png\"></a></p>\n<p>3.接下来我们查看受限状态 输入<strong>get-ExecutionPolicy</strong>，此时结果为RemoteSigned（受限移除），这样我们就可以正常创建了</p>\n<p><a href=\"https://imgtu.com/i/5CPNef\"><img src=\"https://z3.ax1x.com/2021/10/08/5CPNef.png\" alt=\"5CPNef.png\"></a></p>\n"},{"title":"搭建samba服务实现文件共享","date":"2023-01-28T01:24:10.000Z","_content":"\n在一些中小型网络，或者企业的内部网中，利用 Linux 建立文件服务器是一个很好的解决方案。针对企业内部网中的绝大部分客户机采用 Windows 的情况，我们可以通过使用 Samba 来实现文件服务器功能。\nSamba 是在 Linux 及 Unix 上实现 SMB（Server Message Block）协议的一个免费软件，由服务器及客户端程序构成。这里我们只介绍服务器程序。\n我们首先介绍一些 SMB 协议的情况。SMB 协议是建立在 NetBIOS 协议之上的应用协议，是基于 TCP138、139 两个端口的服务。NetBIOS 出现之后，Microsoft 就使用 NetBIOS 实现了一个网络文件/打印服务系统。这个系统基于 NetBIOS 设定了一套文件共享协议，Microsoft 称之为 SMB（Server Message Block）协议。这个协议被用于 Lan Manager 和 Windows 服务器系统中，实现不同计算机之间共享打印机和文件等。因此，为了让 Windows 和 Unix/Linux 计算机相集成，最好的办法就是在 Unix/Linux 计算机中安装支持 SMB 协议的软件。这样使用 Windows 的客户端不需要更改设置，就能像使用 Windows NT 或 Windows 2000 服务器一样，使用 Unix/Linux 计算机上的共享资源了。Samba 使 SMB 协议运行在 NetBIOS 协议上，并且使用 Windows 的 NetBEUI 协议让 Unix/Linux 服务器可以在 Windows 的网络邻居上被访问到。\n\n## 安装：\n\n```bash\n##（首先更新系统的软件下载源）\nsudo apt-get update\n##（可选对ubuntu进行系统升级！）\nsudo apt-get upgrade\n## 正式安装\nsudo apt-get install samba\n## 安装结束后创建Samba用户，用户名及密码\nsudo smbpasswd -a xxx  ## xxx为用户名\n##（输入密码2次：）\nNew SMB password:\nRetype new SMB password:\n\n## 备份原配置\nsudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak\n## 编辑配置文件\nsudo gedit /etc/samba/smb.conf\n## 如果提示 gedit:1505157): Gtk-WARNING **: 23:46:14.954: cannot open display:可以通过vim进行编辑\nsudo vim /etc/samba/smb.conf\n```\n\n## 配置：\n\n### 配置文件常用指令说明:\n\ncomment=STRING :注释；\npath=/PATH/TO/FILENAME :当前共享所映射的文件系统路径；\nbrowseable=YES :是否可浏览，指是否可被用户查看；\nguest ok=YES :是否允许来宾账号访问；\nbrowseable = No :是否公开目录\nwritable=YES :是否可写；\nread only = no|yes :是否为只读\nwrite list=/PATH/TO/user_list :拥有写权限的用户列表；\n\n**在文件尾部添加以下内容，根据自己需要修改，并保存文件**\n\n```bash\n[share]\npath = /media/pi  ## 路径建议提前分配好读写权限 sudo chmod -R 777 /media/pi\navailable = yes\nbrowsealbe = yes\nvalid usere = pi     ## 创建的用户名\nwritable = yes\nguest ok = no\nread only = no\n```\n\n- [share] 是共享文件夹显示的名称\n- 上面配置了禁止匿名登录，允许用户读写文件\n- 更多配置方式https://www.samba.org/\n- 注意 如果共享的文件夹中包含中文可能会出现乱码，建议在[global]修改字符集为 utf-8\n\n```bash\n## 原有\n   display charset = cp936\n   unix charset = cp936\n   dos  charset = cp936\n## 更改为\n   dos charset = UTF-8\n   unix charset = utf-8\n   display charset = utf-8\n```\n\n- 如果映射过慢，可采用如下方法, 通过 testparm 检查配置\n\n```bash\n## 在[global]下添加如下配置\n   read raw = Yes\n   write raw = Yes\n   socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072\n   min receivefile size = 16384\n   use sendfile = true\n   aio read size = 16384\n   aio write size = 16384\n   max xmit = 65535\n   max connections = 0\n   deadtime = 0\n## 配置结束\n[printers]\n   comment = All Printers\n```\n\n## 启动：\n\n保存退出:wq\n\n```bash\n/etc/init.d/smbd restart  ## 重启SMB 使配置生效\n```\n\n这个时候 samba 的安装配置工作就已经完成了，当然可以保底操作一下,确保一切正常\n\n```bash\nsudo apt install cifs-utils -y ## 安装cifs\nsudo apt-get install samba -y ## 更新samba\nsudo ufw allow samba ## 防火墙豁免\n/etc/init.d/smbd restart ## 重启即可\n```\n\n## 验证\n\nwin + R 输入\\\\192.168.1.66\\share 输入实际的主机 ip 可通过 ifconfig 在 linux 机器上查\n\n```bash\nnetstat -tunpl | grep smbd\n```\n\n- 注意：如果是服务商接入会屏蔽掉 445 139 端口\n  在配置文件的[global]项中加入一行\n\n```bash\nsmb ports = 1314\n```\n\n## 小结\n\nsamba 服务器功能\n1）提供 Windows 风格文件或打印机的共享\n2）在 Windows 网络中解析 NETBIOS 名字\n3）提供 smb 客户功能\n4）提供一个命令行工具，利用该工具限制支持 Windows 的某些管理功能\n","source":"_posts/搭建samba服务实现文件共享.md","raw":"---\ntitle: 搭建samba服务实现文件共享\ndate: 2023-01-28 09:24:10\ntags: DevOps\ncategories:\n  - DevOps\n---\n\n在一些中小型网络，或者企业的内部网中，利用 Linux 建立文件服务器是一个很好的解决方案。针对企业内部网中的绝大部分客户机采用 Windows 的情况，我们可以通过使用 Samba 来实现文件服务器功能。\nSamba 是在 Linux 及 Unix 上实现 SMB（Server Message Block）协议的一个免费软件，由服务器及客户端程序构成。这里我们只介绍服务器程序。\n我们首先介绍一些 SMB 协议的情况。SMB 协议是建立在 NetBIOS 协议之上的应用协议，是基于 TCP138、139 两个端口的服务。NetBIOS 出现之后，Microsoft 就使用 NetBIOS 实现了一个网络文件/打印服务系统。这个系统基于 NetBIOS 设定了一套文件共享协议，Microsoft 称之为 SMB（Server Message Block）协议。这个协议被用于 Lan Manager 和 Windows 服务器系统中，实现不同计算机之间共享打印机和文件等。因此，为了让 Windows 和 Unix/Linux 计算机相集成，最好的办法就是在 Unix/Linux 计算机中安装支持 SMB 协议的软件。这样使用 Windows 的客户端不需要更改设置，就能像使用 Windows NT 或 Windows 2000 服务器一样，使用 Unix/Linux 计算机上的共享资源了。Samba 使 SMB 协议运行在 NetBIOS 协议上，并且使用 Windows 的 NetBEUI 协议让 Unix/Linux 服务器可以在 Windows 的网络邻居上被访问到。\n\n## 安装：\n\n```bash\n##（首先更新系统的软件下载源）\nsudo apt-get update\n##（可选对ubuntu进行系统升级！）\nsudo apt-get upgrade\n## 正式安装\nsudo apt-get install samba\n## 安装结束后创建Samba用户，用户名及密码\nsudo smbpasswd -a xxx  ## xxx为用户名\n##（输入密码2次：）\nNew SMB password:\nRetype new SMB password:\n\n## 备份原配置\nsudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak\n## 编辑配置文件\nsudo gedit /etc/samba/smb.conf\n## 如果提示 gedit:1505157): Gtk-WARNING **: 23:46:14.954: cannot open display:可以通过vim进行编辑\nsudo vim /etc/samba/smb.conf\n```\n\n## 配置：\n\n### 配置文件常用指令说明:\n\ncomment=STRING :注释；\npath=/PATH/TO/FILENAME :当前共享所映射的文件系统路径；\nbrowseable=YES :是否可浏览，指是否可被用户查看；\nguest ok=YES :是否允许来宾账号访问；\nbrowseable = No :是否公开目录\nwritable=YES :是否可写；\nread only = no|yes :是否为只读\nwrite list=/PATH/TO/user_list :拥有写权限的用户列表；\n\n**在文件尾部添加以下内容，根据自己需要修改，并保存文件**\n\n```bash\n[share]\npath = /media/pi  ## 路径建议提前分配好读写权限 sudo chmod -R 777 /media/pi\navailable = yes\nbrowsealbe = yes\nvalid usere = pi     ## 创建的用户名\nwritable = yes\nguest ok = no\nread only = no\n```\n\n- [share] 是共享文件夹显示的名称\n- 上面配置了禁止匿名登录，允许用户读写文件\n- 更多配置方式https://www.samba.org/\n- 注意 如果共享的文件夹中包含中文可能会出现乱码，建议在[global]修改字符集为 utf-8\n\n```bash\n## 原有\n   display charset = cp936\n   unix charset = cp936\n   dos  charset = cp936\n## 更改为\n   dos charset = UTF-8\n   unix charset = utf-8\n   display charset = utf-8\n```\n\n- 如果映射过慢，可采用如下方法, 通过 testparm 检查配置\n\n```bash\n## 在[global]下添加如下配置\n   read raw = Yes\n   write raw = Yes\n   socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072\n   min receivefile size = 16384\n   use sendfile = true\n   aio read size = 16384\n   aio write size = 16384\n   max xmit = 65535\n   max connections = 0\n   deadtime = 0\n## 配置结束\n[printers]\n   comment = All Printers\n```\n\n## 启动：\n\n保存退出:wq\n\n```bash\n/etc/init.d/smbd restart  ## 重启SMB 使配置生效\n```\n\n这个时候 samba 的安装配置工作就已经完成了，当然可以保底操作一下,确保一切正常\n\n```bash\nsudo apt install cifs-utils -y ## 安装cifs\nsudo apt-get install samba -y ## 更新samba\nsudo ufw allow samba ## 防火墙豁免\n/etc/init.d/smbd restart ## 重启即可\n```\n\n## 验证\n\nwin + R 输入\\\\192.168.1.66\\share 输入实际的主机 ip 可通过 ifconfig 在 linux 机器上查\n\n```bash\nnetstat -tunpl | grep smbd\n```\n\n- 注意：如果是服务商接入会屏蔽掉 445 139 端口\n  在配置文件的[global]项中加入一行\n\n```bash\nsmb ports = 1314\n```\n\n## 小结\n\nsamba 服务器功能\n1）提供 Windows 风格文件或打印机的共享\n2）在 Windows 网络中解析 NETBIOS 名字\n3）提供 smb 客户功能\n4）提供一个命令行工具，利用该工具限制支持 Windows 的某些管理功能\n","slug":"搭建samba服务实现文件共享","published":1,"updated":"2023-01-28T01:26:25.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf5000tb0gi0q50d8t0","content":"<p>在一些中小型网络，或者企业的内部网中，利用 Linux 建立文件服务器是一个很好的解决方案。针对企业内部网中的绝大部分客户机采用 Windows 的情况，我们可以通过使用 Samba 来实现文件服务器功能。<br>Samba 是在 Linux 及 Unix 上实现 SMB（Server Message Block）协议的一个免费软件，由服务器及客户端程序构成。这里我们只介绍服务器程序。<br>我们首先介绍一些 SMB 协议的情况。SMB 协议是建立在 NetBIOS 协议之上的应用协议，是基于 TCP138、139 两个端口的服务。NetBIOS 出现之后，Microsoft 就使用 NetBIOS 实现了一个网络文件/打印服务系统。这个系统基于 NetBIOS 设定了一套文件共享协议，Microsoft 称之为 SMB（Server Message Block）协议。这个协议被用于 Lan Manager 和 Windows 服务器系统中，实现不同计算机之间共享打印机和文件等。因此，为了让 Windows 和 Unix/Linux 计算机相集成，最好的办法就是在 Unix/Linux 计算机中安装支持 SMB 协议的软件。这样使用 Windows 的客户端不需要更改设置，就能像使用 Windows NT 或 Windows 2000 服务器一样，使用 Unix/Linux 计算机上的共享资源了。Samba 使 SMB 协议运行在 NetBIOS 协议上，并且使用 Windows 的 NetBEUI 协议让 Unix/Linux 服务器可以在 Windows 的网络邻居上被访问到。</p>\n<h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">##（首先更新系统的软件下载源）</span><br>sudo apt-get update<br><span class=\"hljs-comment\">##（可选对ubuntu进行系统升级！）</span><br>sudo apt-get upgrade<br><span class=\"hljs-comment\">## 正式安装</span><br>sudo apt-get install samba<br><span class=\"hljs-comment\">## 安装结束后创建Samba用户，用户名及密码</span><br>sudo smbpasswd -a xxx  <span class=\"hljs-comment\">## xxx为用户名</span><br><span class=\"hljs-comment\">##（输入密码2次：）</span><br>New SMB password:<br>Retype new SMB password:<br><br><span class=\"hljs-comment\">## 备份原配置</span><br>sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak<br><span class=\"hljs-comment\">## 编辑配置文件</span><br>sudo gedit /etc/samba/smb.conf<br><span class=\"hljs-comment\">## 如果提示 gedit:1505157): Gtk-WARNING **: 23:46:14.954: cannot open display:可以通过vim进行编辑</span><br>sudo vim /etc/samba/smb.conf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置：\"><a href=\"#配置：\" class=\"headerlink\" title=\"配置：\"></a>配置：</h2><h3 id=\"配置文件常用指令说明\"><a href=\"#配置文件常用指令说明\" class=\"headerlink\" title=\"配置文件常用指令说明:\"></a>配置文件常用指令说明:</h3><p>comment=STRING :注释；<br>path=/PATH/TO/FILENAME :当前共享所映射的文件系统路径；<br>browseable=YES :是否可浏览，指是否可被用户查看；<br>guest ok=YES :是否允许来宾账号访问；<br>browseable = No :是否公开目录<br>writable=YES :是否可写；<br>read only = no|yes :是否为只读<br>write list=/PATH/TO/user_list :拥有写权限的用户列表；</p>\n<p><strong>在文件尾部添加以下内容，根据自己需要修改，并保存文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[share]<br>path = /media/pi  <span class=\"hljs-comment\">## 路径建议提前分配好读写权限 sudo chmod -R 777 /media/pi</span><br>available = yes<br>browsealbe = yes<br>valid usere = pi     <span class=\"hljs-comment\">## 创建的用户名</span><br>writable = yes<br>guest ok = no<br><span class=\"hljs-built_in\">read</span> only = no<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>[share] 是共享文件夹显示的名称</li>\n<li>上面配置了禁止匿名登录，允许用户读写文件</li>\n<li>更多配置方式<a href=\"https://www.samba.org/\">https://www.samba.org/</a></li>\n<li>注意 如果共享的文件夹中包含中文可能会出现乱码，建议在[global]修改字符集为 utf-8</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 原有</span><br>   display charset = cp936<br>   unix charset = cp936<br>   dos  charset = cp936<br><span class=\"hljs-comment\">## 更改为</span><br>   dos charset = UTF-8<br>   unix charset = utf-8<br>   display charset = utf-8<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果映射过慢，可采用如下方法, 通过 testparm 检查配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 在[global]下添加如下配置</span><br>   <span class=\"hljs-built_in\">read</span> raw = Yes<br>   write raw = Yes<br>   socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072<br>   min receivefile size = 16384<br>   use sendfile = <span class=\"hljs-literal\">true</span><br>   aio <span class=\"hljs-built_in\">read</span> size = 16384<br>   aio write size = 16384<br>   max xmit = 65535<br>   max connections = 0<br>   deadtime = 0<br><span class=\"hljs-comment\">## 配置结束</span><br>[printers]<br>   comment = All Printers<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动：\"><a href=\"#启动：\" class=\"headerlink\" title=\"启动：\"></a>启动：</h2><p>保存退出:wq</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/etc/init.d/smbd restart  <span class=\"hljs-comment\">## 重启SMB 使配置生效</span><br></code></pre></td></tr></table></figure>\n\n<p>这个时候 samba 的安装配置工作就已经完成了，当然可以保底操作一下,确保一切正常</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt install cifs-utils -y <span class=\"hljs-comment\">## 安装cifs</span><br>sudo apt-get install samba -y <span class=\"hljs-comment\">## 更新samba</span><br>sudo ufw allow samba <span class=\"hljs-comment\">## 防火墙豁免</span><br>/etc/init.d/smbd restart <span class=\"hljs-comment\">## 重启即可</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>win + R 输入\\192.168.1.66\\share 输入实际的主机 ip 可通过 ifconfig 在 linux 机器上查</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">netstat -tunpl | grep smbd<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：如果是服务商接入会屏蔽掉 445 139 端口<br>在配置文件的[global]项中加入一行</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">smb ports = 1314<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>samba 服务器功能<br>1）提供 Windows 风格文件或打印机的共享<br>2）在 Windows 网络中解析 NETBIOS 名字<br>3）提供 smb 客户功能<br>4）提供一个命令行工具，利用该工具限制支持 Windows 的某些管理功能</p>\n","site":{"data":{}},"wordcount":2441,"excerpt":"","more":"<p>在一些中小型网络，或者企业的内部网中，利用 Linux 建立文件服务器是一个很好的解决方案。针对企业内部网中的绝大部分客户机采用 Windows 的情况，我们可以通过使用 Samba 来实现文件服务器功能。<br>Samba 是在 Linux 及 Unix 上实现 SMB（Server Message Block）协议的一个免费软件，由服务器及客户端程序构成。这里我们只介绍服务器程序。<br>我们首先介绍一些 SMB 协议的情况。SMB 协议是建立在 NetBIOS 协议之上的应用协议，是基于 TCP138、139 两个端口的服务。NetBIOS 出现之后，Microsoft 就使用 NetBIOS 实现了一个网络文件/打印服务系统。这个系统基于 NetBIOS 设定了一套文件共享协议，Microsoft 称之为 SMB（Server Message Block）协议。这个协议被用于 Lan Manager 和 Windows 服务器系统中，实现不同计算机之间共享打印机和文件等。因此，为了让 Windows 和 Unix/Linux 计算机相集成，最好的办法就是在 Unix/Linux 计算机中安装支持 SMB 协议的软件。这样使用 Windows 的客户端不需要更改设置，就能像使用 Windows NT 或 Windows 2000 服务器一样，使用 Unix/Linux 计算机上的共享资源了。Samba 使 SMB 协议运行在 NetBIOS 协议上，并且使用 Windows 的 NetBEUI 协议让 Unix/Linux 服务器可以在 Windows 的网络邻居上被访问到。</p>\n<h2 id=\"安装：\"><a href=\"#安装：\" class=\"headerlink\" title=\"安装：\"></a>安装：</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">##（首先更新系统的软件下载源）</span><br>sudo apt-get update<br><span class=\"hljs-comment\">##（可选对ubuntu进行系统升级！）</span><br>sudo apt-get upgrade<br><span class=\"hljs-comment\">## 正式安装</span><br>sudo apt-get install samba<br><span class=\"hljs-comment\">## 安装结束后创建Samba用户，用户名及密码</span><br>sudo smbpasswd -a xxx  <span class=\"hljs-comment\">## xxx为用户名</span><br><span class=\"hljs-comment\">##（输入密码2次：）</span><br>New SMB password:<br>Retype new SMB password:<br><br><span class=\"hljs-comment\">## 备份原配置</span><br>sudo cp /etc/samba/smb.conf /etc/samba/smb.conf.bak<br><span class=\"hljs-comment\">## 编辑配置文件</span><br>sudo gedit /etc/samba/smb.conf<br><span class=\"hljs-comment\">## 如果提示 gedit:1505157): Gtk-WARNING **: 23:46:14.954: cannot open display:可以通过vim进行编辑</span><br>sudo vim /etc/samba/smb.conf<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"配置：\"><a href=\"#配置：\" class=\"headerlink\" title=\"配置：\"></a>配置：</h2><h3 id=\"配置文件常用指令说明\"><a href=\"#配置文件常用指令说明\" class=\"headerlink\" title=\"配置文件常用指令说明:\"></a>配置文件常用指令说明:</h3><p>comment=STRING :注释；<br>path=/PATH/TO/FILENAME :当前共享所映射的文件系统路径；<br>browseable=YES :是否可浏览，指是否可被用户查看；<br>guest ok=YES :是否允许来宾账号访问；<br>browseable = No :是否公开目录<br>writable=YES :是否可写；<br>read only = no|yes :是否为只读<br>write list=/PATH/TO/user_list :拥有写权限的用户列表；</p>\n<p><strong>在文件尾部添加以下内容，根据自己需要修改，并保存文件</strong></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">[share]<br>path = /media/pi  <span class=\"hljs-comment\">## 路径建议提前分配好读写权限 sudo chmod -R 777 /media/pi</span><br>available = yes<br>browsealbe = yes<br>valid usere = pi     <span class=\"hljs-comment\">## 创建的用户名</span><br>writable = yes<br>guest ok = no<br><span class=\"hljs-built_in\">read</span> only = no<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>[share] 是共享文件夹显示的名称</li>\n<li>上面配置了禁止匿名登录，允许用户读写文件</li>\n<li>更多配置方式<a href=\"https://www.samba.org/\">https://www.samba.org/</a></li>\n<li>注意 如果共享的文件夹中包含中文可能会出现乱码，建议在[global]修改字符集为 utf-8</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 原有</span><br>   display charset = cp936<br>   unix charset = cp936<br>   dos  charset = cp936<br><span class=\"hljs-comment\">## 更改为</span><br>   dos charset = UTF-8<br>   unix charset = utf-8<br>   display charset = utf-8<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>如果映射过慢，可采用如下方法, 通过 testparm 检查配置</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\"><span class=\"hljs-comment\">## 在[global]下添加如下配置</span><br>   <span class=\"hljs-built_in\">read</span> raw = Yes<br>   write raw = Yes<br>   socket options = TCP_NODELAY IPTOS_LOWDELAY SO_RCVBUF=131072 SO_SNDBUF=131072<br>   min receivefile size = 16384<br>   use sendfile = <span class=\"hljs-literal\">true</span><br>   aio <span class=\"hljs-built_in\">read</span> size = 16384<br>   aio write size = 16384<br>   max xmit = 65535<br>   max connections = 0<br>   deadtime = 0<br><span class=\"hljs-comment\">## 配置结束</span><br>[printers]<br>   comment = All Printers<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"启动：\"><a href=\"#启动：\" class=\"headerlink\" title=\"启动：\"></a>启动：</h2><p>保存退出:wq</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">/etc/init.d/smbd restart  <span class=\"hljs-comment\">## 重启SMB 使配置生效</span><br></code></pre></td></tr></table></figure>\n\n<p>这个时候 samba 的安装配置工作就已经完成了，当然可以保底操作一下,确保一切正常</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">sudo apt install cifs-utils -y <span class=\"hljs-comment\">## 安装cifs</span><br>sudo apt-get install samba -y <span class=\"hljs-comment\">## 更新samba</span><br>sudo ufw allow samba <span class=\"hljs-comment\">## 防火墙豁免</span><br>/etc/init.d/smbd restart <span class=\"hljs-comment\">## 重启即可</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>win + R 输入\\192.168.1.66\\share 输入实际的主机 ip 可通过 ifconfig 在 linux 机器上查</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">netstat -tunpl | grep smbd<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：如果是服务商接入会屏蔽掉 445 139 端口<br>在配置文件的[global]项中加入一行</li>\n</ul>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">smb ports = 1314<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>samba 服务器功能<br>1）提供 Windows 风格文件或打印机的共享<br>2）在 Windows 网络中解析 NETBIOS 名字<br>3）提供 smb 客户功能<br>4）提供一个命令行工具，利用该工具限制支持 Windows 的某些管理功能</p>\n"},{"title":"没有tts用怎么办","date":"2023-03-05T16:28:23.000Z","_content":"\n####  主要步骤：\n\n第一步：油猴插件下载：https://www.tampermonkey.net/ \n\n第二步：微软tts 下载按钮 https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download\n\n第三步：微软TTS语音引擎文字转语音网址 https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview\n\n#### 重要说明：\n\n1.下载安装油猴插件\n\n[![ppmVJv8.md.png](https://s1.ax1x.com/2023/03/08/ppmVJv8.md.png)](https://imgse.com/i/ppmVJv8)\n\n2.下载油猴插件脚本\n\n[![ppmVtKS.md.png](https://s1.ax1x.com/2023/03/08/ppmVtKS.md.png)](https://imgse.com/i/ppmVtKS)\n\n3.在微软的文字转tts选择自己需要的配置，注意查看自己的脚本是否为开启状态\n\n[![ppmVdEj.md.png](https://s1.ax1x.com/2023/03/08/ppmVdEj.md.png)](https://imgse.com/i/ppmVdEj)\n\n4.注意如果没有开启的状态，自己调整关闭浏览器重新访问启用一下，接下来微软网页翻到最下面，可以试听和下载\n\n[![ppmVr80.md.png](https://s1.ax1x.com/2023/03/08/ppmVr80.md.png)](https://imgse.com/i/ppmVr80)\n\n5.下载有多种输出频率单主要是MP3，可以用ffmpeg转一下，ffmpeg怎么用可以参考我之前的文章（https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/），当然你也可以自己百度。\n\n#### 为什么不用python给我们写一个脚本：\n\n1.懒\n\n2.写了pyttsx3出来的声音不自然，百度aip使用有限制，数量有限\n\n![Snipaste_2023-03-06_00-58-06.png](http://s5.nsloop.com:17969/images/2023/03/06/Snipaste_2023-03-06_00-58-06.png)\n","source":"_posts/没有tts用怎么办.md","raw":"---\ntitle: 没有tts用怎么办\ndate: 2023-03-06 00:28:23\ntags: 工具\ncategories:\n- 音频处理\n---\n\n####  主要步骤：\n\n第一步：油猴插件下载：https://www.tampermonkey.net/ \n\n第二步：微软tts 下载按钮 https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download\n\n第三步：微软TTS语音引擎文字转语音网址 https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview\n\n#### 重要说明：\n\n1.下载安装油猴插件\n\n[![ppmVJv8.md.png](https://s1.ax1x.com/2023/03/08/ppmVJv8.md.png)](https://imgse.com/i/ppmVJv8)\n\n2.下载油猴插件脚本\n\n[![ppmVtKS.md.png](https://s1.ax1x.com/2023/03/08/ppmVtKS.md.png)](https://imgse.com/i/ppmVtKS)\n\n3.在微软的文字转tts选择自己需要的配置，注意查看自己的脚本是否为开启状态\n\n[![ppmVdEj.md.png](https://s1.ax1x.com/2023/03/08/ppmVdEj.md.png)](https://imgse.com/i/ppmVdEj)\n\n4.注意如果没有开启的状态，自己调整关闭浏览器重新访问启用一下，接下来微软网页翻到最下面，可以试听和下载\n\n[![ppmVr80.md.png](https://s1.ax1x.com/2023/03/08/ppmVr80.md.png)](https://imgse.com/i/ppmVr80)\n\n5.下载有多种输出频率单主要是MP3，可以用ffmpeg转一下，ffmpeg怎么用可以参考我之前的文章（https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/），当然你也可以自己百度。\n\n#### 为什么不用python给我们写一个脚本：\n\n1.懒\n\n2.写了pyttsx3出来的声音不自然，百度aip使用有限制，数量有限\n\n![Snipaste_2023-03-06_00-58-06.png](http://s5.nsloop.com:17969/images/2023/03/06/Snipaste_2023-03-06_00-58-06.png)\n","slug":"没有tts用怎么办","published":1,"updated":"2023-05-03T16:45:53.621Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf6000vb0gi2yie8877","content":"<h4 id=\"主要步骤：\"><a href=\"#主要步骤：\" class=\"headerlink\" title=\"主要步骤：\"></a>主要步骤：</h4><p>第一步：油猴插件下载：<a href=\"https://www.tampermonkey.net/\">https://www.tampermonkey.net/</a> </p>\n<p>第二步：微软tts 下载按钮 <a href=\"https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download\">https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download</a></p>\n<p>第三步：微软TTS语音引擎文字转语音网址 <a href=\"https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview\">https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview</a></p>\n<h4 id=\"重要说明：\"><a href=\"#重要说明：\" class=\"headerlink\" title=\"重要说明：\"></a>重要说明：</h4><p>1.下载安装油猴插件</p>\n<p><a href=\"https://imgse.com/i/ppmVJv8\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVJv8.md.png\" alt=\"ppmVJv8.md.png\"></a></p>\n<p>2.下载油猴插件脚本</p>\n<p><a href=\"https://imgse.com/i/ppmVtKS\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVtKS.md.png\" alt=\"ppmVtKS.md.png\"></a></p>\n<p>3.在微软的文字转tts选择自己需要的配置，注意查看自己的脚本是否为开启状态</p>\n<p><a href=\"https://imgse.com/i/ppmVdEj\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVdEj.md.png\" alt=\"ppmVdEj.md.png\"></a></p>\n<p>4.注意如果没有开启的状态，自己调整关闭浏览器重新访问启用一下，接下来微软网页翻到最下面，可以试听和下载</p>\n<p><a href=\"https://imgse.com/i/ppmVr80\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVr80.md.png\" alt=\"ppmVr80.md.png\"></a></p>\n<p>5.下载有多种输出频率单主要是MP3，可以用ffmpeg转一下，ffmpeg怎么用可以参考我之前的文章（<a href=\"https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%EF%BC%89%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%99%BE%E5%BA%A6%E3%80%82\">https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/），当然你也可以自己百度。</a></p>\n<h4 id=\"为什么不用python给我们写一个脚本：\"><a href=\"#为什么不用python给我们写一个脚本：\" class=\"headerlink\" title=\"为什么不用python给我们写一个脚本：\"></a>为什么不用python给我们写一个脚本：</h4><p>1.懒</p>\n<p>2.写了pyttsx3出来的声音不自然，百度aip使用有限制，数量有限</p>\n<p><img src=\"http://s5.nsloop.com:17969/images/2023/03/06/Snipaste_2023-03-06_00-58-06.png\" alt=\"Snipaste_2023-03-06_00-58-06.png\"></p>\n","site":{"data":{}},"wordcount":547,"excerpt":"","more":"<h4 id=\"主要步骤：\"><a href=\"#主要步骤：\" class=\"headerlink\" title=\"主要步骤：\"></a>主要步骤：</h4><p>第一步：油猴插件下载：<a href=\"https://www.tampermonkey.net/\">https://www.tampermonkey.net/</a> </p>\n<p>第二步：微软tts 下载按钮 <a href=\"https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download\">https://greasyfork.org/zh-CN/scripts/444347-azure-speech-download</a></p>\n<p>第三步：微软TTS语音引擎文字转语音网址 <a href=\"https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview\">https://azure.microsoft.com/en-us/products/cognitive-services/text-to-speech/#overview</a></p>\n<h4 id=\"重要说明：\"><a href=\"#重要说明：\" class=\"headerlink\" title=\"重要说明：\"></a>重要说明：</h4><p>1.下载安装油猴插件</p>\n<p><a href=\"https://imgse.com/i/ppmVJv8\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVJv8.md.png\" alt=\"ppmVJv8.md.png\"></a></p>\n<p>2.下载油猴插件脚本</p>\n<p><a href=\"https://imgse.com/i/ppmVtKS\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVtKS.md.png\" alt=\"ppmVtKS.md.png\"></a></p>\n<p>3.在微软的文字转tts选择自己需要的配置，注意查看自己的脚本是否为开启状态</p>\n<p><a href=\"https://imgse.com/i/ppmVdEj\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVdEj.md.png\" alt=\"ppmVdEj.md.png\"></a></p>\n<p>4.注意如果没有开启的状态，自己调整关闭浏览器重新访问启用一下，接下来微软网页翻到最下面，可以试听和下载</p>\n<p><a href=\"https://imgse.com/i/ppmVr80\"><img src=\"https://s1.ax1x.com/2023/03/08/ppmVr80.md.png\" alt=\"ppmVr80.md.png\"></a></p>\n<p>5.下载有多种输出频率单主要是MP3，可以用ffmpeg转一下，ffmpeg怎么用可以参考我之前的文章（<a href=\"https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/%EF%BC%89%EF%BC%8C%E5%BD%93%E7%84%B6%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5%E8%87%AA%E5%B7%B1%E7%99%BE%E5%BA%A6%E3%80%82\">https://stonelst.gitee.io/2021/12/04/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/），当然你也可以自己百度。</a></p>\n<h4 id=\"为什么不用python给我们写一个脚本：\"><a href=\"#为什么不用python给我们写一个脚本：\" class=\"headerlink\" title=\"为什么不用python给我们写一个脚本：\"></a>为什么不用python给我们写一个脚本：</h4><p>1.懒</p>\n<p>2.写了pyttsx3出来的声音不自然，百度aip使用有限制，数量有限</p>\n<p><img src=\"http://s5.nsloop.com:17969/images/2023/03/06/Snipaste_2023-03-06_00-58-06.png\" alt=\"Snipaste_2023-03-06_00-58-06.png\"></p>\n"},{"title":"越来越卷之java学习","date":"2021-10-28T06:59:33.000Z","_content":"\n安装JDK  javac 编辑命令 java执行命令\n\n[![5H90f0.png](https://z3.ax1x.com/2021/10/27/5H90f0.png)](https://imgtu.com/i/5H90f0)\n\n```java\npublic class HelloWorld { //类名必须与文件名一致\n\tpublic static void main(String[] args){  // 架子\n\t\tSystem.out.printLn(\"HelloWorld\");\n\t}\n}\n```\n\n[![5HAElt.png](https://z3.ax1x.com/2021/10/27/5HAElt.png)](https://imgtu.com/i/5HAElt)\n\n[![5HKv6J.png](https://z3.ax1x.com/2021/10/27/5HKv6J.png)](https://imgtu.com/i/5HKv6J)\n\n[![5H85XF.png](https://z3.ax1x.com/2021/10/27/5H85XF.png)](https://imgtu.com/i/5H85XF)\n\n项目创建过程\n\n[![5HtiN9.png](https://z3.ax1x.com/2021/10/27/5HtiN9.png)](https://imgtu.com/i/5HtiN9)\n\n[![5Ht83t.png](https://z3.ax1x.com/2021/10/27/5Ht83t.png)](https://imgtu.com/i/5Ht83t)\n\n[![5HtyvV.png](https://z3.ax1x.com/2021/10/27/5HtyvV.png)](https://imgtu.com/i/5HtyvV)\n\n[![5Ht2bF.png](https://z3.ax1x.com/2021/10/27/5Ht2bF.png)](https://imgtu.com/i/5Ht2bF)\n\n模型--->包--->类\n\n修改名称\n\n[![5bsnc4.png](https://z3.ax1x.com/2021/10/28/5bsnc4.png)](https://imgtu.com/i/5bsnc4)\n\n删除项目删不干净要进到项目中去删除，.idea中的配置删掉，再重新启动idea\n\n[![5bsH8U.png](https://z3.ax1x.com/2021/10/28/5bsH8U.png)](https://imgtu.com/i/5bsH8U)\n","source":"_posts/越来越卷之java学习.md","raw":"---\ntitle: 越来越卷之java学习\ndate: 2021-10-28 14:59:33\ntags: Java\ncategories:\n- Java\n\n---\n\n安装JDK  javac 编辑命令 java执行命令\n\n[![5H90f0.png](https://z3.ax1x.com/2021/10/27/5H90f0.png)](https://imgtu.com/i/5H90f0)\n\n```java\npublic class HelloWorld { //类名必须与文件名一致\n\tpublic static void main(String[] args){  // 架子\n\t\tSystem.out.printLn(\"HelloWorld\");\n\t}\n}\n```\n\n[![5HAElt.png](https://z3.ax1x.com/2021/10/27/5HAElt.png)](https://imgtu.com/i/5HAElt)\n\n[![5HKv6J.png](https://z3.ax1x.com/2021/10/27/5HKv6J.png)](https://imgtu.com/i/5HKv6J)\n\n[![5H85XF.png](https://z3.ax1x.com/2021/10/27/5H85XF.png)](https://imgtu.com/i/5H85XF)\n\n项目创建过程\n\n[![5HtiN9.png](https://z3.ax1x.com/2021/10/27/5HtiN9.png)](https://imgtu.com/i/5HtiN9)\n\n[![5Ht83t.png](https://z3.ax1x.com/2021/10/27/5Ht83t.png)](https://imgtu.com/i/5Ht83t)\n\n[![5HtyvV.png](https://z3.ax1x.com/2021/10/27/5HtyvV.png)](https://imgtu.com/i/5HtyvV)\n\n[![5Ht2bF.png](https://z3.ax1x.com/2021/10/27/5Ht2bF.png)](https://imgtu.com/i/5Ht2bF)\n\n模型--->包--->类\n\n修改名称\n\n[![5bsnc4.png](https://z3.ax1x.com/2021/10/28/5bsnc4.png)](https://imgtu.com/i/5bsnc4)\n\n删除项目删不干净要进到项目中去删除，.idea中的配置删掉，再重新启动idea\n\n[![5bsH8U.png](https://z3.ax1x.com/2021/10/28/5bsH8U.png)](https://imgtu.com/i/5bsH8U)\n","slug":"越来越卷之java学习","published":1,"updated":"2022-11-20T05:15:37.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvf7000zb0gi3sohhimr","content":"<p>安装JDK  javac 编辑命令 java执行命令</p>\n<p><a href=\"https://imgtu.com/i/5H90f0\"><img src=\"https://z3.ax1x.com/2021/10/27/5H90f0.png\" alt=\"5H90f0.png\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloWorld</span> </span>&#123; <span class=\"hljs-comment\">//类名必须与文件名一致</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;  <span class=\"hljs-comment\">// 架子</span><br>\t\tSystem.out.printLn(<span class=\"hljs-string\">&quot;HelloWorld&quot;</span>);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://imgtu.com/i/5HAElt\"><img src=\"https://z3.ax1x.com/2021/10/27/5HAElt.png\" alt=\"5HAElt.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5HKv6J\"><img src=\"https://z3.ax1x.com/2021/10/27/5HKv6J.png\" alt=\"5HKv6J.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5H85XF\"><img src=\"https://z3.ax1x.com/2021/10/27/5H85XF.png\" alt=\"5H85XF.png\"></a></p>\n<p>项目创建过程</p>\n<p><a href=\"https://imgtu.com/i/5HtiN9\"><img src=\"https://z3.ax1x.com/2021/10/27/5HtiN9.png\" alt=\"5HtiN9.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5Ht83t\"><img src=\"https://z3.ax1x.com/2021/10/27/5Ht83t.png\" alt=\"5Ht83t.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5HtyvV\"><img src=\"https://z3.ax1x.com/2021/10/27/5HtyvV.png\" alt=\"5HtyvV.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5Ht2bF\"><img src=\"https://z3.ax1x.com/2021/10/27/5Ht2bF.png\" alt=\"5Ht2bF.png\"></a></p>\n<p>模型—&gt;包—&gt;类</p>\n<p>修改名称</p>\n<p><a href=\"https://imgtu.com/i/5bsnc4\"><img src=\"https://z3.ax1x.com/2021/10/28/5bsnc4.png\" alt=\"5bsnc4.png\"></a></p>\n<p>删除项目删不干净要进到项目中去删除，.idea中的配置删掉，再重新启动idea</p>\n<p><a href=\"https://imgtu.com/i/5bsH8U\"><img src=\"https://z3.ax1x.com/2021/10/28/5bsH8U.png\" alt=\"5bsH8U.png\"></a></p>\n","site":{"data":{}},"wordcount":228,"excerpt":"","more":"<p>安装JDK  javac 编辑命令 java执行命令</p>\n<p><a href=\"https://imgtu.com/i/5H90f0\"><img src=\"https://z3.ax1x.com/2021/10/27/5H90f0.png\" alt=\"5H90f0.png\"></a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloWorld</span> </span>&#123; <span class=\"hljs-comment\">//类名必须与文件名一致</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(String[] args)</span></span>&#123;  <span class=\"hljs-comment\">// 架子</span><br>\t\tSystem.out.printLn(<span class=\"hljs-string\">&quot;HelloWorld&quot;</span>);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><a href=\"https://imgtu.com/i/5HAElt\"><img src=\"https://z3.ax1x.com/2021/10/27/5HAElt.png\" alt=\"5HAElt.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5HKv6J\"><img src=\"https://z3.ax1x.com/2021/10/27/5HKv6J.png\" alt=\"5HKv6J.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5H85XF\"><img src=\"https://z3.ax1x.com/2021/10/27/5H85XF.png\" alt=\"5H85XF.png\"></a></p>\n<p>项目创建过程</p>\n<p><a href=\"https://imgtu.com/i/5HtiN9\"><img src=\"https://z3.ax1x.com/2021/10/27/5HtiN9.png\" alt=\"5HtiN9.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5Ht83t\"><img src=\"https://z3.ax1x.com/2021/10/27/5Ht83t.png\" alt=\"5Ht83t.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5HtyvV\"><img src=\"https://z3.ax1x.com/2021/10/27/5HtyvV.png\" alt=\"5HtyvV.png\"></a></p>\n<p><a href=\"https://imgtu.com/i/5Ht2bF\"><img src=\"https://z3.ax1x.com/2021/10/27/5Ht2bF.png\" alt=\"5Ht2bF.png\"></a></p>\n<p>模型—&gt;包—&gt;类</p>\n<p>修改名称</p>\n<p><a href=\"https://imgtu.com/i/5bsnc4\"><img src=\"https://z3.ax1x.com/2021/10/28/5bsnc4.png\" alt=\"5bsnc4.png\"></a></p>\n<p>删除项目删不干净要进到项目中去删除，.idea中的配置删掉，再重新启动idea</p>\n<p><a href=\"https://imgtu.com/i/5bsH8U\"><img src=\"https://z3.ax1x.com/2021/10/28/5bsH8U.png\" alt=\"5bsH8U.png\"></a></p>\n"},{"title":"大前端知识复习","date":"2021-09-30T06:07:42.000Z","_content":"\n# 一，24个JavaScript循环遍历方式\n\n![](https://www.hualigs.cn/image/61556646d8326.jpg)\n\n## 1.1数组遍历\n\n### 1. forEach()\n\n`forEach` 方法用于调用数组的每个元素，并将元素传递给回调函数。数组中的每个值都会调用回调函数。其语法如下：\n\n```js\narray.forEach(function(currentValue, index, arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必需。当前元素\n- index：可选。当前元素的索引值。\n- arr：可选。当前元素所属的数组对象\n\n```js\nlet arr = [1,2,3,4,5]\narr.forEach((item, index, arr) => {\n  console.log(index+\":\"+item)\n})\n```\n\n该方法还可以有第二个参数，用来绑定回调函数内部this变量（前提是回调函数不能是箭头函数，因为箭头函数没有this）：\n\n```js\nlet arr = [1,2,3,4,5]\nlet arr1 = [9,8,7,6,5]\narr.forEach(function(item, index, arr){\n  console.log(this[index])  //  9 8 7 6 5\n}, arr1)\n```\n\n注意：\n\n- forEach 方法不会改变原数组，也没有返回值；\n- forEach无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致；\n- forEach 方法无法遍历对象，仅适用于数组的遍历。\n\n### 2. map()\n\n`map()` 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。其语法如下：\n\n```js\narray.map(function(currentValue,index,arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nlet arr = [1, 2, 3];\n \narr.map(item => {\n    return item + 1;\n})\n\n// 输出结果： [2, 3, 4]\n```\n\n该方法的第二个参数用来绑定参数函数内部的this变量，是可选的：\n\n```js\nlet arr = ['a', 'b', 'c'];\n \n[1, 2].map(function (e) {\n    return this[e];\n}, arr)\n\n// 输出结果： ['b', 'c']\n```\n\n该方法还可以进行链式调用：\n\n```js\nlet arr = [1, 2, 3];\n \narr.map(item => item + 1).map(item => item + 1)\n\n// 输出结果： [3, 4, 5]\n```\n\n注意：\n\n- map 方法不会对空数组进行检测；\n- map 方法遍历数组时会返回一个新数组，**不会改变原始数组**；\n- map 方法有返回值，可以return出来，map的回调函数中支持return返回值；\n- map 方法无法遍历对象，仅适用于数组的遍历。\n\n### 3. for of\n\n`for...of` 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 `for...of` 循环，以替代 `for...in` 和 `forEach()` ，并支持新的迭代协议。其语法如下：\n\n```js\nfor (variable of iterable) {\n    statement\n}\n```\n\n该方法有两个参数：\n\n- variable：每个迭代的属性值被分配给该变量。\n- iterable：一个具有可枚举属性并且可以迭代的对象。\n\n该方法可以获取数组的每一项：\n\n```js\nlet arr = [\n    {id:1, value:'hello'},\n    {id:2, value:'world'},\n    {id:3, value:'JavaScript'}\n]\nfor (let item of arr) {\n  console.log(item); \n}\n// 输出结果：{id:1, value:'hello'}  {id:2, value:'world'} {id:3, value:'JavaScript'}\n```\n\n注意：\n\n- for of 方法只会遍历当前对象的属性，不会遍历其原型链上的属性；\n- for of 方法适用遍历 **数组/ 类数组/字符串/map/set** 等拥有迭代器对象的集合；\n- for of 方法不支持遍历普通对象，因为其没有迭代器对象。如果想要遍历一个对象的属性，可以用 for in 方法；\n- 可以使用break、continue、return来中断循环遍历；\n\n### 4. filter()\n\n`filter()`方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回，如果没有符合条件的元素，则返回空数组。其语法如下：\n\n```js\narray.filter(function(currentValue,index,arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nconst arr = [1, 2, 3, 4, 5]\narr.filter(item => item > 2) \n\n// 输出结果：[3, 4, 5]\n```\n\n同样，它也有第二个参数，用来绑定参数函数内部的this变量。\n\n可以使用`filter()`方法来移除数组中的undefined、null、NAN等值：\n\n```js\nlet arr = [1, undefined, 2, null, 3, false, '', 4, 0]\narr.filter(Boolean)\n\n// 输出结果：[1, 2, 3, 4]\n```\n\n注意：\n\n- filter 方法会返回一个新的数组，不会改变原数组；\n- filter 方法不会对空数组进行检测；\n- filter 方法仅适用于检测数组。\n\n### 5. some()、every()\n\nsome() 方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，且剩余的元素不会再进行检测，否则就返回false。\n\nevery() 方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。其语法如下：\n\n两者的语法如下：\n\n```js\narray.some(function(currentValue,index,arr),thisValue)\narray.every(function(currentValue,index,arr), thisValue)\n```\n\n两个方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nlet arr = [1, 2, 3, 4, 5]\narr.some(item => item > 4) \n\n// 输出结果：true\n\nlet arr = [1, 2, 3, 4, 5]\narr.every(item => item > 0) \n\n// 输出结果：true\n```\n\n注意：\n\n- 两个方法都不会改变原数组，会返回一个布尔值；\n- 两个方法都不会对空数组进行检测；\n- 两个方法都仅适用于检测数组。\n\n### 6. reduce()、reduceRight()\n\nreduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。其语法如下：\n\n```js\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n```\n\nreduce 方法会为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，回调函数接受四个参数：\n\n- total：上一次调用回调返回的值，或者是提供的初始值（initialValue）；\n- currentValue：当前被处理的元素；\n- currentIndex：当前元素的索引；\n- arr：当前元素所属的数组对象。\n\n该方法的第二个参数是 `initialValue`，表示传递给函数的初始值 （作为第一次调用 callback 的第一个参数）：\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduce((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n})\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n1 2 1\n3 3 2\n6 4 3\n[1, 2, 3, 4] 10\n```\n\n再来加一个初始值试试：\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduce((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n}, 5)\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n5 1 0\n6 2 1\n8 3 2\n11 4 3\n[1, 2, 3, 4] 15\n```\n\n由此可以得出结论：**如果没有提供初始值initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供了初始值initialValue，从索引0开始执行**\n\nreduceRight() 方法和的`reduce()`用法几乎一致，只是该方法是对数组进行倒序遍历的，而`reduce()`方法是正序遍历的。\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduceRight((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n}, 5)\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n5 4 3\n9 3 2\n12 2 1\n14 1 0\n[1, 2, 3, 4] 15\n```\n\n注意：\n\n- 两个方法都不会改变原数组；\n- 两个方法如果添加初始值，就会改变原数组，会将这个初始值放在数组的最后一位；\n- 两个方法对于空数组是不会执行回调函数的。\n\n### 7. find()、findIndex()\n\n`find()` 方法返回通过函数内判断的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时， `find()` 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。\n\n`findIndex()` 方法返回传入一个测试函数符合条件的数组**第一个元素位置**（索引）。当数组中的元素在函数条件时返回 true 时， `findIndex()` 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。\n\n两个方法的语法如下：\n\n```js\narray.find(function(currentValue, index, arr),thisValue)\narray.findIndex(function(currentValue, index, arr), thisValue)\n```\n\n两个方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必需。当前元素；\n- index：可选。当前元素的索引；\n- arr：可选。当前元素所属的数组对象。\n\n```js\nlet arr = [1, 2, 3, 4, 5]\narr.find(item => item > 2) \n\n// 输出结果：3\n\nlet arr = [1, 2, 3, 4, 5]\narr.findIndex(item => item > 2) \n\n// 输出结果：2\n```\n\n`find()`和`findIndex()`两个方法几乎一样，只是返回结果不同：\n\n- `find()`：返回的是第一个符合条件的值；\n- `findIndex`：返回的是第一个返回条件的值的索引值。\n\n注意：\n\n- 两个方法对于空数组，函数是不会执行的；\n- 两个方法否不会改变原数组。\n\n### 8. keys()、values()、entries()\n\n三个方法都返回一个数组的迭代对象，对象的内容不太相同：\n\n- keys() 返回数组的索引值；\n- values() 返回数组的元素；\n- entries() 返回数组的键值对。\n\n三个方法的语法如下：\n\n```js\narray.keys()\narray.values()\narray.entries()\n```\n\n这三个方法都没有参数：\n\n```js\nlet arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nconst iterator1 = arr.keys();\nconst iterator2 = arr.values() \nconst iterator3 = arr.entries() \n\nfor (let item of iterator1) {\n  console.log(item);\n}\n// 输出结果： 0 1 2 3\n\nfor (let item of iterator2) {\n  console.log(item);\n}\n// 输出结果：Banana Orange Apple Mango\n\nfor (let item of iterator3) {\n  console.log(item);\n}\n// 输出结果：[0, 'Banana'] [1, 'Orange'] [2, 'Apple'] [3, 'Mango']\n```\n\n**总结：**\n\n|          **方法**           | **是否改变原数组** |                           **特点**                           |\n| :-------------------------: | :----------------: | :----------------------------------------------------------: |\n|          forEach()          |         否         |                          没有返回值                          |\n|            map()            |         否         |                     有返回值，可链式调用                     |\n|           for of            |         否         | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |\n|          filter()           |         否         |      过滤数组，返回包含符合条件的元素的数组，可链式调用      |\n|       every()、some()       |         否         | some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |\n|     find()、findIndex()     |         否         | find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |\n|   reduce()、reduceRight()   |         否         |     reduce()对数组正序操作；reduceRight()对数组逆序操作      |\n| keys()、values()、entries() |         否         | keys() 返回数组的索引值；values() 返回数组元素；entries() 返回数组的键值对。 |\n\n## 1.2对象遍历方法\n\n### 1. for in\n\n`for…in` 主要用于循环对象属性。循环中的代码每执行一次，就会对对象的属性进行一次操作。其语法如下：\n\n```js\nfor (var in object) {\n 执行的代码块\n}\n```\n\n其中两个参数：\n\n- var：必须。指定的变量可以是数组元素，也可以是对象的属性。\n- object：必须。指定迭代的的对象。\n\n```js\nvar obj = {a: 1, b: 2, c: 3}; \n \nfor (var i in obj) { \n    console.log('键名：', i); \n    console.log('键值：', obj[i]); \n}\n```\n\n输出结果：\n\n```js\n键名：a\n键值： 1\n键名：b\n键值： 2\n键名：c\n键值： 3\n```\n\n注意：\n\n- for in 方法不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。\n\n### 2. Object.keys()、Object.values()、Object.entries()\n\n这三个方法都用来遍历对象，它会返回一个由给定对象的自身可枚举属性（不含继承的和Symbol属性）组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，这个三个元素返回的值分别如下：\n\n- Object.keys()：返回包含对象键名的数组；\n- Object.values()：返回包含对象键值的数组；\n- Object.entries()：返回包含对象键名和键值的数组。\n\n```js\nlet obj = { \n  id: 1, \n  name: 'hello', \n  age: 18 \n};\nconsole.log(Object.keys(obj));   // 输出结果: ['id', 'name', 'age']\nconsole.log(Object.values(obj)); // 输出结果: [1, 'hello', 18]\nconsole.log(Object.entries(obj));   // 输出结果: [['id', 1], ['name', 'hello'], ['age', 18]\n```\n\n注意\n\n- Object.keys()方法返回的数组中的值都是字符串，也就是说不是字符串的key值会转化为字符串。\n- 结果数组中的属性值都是对象本身**可枚举的属性**，不包括继承来的属性。\n\n### 3. Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames()`方法与`Object.keys()`类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回**不可枚举的属性。**\n\n```js\nlet a = ['Hello', 'World'];\n \nObject.keys(a) // [\"0\", \"1\"]\nObject.getOwnPropertyNames(a) // [\"0\", \"1\", \"length\"]\n```\n\n这两个方法都可以用来计算对象中属性的个数：\n\n```js\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\nObject.getOwnPropertyNames(obj) // [\"0\", \"1\", \"2\"]\nObject.keys(obj).length // 3\nObject.getOwnPropertyNames(obj).length // 3\n```\n\n### 4. Object.getOwnPropertySymbols()\n\n`Object.getOwnPropertySymbols()` 方法返回对象自身的 Symbol 属性组成的数组，不包括字符串属性：\n\n```js\nlet obj = {a: 1}\n\n// 给对象添加一个不可枚举的 Symbol 属性\nObject.defineProperties(obj, {\n [Symbol('baz')]: {\n  value: 'Symbol baz',\n  enumerable: false\n }\n})\n \n// 给对象添加一个可枚举的 Symbol 属性\nobj[Symbol('foo')] = 'Symbol foo'\n \nObject.getOwnPropertySymbols(obj).forEach((key) => {\n console.log(obj[key]) \n})\n\n// 输出结果：Symbol baz Symbol foo\n```\n\n### 5. Reflect.ownKeys()\n\nReflect.ownKeys() 返回一个数组，包含对象自身的所有属性。它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：\n\n```js\nvar obj = {\n a: 1,\n b: 2\n}\nObject.defineProperty(obj, 'method', {\n value: function () {\n     alert(\"Non enumerable property\")\n },\n enumerable: false\n})\n\nconsole.log(Object.keys(obj))\n// [\"a\", \"b\"]\nconsole.log(Reflect.ownKeys(obj))\n// [\"a\", \"b\", \"method\"]\n```\n\n注意：\n\n- Object.keys() ：相当于返回对象属性数组；\n\n- Reflect.ownKeys() :相当于\n\n  `Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)`。\n\n**总结：**\n\n|          **对象方法**          | **遍历基本属性** | **遍历原型链** | **遍历不可枚举属性** | **遍历Symbol** |\n| :----------------------------: | :--------------: | :------------: | :------------------: | :------------: |\n|             for in             |        是        |       是       |          否          |       否       |\n|         Object.keys()          |        是        |       否       |          否          |       否       |\n|  Object.getOwnPropertyNames()  |        是        |       否       |          是          |       否       |\n| Object.getOwnPropertySymbols() |        否        |       否       |          是          |       是       |\n|       Reflect.ownKeys()        |        是        |       否       |          是          |       是       |\n\n## 1.3其他遍历方式\n\n### 1. for\n\nfor循环是应该是最常见的循环方式了，它由三个表达式组成，分别是声明循环变量、判断循环条件、更新循环变量。这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。\n\n```js\nconst arr = [1,2,3,4,5]\nfor(let i = 0, len = arr.length; i < len; i++ ){\n  console.log(arr[i])\n}\n```\n\n在执行的时候，会先判断执行条件，再执行。for循环可以用来遍历数组，字符串，类数组，DOM节点等。可以改变原数组。\n\n### 2. while\n\n`while`循环中的结束条件可以是各种类型，但是最终都会转为布尔值，转换规则如下。\n\n- Boolean：true为真，false为假；\n- String：空字符串为假，所有非空字符串为真；\n- Number：0为假，非0数字为真；\n- null/Undefined/NaN：全为假；\n- Object：全为真。\n\n```js\nlet num = 1;\n            \nwhile (num < 10){\n    console.log(num);\n    num ++;\n}\n```\n\n`while`和`for`一样，都是先判断，再执行。只要指定条件为 true，循环就可以一直执行代码。\n\n### 3. do / while\n\n该方法会先执行再判断，即使初始条件不成立，`do/while`循环也至少会执行一次。\n\n```js\nlet num = 10;\n            \ndo\n {\n    console.log(num);\n    num--;\n  }\nwhile(num >= 0);\n            \nconsole.log(num); //-1\n```\n\n不建议使用do / while来遍历数组。\n\n### 4. for await of\n\n`for await...of`方法被称为**异步迭代器**，该方法是主要用来遍历异步对象。它是ES2018中引入的方法。\n\n`for await...of` 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，类数组，Map， Set和自定义的异步或者同步可迭代对象。这个语句只能在 `async function`内使用：\n\n```js\nfunction Gen (time) {\n  return new Promise((resolve,reject) => {\n    setTimeout(function () {\n       resolve(time)\n    },time)\n  })\n}\n\nasync function test () {\n   let arr = [Gen(2000),Gen(100),Gen(3000)]\n   for await (let item of arr) {\n      console.log(Date.now(),item)\n   }\n}\ntest()\n```\n\n![](https://www.hualigs.cn/image/61556b1601dd4.jpg)\n","source":"_posts/大前端基础复习.md","raw":"---\ntitle: 大前端知识复习\ndate: 2021-09-30 14:07:42\ntags: js\ncategories:\n- 知识复习\n---\n\n# 一，24个JavaScript循环遍历方式\n\n![](https://www.hualigs.cn/image/61556646d8326.jpg)\n\n## 1.1数组遍历\n\n### 1. forEach()\n\n`forEach` 方法用于调用数组的每个元素，并将元素传递给回调函数。数组中的每个值都会调用回调函数。其语法如下：\n\n```js\narray.forEach(function(currentValue, index, arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必需。当前元素\n- index：可选。当前元素的索引值。\n- arr：可选。当前元素所属的数组对象\n\n```js\nlet arr = [1,2,3,4,5]\narr.forEach((item, index, arr) => {\n  console.log(index+\":\"+item)\n})\n```\n\n该方法还可以有第二个参数，用来绑定回调函数内部this变量（前提是回调函数不能是箭头函数，因为箭头函数没有this）：\n\n```js\nlet arr = [1,2,3,4,5]\nlet arr1 = [9,8,7,6,5]\narr.forEach(function(item, index, arr){\n  console.log(this[index])  //  9 8 7 6 5\n}, arr1)\n```\n\n注意：\n\n- forEach 方法不会改变原数组，也没有返回值；\n- forEach无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致；\n- forEach 方法无法遍历对象，仅适用于数组的遍历。\n\n### 2. map()\n\n`map()` 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。其语法如下：\n\n```js\narray.map(function(currentValue,index,arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nlet arr = [1, 2, 3];\n \narr.map(item => {\n    return item + 1;\n})\n\n// 输出结果： [2, 3, 4]\n```\n\n该方法的第二个参数用来绑定参数函数内部的this变量，是可选的：\n\n```js\nlet arr = ['a', 'b', 'c'];\n \n[1, 2].map(function (e) {\n    return this[e];\n}, arr)\n\n// 输出结果： ['b', 'c']\n```\n\n该方法还可以进行链式调用：\n\n```js\nlet arr = [1, 2, 3];\n \narr.map(item => item + 1).map(item => item + 1)\n\n// 输出结果： [3, 4, 5]\n```\n\n注意：\n\n- map 方法不会对空数组进行检测；\n- map 方法遍历数组时会返回一个新数组，**不会改变原始数组**；\n- map 方法有返回值，可以return出来，map的回调函数中支持return返回值；\n- map 方法无法遍历对象，仅适用于数组的遍历。\n\n### 3. for of\n\n`for...of` 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 `for...of` 循环，以替代 `for...in` 和 `forEach()` ，并支持新的迭代协议。其语法如下：\n\n```js\nfor (variable of iterable) {\n    statement\n}\n```\n\n该方法有两个参数：\n\n- variable：每个迭代的属性值被分配给该变量。\n- iterable：一个具有可枚举属性并且可以迭代的对象。\n\n该方法可以获取数组的每一项：\n\n```js\nlet arr = [\n    {id:1, value:'hello'},\n    {id:2, value:'world'},\n    {id:3, value:'JavaScript'}\n]\nfor (let item of arr) {\n  console.log(item); \n}\n// 输出结果：{id:1, value:'hello'}  {id:2, value:'world'} {id:3, value:'JavaScript'}\n```\n\n注意：\n\n- for of 方法只会遍历当前对象的属性，不会遍历其原型链上的属性；\n- for of 方法适用遍历 **数组/ 类数组/字符串/map/set** 等拥有迭代器对象的集合；\n- for of 方法不支持遍历普通对象，因为其没有迭代器对象。如果想要遍历一个对象的属性，可以用 for in 方法；\n- 可以使用break、continue、return来中断循环遍历；\n\n### 4. filter()\n\n`filter()`方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回，如果没有符合条件的元素，则返回空数组。其语法如下：\n\n```js\narray.filter(function(currentValue,index,arr), thisValue)\n```\n\n该方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nconst arr = [1, 2, 3, 4, 5]\narr.filter(item => item > 2) \n\n// 输出结果：[3, 4, 5]\n```\n\n同样，它也有第二个参数，用来绑定参数函数内部的this变量。\n\n可以使用`filter()`方法来移除数组中的undefined、null、NAN等值：\n\n```js\nlet arr = [1, undefined, 2, null, 3, false, '', 4, 0]\narr.filter(Boolean)\n\n// 输出结果：[1, 2, 3, 4]\n```\n\n注意：\n\n- filter 方法会返回一个新的数组，不会改变原数组；\n- filter 方法不会对空数组进行检测；\n- filter 方法仅适用于检测数组。\n\n### 5. some()、every()\n\nsome() 方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，且剩余的元素不会再进行检测，否则就返回false。\n\nevery() 方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。其语法如下：\n\n两者的语法如下：\n\n```js\narray.some(function(currentValue,index,arr),thisValue)\narray.every(function(currentValue,index,arr), thisValue)\n```\n\n两个方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必须。当前元素的值；\n- index：可选。当前元素的索引值；\n- arr：可选。当前元素属于的数组对象。\n\n```js\nlet arr = [1, 2, 3, 4, 5]\narr.some(item => item > 4) \n\n// 输出结果：true\n\nlet arr = [1, 2, 3, 4, 5]\narr.every(item => item > 0) \n\n// 输出结果：true\n```\n\n注意：\n\n- 两个方法都不会改变原数组，会返回一个布尔值；\n- 两个方法都不会对空数组进行检测；\n- 两个方法都仅适用于检测数组。\n\n### 6. reduce()、reduceRight()\n\nreduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。其语法如下：\n\n```js\narray.reduce(function(total, currentValue, currentIndex, arr), initialValue)\n```\n\nreduce 方法会为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，回调函数接受四个参数：\n\n- total：上一次调用回调返回的值，或者是提供的初始值（initialValue）；\n- currentValue：当前被处理的元素；\n- currentIndex：当前元素的索引；\n- arr：当前元素所属的数组对象。\n\n该方法的第二个参数是 `initialValue`，表示传递给函数的初始值 （作为第一次调用 callback 的第一个参数）：\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduce((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n})\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n1 2 1\n3 3 2\n6 4 3\n[1, 2, 3, 4] 10\n```\n\n再来加一个初始值试试：\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduce((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n}, 5)\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n5 1 0\n6 2 1\n8 3 2\n11 4 3\n[1, 2, 3, 4] 15\n```\n\n由此可以得出结论：**如果没有提供初始值initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供了初始值initialValue，从索引0开始执行**\n\nreduceRight() 方法和的`reduce()`用法几乎一致，只是该方法是对数组进行倒序遍历的，而`reduce()`方法是正序遍历的。\n\n```js\nlet arr = [1, 2, 3, 4]\nlet sum = arr.reduceRight((prev, cur, index, arr) => {\n    console.log(prev, cur, index);\n    return prev + cur;\n}, 5)\nconsole.log(arr, sum);\n```\n\n输出结果：\n\n```js\n5 4 3\n9 3 2\n12 2 1\n14 1 0\n[1, 2, 3, 4] 15\n```\n\n注意：\n\n- 两个方法都不会改变原数组；\n- 两个方法如果添加初始值，就会改变原数组，会将这个初始值放在数组的最后一位；\n- 两个方法对于空数组是不会执行回调函数的。\n\n### 7. find()、findIndex()\n\n`find()` 方法返回通过函数内判断的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时， `find()` 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。\n\n`findIndex()` 方法返回传入一个测试函数符合条件的数组**第一个元素位置**（索引）。当数组中的元素在函数条件时返回 true 时， `findIndex()` 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。\n\n两个方法的语法如下：\n\n```js\narray.find(function(currentValue, index, arr),thisValue)\narray.findIndex(function(currentValue, index, arr), thisValue)\n```\n\n两个方法的第一个参数为回调函数，是必传的，它有三个参数：\n\n- currentValue：必需。当前元素；\n- index：可选。当前元素的索引；\n- arr：可选。当前元素所属的数组对象。\n\n```js\nlet arr = [1, 2, 3, 4, 5]\narr.find(item => item > 2) \n\n// 输出结果：3\n\nlet arr = [1, 2, 3, 4, 5]\narr.findIndex(item => item > 2) \n\n// 输出结果：2\n```\n\n`find()`和`findIndex()`两个方法几乎一样，只是返回结果不同：\n\n- `find()`：返回的是第一个符合条件的值；\n- `findIndex`：返回的是第一个返回条件的值的索引值。\n\n注意：\n\n- 两个方法对于空数组，函数是不会执行的；\n- 两个方法否不会改变原数组。\n\n### 8. keys()、values()、entries()\n\n三个方法都返回一个数组的迭代对象，对象的内容不太相同：\n\n- keys() 返回数组的索引值；\n- values() 返回数组的元素；\n- entries() 返回数组的键值对。\n\n三个方法的语法如下：\n\n```js\narray.keys()\narray.values()\narray.entries()\n```\n\n这三个方法都没有参数：\n\n```js\nlet arr = [\"Banana\", \"Orange\", \"Apple\", \"Mango\"];\nconst iterator1 = arr.keys();\nconst iterator2 = arr.values() \nconst iterator3 = arr.entries() \n\nfor (let item of iterator1) {\n  console.log(item);\n}\n// 输出结果： 0 1 2 3\n\nfor (let item of iterator2) {\n  console.log(item);\n}\n// 输出结果：Banana Orange Apple Mango\n\nfor (let item of iterator3) {\n  console.log(item);\n}\n// 输出结果：[0, 'Banana'] [1, 'Orange'] [2, 'Apple'] [3, 'Mango']\n```\n\n**总结：**\n\n|          **方法**           | **是否改变原数组** |                           **特点**                           |\n| :-------------------------: | :----------------: | :----------------------------------------------------------: |\n|          forEach()          |         否         |                          没有返回值                          |\n|            map()            |         否         |                     有返回值，可链式调用                     |\n|           for of            |         否         | for...of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环 |\n|          filter()           |         否         |      过滤数组，返回包含符合条件的元素的数组，可链式调用      |\n|       every()、some()       |         否         | some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false. |\n|     find()、findIndex()     |         否         | find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值 |\n|   reduce()、reduceRight()   |         否         |     reduce()对数组正序操作；reduceRight()对数组逆序操作      |\n| keys()、values()、entries() |         否         | keys() 返回数组的索引值；values() 返回数组元素；entries() 返回数组的键值对。 |\n\n## 1.2对象遍历方法\n\n### 1. for in\n\n`for…in` 主要用于循环对象属性。循环中的代码每执行一次，就会对对象的属性进行一次操作。其语法如下：\n\n```js\nfor (var in object) {\n 执行的代码块\n}\n```\n\n其中两个参数：\n\n- var：必须。指定的变量可以是数组元素，也可以是对象的属性。\n- object：必须。指定迭代的的对象。\n\n```js\nvar obj = {a: 1, b: 2, c: 3}; \n \nfor (var i in obj) { \n    console.log('键名：', i); \n    console.log('键值：', obj[i]); \n}\n```\n\n输出结果：\n\n```js\n键名：a\n键值： 1\n键名：b\n键值： 2\n键名：c\n键值： 3\n```\n\n注意：\n\n- for in 方法不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。\n\n### 2. Object.keys()、Object.values()、Object.entries()\n\n这三个方法都用来遍历对象，它会返回一个由给定对象的自身可枚举属性（不含继承的和Symbol属性）组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，这个三个元素返回的值分别如下：\n\n- Object.keys()：返回包含对象键名的数组；\n- Object.values()：返回包含对象键值的数组；\n- Object.entries()：返回包含对象键名和键值的数组。\n\n```js\nlet obj = { \n  id: 1, \n  name: 'hello', \n  age: 18 \n};\nconsole.log(Object.keys(obj));   // 输出结果: ['id', 'name', 'age']\nconsole.log(Object.values(obj)); // 输出结果: [1, 'hello', 18]\nconsole.log(Object.entries(obj));   // 输出结果: [['id', 1], ['name', 'hello'], ['age', 18]\n```\n\n注意\n\n- Object.keys()方法返回的数组中的值都是字符串，也就是说不是字符串的key值会转化为字符串。\n- 结果数组中的属性值都是对象本身**可枚举的属性**，不包括继承来的属性。\n\n### 3. Object.getOwnPropertyNames()\n\n`Object.getOwnPropertyNames()`方法与`Object.keys()`类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回**不可枚举的属性。**\n\n```js\nlet a = ['Hello', 'World'];\n \nObject.keys(a) // [\"0\", \"1\"]\nObject.getOwnPropertyNames(a) // [\"0\", \"1\", \"length\"]\n```\n\n这两个方法都可以用来计算对象中属性的个数：\n\n```js\nvar obj = { 0: \"a\", 1: \"b\", 2: \"c\"};\nObject.getOwnPropertyNames(obj) // [\"0\", \"1\", \"2\"]\nObject.keys(obj).length // 3\nObject.getOwnPropertyNames(obj).length // 3\n```\n\n### 4. Object.getOwnPropertySymbols()\n\n`Object.getOwnPropertySymbols()` 方法返回对象自身的 Symbol 属性组成的数组，不包括字符串属性：\n\n```js\nlet obj = {a: 1}\n\n// 给对象添加一个不可枚举的 Symbol 属性\nObject.defineProperties(obj, {\n [Symbol('baz')]: {\n  value: 'Symbol baz',\n  enumerable: false\n }\n})\n \n// 给对象添加一个可枚举的 Symbol 属性\nobj[Symbol('foo')] = 'Symbol foo'\n \nObject.getOwnPropertySymbols(obj).forEach((key) => {\n console.log(obj[key]) \n})\n\n// 输出结果：Symbol baz Symbol foo\n```\n\n### 5. Reflect.ownKeys()\n\nReflect.ownKeys() 返回一个数组，包含对象自身的所有属性。它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：\n\n```js\nvar obj = {\n a: 1,\n b: 2\n}\nObject.defineProperty(obj, 'method', {\n value: function () {\n     alert(\"Non enumerable property\")\n },\n enumerable: false\n})\n\nconsole.log(Object.keys(obj))\n// [\"a\", \"b\"]\nconsole.log(Reflect.ownKeys(obj))\n// [\"a\", \"b\", \"method\"]\n```\n\n注意：\n\n- Object.keys() ：相当于返回对象属性数组；\n\n- Reflect.ownKeys() :相当于\n\n  `Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)`。\n\n**总结：**\n\n|          **对象方法**          | **遍历基本属性** | **遍历原型链** | **遍历不可枚举属性** | **遍历Symbol** |\n| :----------------------------: | :--------------: | :------------: | :------------------: | :------------: |\n|             for in             |        是        |       是       |          否          |       否       |\n|         Object.keys()          |        是        |       否       |          否          |       否       |\n|  Object.getOwnPropertyNames()  |        是        |       否       |          是          |       否       |\n| Object.getOwnPropertySymbols() |        否        |       否       |          是          |       是       |\n|       Reflect.ownKeys()        |        是        |       否       |          是          |       是       |\n\n## 1.3其他遍历方式\n\n### 1. for\n\nfor循环是应该是最常见的循环方式了，它由三个表达式组成，分别是声明循环变量、判断循环条件、更新循环变量。这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。\n\n```js\nconst arr = [1,2,3,4,5]\nfor(let i = 0, len = arr.length; i < len; i++ ){\n  console.log(arr[i])\n}\n```\n\n在执行的时候，会先判断执行条件，再执行。for循环可以用来遍历数组，字符串，类数组，DOM节点等。可以改变原数组。\n\n### 2. while\n\n`while`循环中的结束条件可以是各种类型，但是最终都会转为布尔值，转换规则如下。\n\n- Boolean：true为真，false为假；\n- String：空字符串为假，所有非空字符串为真；\n- Number：0为假，非0数字为真；\n- null/Undefined/NaN：全为假；\n- Object：全为真。\n\n```js\nlet num = 1;\n            \nwhile (num < 10){\n    console.log(num);\n    num ++;\n}\n```\n\n`while`和`for`一样，都是先判断，再执行。只要指定条件为 true，循环就可以一直执行代码。\n\n### 3. do / while\n\n该方法会先执行再判断，即使初始条件不成立，`do/while`循环也至少会执行一次。\n\n```js\nlet num = 10;\n            \ndo\n {\n    console.log(num);\n    num--;\n  }\nwhile(num >= 0);\n            \nconsole.log(num); //-1\n```\n\n不建议使用do / while来遍历数组。\n\n### 4. for await of\n\n`for await...of`方法被称为**异步迭代器**，该方法是主要用来遍历异步对象。它是ES2018中引入的方法。\n\n`for await...of` 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，类数组，Map， Set和自定义的异步或者同步可迭代对象。这个语句只能在 `async function`内使用：\n\n```js\nfunction Gen (time) {\n  return new Promise((resolve,reject) => {\n    setTimeout(function () {\n       resolve(time)\n    },time)\n  })\n}\n\nasync function test () {\n   let arr = [Gen(2000),Gen(100),Gen(3000)]\n   for await (let item of arr) {\n      console.log(Date.now(),item)\n   }\n}\ntest()\n```\n\n![](https://www.hualigs.cn/image/61556b1601dd4.jpg)\n","slug":"大前端基础复习","published":1,"updated":"2023-05-03T16:46:06.836Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cll9ivvfc001vb0gi103z382u","content":"<h1 id=\"一，24个JavaScript循环遍历方式\"><a href=\"#一，24个JavaScript循环遍历方式\" class=\"headerlink\" title=\"一，24个JavaScript循环遍历方式\"></a>一，24个JavaScript循环遍历方式</h1><p><img src=\"https://www.hualigs.cn/image/61556646d8326.jpg\"></p>\n<h2 id=\"1-1数组遍历\"><a href=\"#1-1数组遍历\" class=\"headerlink\" title=\"1.1数组遍历\"></a>1.1数组遍历</h2><h3 id=\"1-forEach\"><a href=\"#1-forEach\" class=\"headerlink\" title=\"1. forEach()\"></a>1. forEach()</h3><p><code>forEach</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。数组中的每个值都会调用回调函数。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue, index, arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必需。当前元素</li>\n<li>index：可选。当前元素的索引值。</li>\n<li>arr：可选。当前元素所属的数组对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>arr.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(index+<span class=\"hljs-string\">&quot;:&quot;</span>+item)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该方法还可以有第二个参数，用来绑定回调函数内部this变量（前提是回调函数不能是箭头函数，因为箭头函数没有this）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>]<br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item, index, arr</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>[index])  <span class=\"hljs-comment\">//  9 8 7 6 5</span><br>&#125;, arr1)<br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>forEach 方法不会改变原数组，也没有返回值；</li>\n<li>forEach无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致；</li>\n<li>forEach 方法无法遍历对象，仅适用于数组的遍历。</li>\n</ul>\n<h3 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map()\"></a>2. map()</h3><p><code>map()</code> 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br> <br>arr.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;)<br><br><span class=\"hljs-comment\">// 输出结果： [2, 3, 4]</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第二个参数用来绑定参数函数内部的this变量，是可选的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];<br> <br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>[e];<br>&#125;, arr)<br><br><span class=\"hljs-comment\">// 输出结果： [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法还可以进行链式调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br> <br>arr.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>).map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-comment\">// 输出结果： [3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>map 方法不会对空数组进行检测；</li>\n<li>map 方法遍历数组时会返回一个新数组，<strong>不会改变原始数组</strong>；</li>\n<li>map 方法有返回值，可以return出来，map的回调函数中支持return返回值；</li>\n<li>map 方法无法遍历对象，仅适用于数组的遍历。</li>\n</ul>\n<h3 id=\"3-for-of\"><a href=\"#3-for-of\" class=\"headerlink\" title=\"3. for of\"></a>3. for of</h3><p><code>for...of</code> 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 <code>for...of</code> 循环，以替代 <code>for...in</code> 和 <code>forEach()</code> ，并支持新的迭代协议。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (variable <span class=\"hljs-keyword\">of</span> iterable) &#123;<br>    statement<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该方法有两个参数：</p>\n<ul>\n<li>variable：每个迭代的属性值被分配给该变量。</li>\n<li>iterable：一个具有可枚举属性并且可以迭代的对象。</li>\n</ul>\n<p>该方法可以获取数组的每一项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;hello&#x27;</span>&#125;,<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;,<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;JavaScript&#x27;</span>&#125;<br>]<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> arr) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item); <br>&#125;<br><span class=\"hljs-comment\">// 输出结果：&#123;id:1, value:&#x27;hello&#x27;&#125;  &#123;id:2, value:&#x27;world&#x27;&#125; &#123;id:3, value:&#x27;JavaScript&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>for of 方法只会遍历当前对象的属性，不会遍历其原型链上的属性；</li>\n<li>for of 方法适用遍历 <strong>数组/ 类数组/字符串/map/set</strong> 等拥有迭代器对象的集合；</li>\n<li>for of 方法不支持遍历普通对象，因为其没有迭代器对象。如果想要遍历一个对象的属性，可以用 for in 方法；</li>\n<li>可以使用break、continue、return来中断循环遍历；</li>\n</ul>\n<h3 id=\"4-filter\"><a href=\"#4-filter\" class=\"headerlink\" title=\"4. filter()\"></a>4. filter()</h3><p><code>filter()</code>方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回，如果没有符合条件的元素，则返回空数组。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：[3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<p>同样，它也有第二个参数，用来绑定参数函数内部的this变量。</p>\n<p>可以使用<code>filter()</code>方法来移除数组中的undefined、null、NAN等值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>]<br>arr.filter(<span class=\"hljs-built_in\">Boolean</span>)<br><br><span class=\"hljs-comment\">// 输出结果：[1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>filter 方法会返回一个新的数组，不会改变原数组；</li>\n<li>filter 方法不会对空数组进行检测；</li>\n<li>filter 方法仅适用于检测数组。</li>\n</ul>\n<h3 id=\"5-some-、every\"><a href=\"#5-some-、every\" class=\"headerlink\" title=\"5. some()、every()\"></a>5. some()、every()</h3><p>some() 方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，且剩余的元素不会再进行检测，否则就返回false。</p>\n<p>every() 方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。其语法如下：</p>\n<p>两者的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.some(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>),<span class=\"hljs-title\">thisValue</span>)</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">array</span>.<span class=\"hljs-title\">every</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">function</span>(currentValue,index,arr), thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>两个方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.some(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">4</span>) <br><br><span class=\"hljs-comment\">// 输出结果：true</span><br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.every(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">0</span>) <br><br><span class=\"hljs-comment\">// 输出结果：true</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>两个方法都不会改变原数组，会返回一个布尔值；</li>\n<li>两个方法都不会对空数组进行检测；</li>\n<li>两个方法都仅适用于检测数组。</li>\n</ul>\n<h3 id=\"6-reduce-、reduceRight\"><a href=\"#6-reduce-、reduceRight\" class=\"headerlink\" title=\"6. reduce()、reduceRight()\"></a>6. reduce()、reduceRight()</h3><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">total, currentValue, currentIndex, arr</span>), <span class=\"hljs-title\">initialValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>reduce 方法会为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，回调函数接受四个参数：</p>\n<ul>\n<li>total：上一次调用回调返回的值，或者是提供的初始值（initialValue）；</li>\n<li>currentValue：当前被处理的元素；</li>\n<li>currentIndex：当前元素的索引；</li>\n<li>arr：当前元素所属的数组对象。</li>\n</ul>\n<p>该方法的第二个参数是 <code>initialValue</code>，表示传递给函数的初始值 （作为第一次调用 callback 的第一个参数）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n\n<p>再来加一个初始值试试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;, <span class=\"hljs-number\">5</span>)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">8</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">15</span><br></code></pre></td></tr></table></figure>\n\n<p>由此可以得出结论：<strong>如果没有提供初始值initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供了初始值initialValue，从索引0开始执行</strong></p>\n<p>reduceRight() 方法和的<code>reduce()</code>用法几乎一致，只是该方法是对数组进行倒序遍历的，而<code>reduce()</code>方法是正序遍历的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduceRight(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;, <span class=\"hljs-number\">5</span>)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">9</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">12</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">14</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">15</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>两个方法都不会改变原数组；</li>\n<li>两个方法如果添加初始值，就会改变原数组，会将这个初始值放在数组的最后一位；</li>\n<li>两个方法对于空数组是不会执行回调函数的。</li>\n</ul>\n<h3 id=\"7-find-、findIndex\"><a href=\"#7-find-、findIndex\" class=\"headerlink\" title=\"7. find()、findIndex()\"></a>7. find()、findIndex()</h3><p><code>find()</code> 方法返回通过函数内判断的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时， <code>find()</code> 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p>\n<p><code>findIndex()</code> 方法返回传入一个测试函数符合条件的数组<strong>第一个元素位置</strong>（索引）。当数组中的元素在函数条件时返回 true 时， <code>findIndex()</code> 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。</p>\n<p>两个方法的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.find(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue, index, arr</span>),<span class=\"hljs-title\">thisValue</span>)</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">array</span>.<span class=\"hljs-title\">findIndex</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">function</span>(currentValue, index, arr), thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>两个方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必需。当前元素；</li>\n<li>index：可选。当前元素的索引；</li>\n<li>arr：可选。当前元素所属的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.find(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：3</span><br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.findIndex(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：2</span><br></code></pre></td></tr></table></figure>\n\n<p><code>find()</code>和<code>findIndex()</code>两个方法几乎一样，只是返回结果不同：</p>\n<ul>\n<li><code>find()</code>：返回的是第一个符合条件的值；</li>\n<li><code>findIndex</code>：返回的是第一个返回条件的值的索引值。</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>两个方法对于空数组，函数是不会执行的；</li>\n<li>两个方法否不会改变原数组。</li>\n</ul>\n<h3 id=\"8-keys-、values-、entries\"><a href=\"#8-keys-、values-、entries\" class=\"headerlink\" title=\"8. keys()、values()、entries()\"></a>8. keys()、values()、entries()</h3><p>三个方法都返回一个数组的迭代对象，对象的内容不太相同：</p>\n<ul>\n<li>keys() 返回数组的索引值；</li>\n<li>values() 返回数组的元素；</li>\n<li>entries() 返回数组的键值对。</li>\n</ul>\n<p>三个方法的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.keys()<br>array.values()<br>array.entries()<br></code></pre></td></tr></table></figure>\n\n<p>这三个方法都没有参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Orange&quot;</span>, <span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Mango&quot;</span>];<br><span class=\"hljs-keyword\">const</span> iterator1 = arr.keys();<br><span class=\"hljs-keyword\">const</span> iterator2 = arr.values() <br><span class=\"hljs-keyword\">const</span> iterator3 = arr.entries() <br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator1) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果： 0 1 2 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator2) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果：Banana Orange Apple Mango</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator3) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果：[0, &#x27;Banana&#x27;] [1, &#x27;Orange&#x27;] [2, &#x27;Apple&#x27;] [3, &#x27;Mango&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>方法</strong></th>\n<th align=\"center\"><strong>是否改变原数组</strong></th>\n<th align=\"center\"><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">forEach()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">没有返回值</td>\n</tr>\n<tr>\n<td align=\"center\">map()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">有返回值，可链式调用</td>\n</tr>\n<tr>\n<td align=\"center\">for of</td>\n<td align=\"center\">否</td>\n<td align=\"center\">for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>\n</tr>\n<tr>\n<td align=\"center\">filter()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">过滤数组，返回包含符合条件的元素的数组，可链式调用</td>\n</tr>\n<tr>\n<td align=\"center\">every()、some()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>\n</tr>\n<tr>\n<td align=\"center\">find()、findIndex()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>\n</tr>\n<tr>\n<td align=\"center\">reduce()、reduceRight()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">reduce()对数组正序操作；reduceRight()对数组逆序操作</td>\n</tr>\n<tr>\n<td align=\"center\">keys()、values()、entries()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">keys() 返回数组的索引值；values() 返回数组元素；entries() 返回数组的键值对。</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2对象遍历方法\"><a href=\"#1-2对象遍历方法\" class=\"headerlink\" title=\"1.2对象遍历方法\"></a>1.2对象遍历方法</h2><h3 id=\"1-for-in\"><a href=\"#1-for-in\" class=\"headerlink\" title=\"1. for in\"></a>1. for in</h3><p><code>for…in</code> 主要用于循环对象属性。循环中的代码每执行一次，就会对对象的属性进行一次操作。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">in</span> object) &#123;<br> 执行的代码块<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中两个参数：</p>\n<ul>\n<li>var：必须。指定的变量可以是数组元素，也可以是对象的属性。</li>\n<li>object：必须。指定迭代的的对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>&#125;; <br> <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj) &#123; <br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;键名：&#x27;</span>, i); <br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;键值：&#x27;</span>, obj[i]); <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">键名：a<br>键值： <span class=\"hljs-number\">1</span><br>键名：b<br>键值： <span class=\"hljs-number\">2</span><br>键名：c<br>键值： <span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>for in 方法不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。</li>\n</ul>\n<h3 id=\"2-Object-keys-、Object-values-、Object-entries\"><a href=\"#2-Object-keys-、Object-values-、Object-entries\" class=\"headerlink\" title=\"2. Object.keys()、Object.values()、Object.entries()\"></a>2. Object.keys()、Object.values()、Object.entries()</h3><p>这三个方法都用来遍历对象，它会返回一个由给定对象的自身可枚举属性（不含继承的和Symbol属性）组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，这个三个元素返回的值分别如下：</p>\n<ul>\n<li>Object.keys()：返回包含对象键名的数组；</li>\n<li>Object.values()：返回包含对象键值的数组；</li>\n<li>Object.entries()：返回包含对象键名和键值的数组。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123; <br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> <br>&#125;;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(obj));   <span class=\"hljs-comment\">// 输出结果: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.values(obj)); <span class=\"hljs-comment\">// 输出结果: [1, &#x27;hello&#x27;, 18]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.entries(obj));   <span class=\"hljs-comment\">// 输出结果: [[&#x27;id&#x27;, 1], [&#x27;name&#x27;, &#x27;hello&#x27;], [&#x27;age&#x27;, 18]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意</p>\n<ul>\n<li>Object.keys()方法返回的数组中的值都是字符串，也就是说不是字符串的key值会转化为字符串。</li>\n<li>结果数组中的属性值都是对象本身<strong>可枚举的属性</strong>，不包括继承来的属性。</li>\n</ul>\n<h3 id=\"3-Object-getOwnPropertyNames\"><a href=\"#3-Object-getOwnPropertyNames\" class=\"headerlink\" title=\"3. Object.getOwnPropertyNames()\"></a>3. Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames()</code>方法与<code>Object.keys()</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回<strong>不可枚举的属性。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> a = [<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;World&#x27;</span>];<br> <br><span class=\"hljs-built_in\">Object</span>.keys(a) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;]</span><br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(a) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<p>这两个方法都可以用来计算对象中属性的个数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-number\">0</span>: <span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&quot;c&quot;</span>&#125;;<br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br><span class=\"hljs-built_in\">Object</span>.keys(obj).length <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj).length <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-Object-getOwnPropertySymbols\"><a href=\"#4-Object-getOwnPropertySymbols\" class=\"headerlink\" title=\"4. Object.getOwnPropertySymbols()\"></a>4. Object.getOwnPropertySymbols()</h3><p><code>Object.getOwnPropertySymbols()</code> 方法返回对象自身的 Symbol 属性组成的数组，不包括字符串属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// 给对象添加一个不可枚举的 Symbol 属性</span><br><span class=\"hljs-built_in\">Object</span>.defineProperties(obj, &#123;<br> [<span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)]: &#123;<br>  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Symbol baz&#x27;</span>,<br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span><br> &#125;<br>&#125;)<br> <br><span class=\"hljs-comment\">// 给对象添加一个可枚举的 Symbol 属性</span><br>obj[<span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)] = <span class=\"hljs-string\">&#x27;Symbol foo&#x27;</span><br> <br><span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols(obj).forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> &#123;<br> <span class=\"hljs-built_in\">console</span>.log(obj[key]) <br>&#125;)<br><br><span class=\"hljs-comment\">// 输出结果：Symbol baz Symbol foo</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-Reflect-ownKeys\"><a href=\"#5-Reflect-ownKeys\" class=\"headerlink\" title=\"5. Reflect.ownKeys()\"></a>5. Reflect.ownKeys()</h3><p>Reflect.ownKeys() 返回一个数组，包含对象自身的所有属性。它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,<br> <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span><br>&#125;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&#x27;method&#x27;</span>, &#123;<br> <span class=\"hljs-attr\">value</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>     alert(<span class=\"hljs-string\">&quot;Non enumerable property&quot;</span>)<br> &#125;,<br> <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span><br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(obj))<br><span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Reflect</span>.ownKeys(obj))<br><span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;method&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li><p>Object.keys() ：相当于返回对象属性数组；</p>\n</li>\n<li><p>Reflect.ownKeys() :相当于</p>\n<p><code>Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)</code>。</p>\n</li>\n</ul>\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>对象方法</strong></th>\n<th align=\"center\"><strong>遍历基本属性</strong></th>\n<th align=\"center\"><strong>遍历原型链</strong></th>\n<th align=\"center\"><strong>遍历不可枚举属性</strong></th>\n<th align=\"center\"><strong>遍历Symbol</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">for in</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.keys()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.getOwnPropertyNames()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.getOwnPropertySymbols()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">Reflect.ownKeys()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3其他遍历方式\"><a href=\"#1-3其他遍历方式\" class=\"headerlink\" title=\"1.3其他遍历方式\"></a>1.3其他遍历方式</h2><h3 id=\"1-for\"><a href=\"#1-for\" class=\"headerlink\" title=\"1. for\"></a>1. for</h3><p>for循环是应该是最常见的循环方式了，它由三个表达式组成，分别是声明循环变量、判断循环条件、更新循环变量。这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = arr.length; i &lt; len; i++ )&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(arr[i])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在执行的时候，会先判断执行条件，再执行。for循环可以用来遍历数组，字符串，类数组，DOM节点等。可以改变原数组。</p>\n<h3 id=\"2-while\"><a href=\"#2-while\" class=\"headerlink\" title=\"2. while\"></a>2. while</h3><p><code>while</code>循环中的结束条件可以是各种类型，但是最终都会转为布尔值，转换规则如下。</p>\n<ul>\n<li>Boolean：true为真，false为假；</li>\n<li>String：空字符串为假，所有非空字符串为真；</li>\n<li>Number：0为假，非0数字为真；</li>\n<li>null/Undefined/NaN：全为假；</li>\n<li>Object：全为真。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>;<br>            <br><span class=\"hljs-keyword\">while</span> (num &lt; <span class=\"hljs-number\">10</span>)&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(num);<br>    num ++;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>while</code>和<code>for</code>一样，都是先判断，再执行。只要指定条件为 true，循环就可以一直执行代码。</p>\n<h3 id=\"3-do-while\"><a href=\"#3-do-while\" class=\"headerlink\" title=\"3. do / while\"></a>3. do / while</h3><p>该方法会先执行再判断，即使初始条件不成立，<code>do/while</code>循环也至少会执行一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">10</span>;<br>            <br><span class=\"hljs-keyword\">do</span><br> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(num);<br>    num--;<br>  &#125;<br><span class=\"hljs-keyword\">while</span>(num &gt;= <span class=\"hljs-number\">0</span>);<br>            <br><span class=\"hljs-built_in\">console</span>.log(num); <span class=\"hljs-comment\">//-1</span><br></code></pre></td></tr></table></figure>\n\n<p>不建议使用do / while来遍历数组。</p>\n<h3 id=\"4-for-await-of\"><a href=\"#4-for-await-of\" class=\"headerlink\" title=\"4. for await of\"></a>4. for await of</h3><p><code>for await...of</code>方法被称为<strong>异步迭代器</strong>，该方法是主要用来遍历异步对象。它是ES2018中引入的方法。</p>\n<p><code>for await...of</code> 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，类数组，Map， Set和自定义的异步或者同步可迭代对象。这个语句只能在 <code>async function</code>内使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Gen</span> (<span class=\"hljs-params\">time</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>       resolve(time)<br>    &#125;,time)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>   <span class=\"hljs-keyword\">let</span> arr = [Gen(<span class=\"hljs-number\">2000</span>),Gen(<span class=\"hljs-number\">100</span>),Gen(<span class=\"hljs-number\">3000</span>)]<br>   <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">await</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> arr) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Date</span>.now(),item)<br>   &#125;<br>&#125;<br>test()<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.hualigs.cn/image/61556b1601dd4.jpg\"></p>\n","site":{"data":{}},"wordcount":9985,"excerpt":"","more":"<h1 id=\"一，24个JavaScript循环遍历方式\"><a href=\"#一，24个JavaScript循环遍历方式\" class=\"headerlink\" title=\"一，24个JavaScript循环遍历方式\"></a>一，24个JavaScript循环遍历方式</h1><p><img src=\"https://www.hualigs.cn/image/61556646d8326.jpg\"></p>\n<h2 id=\"1-1数组遍历\"><a href=\"#1-1数组遍历\" class=\"headerlink\" title=\"1.1数组遍历\"></a>1.1数组遍历</h2><h3 id=\"1-forEach\"><a href=\"#1-forEach\" class=\"headerlink\" title=\"1. forEach()\"></a>1. forEach()</h3><p><code>forEach</code> 方法用于调用数组的每个元素，并将元素传递给回调函数。数组中的每个值都会调用回调函数。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue, index, arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必需。当前元素</li>\n<li>index：可选。当前元素的索引值。</li>\n<li>arr：可选。当前元素所属的数组对象</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br>arr.forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">item, index, arr</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(index+<span class=\"hljs-string\">&quot;:&quot;</span>+item)<br>&#125;)<br></code></pre></td></tr></table></figure>\n\n<p>该方法还可以有第二个参数，用来绑定回调函数内部this变量（前提是回调函数不能是箭头函数，因为箭头函数没有this）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">9</span>,<span class=\"hljs-number\">8</span>,<span class=\"hljs-number\">7</span>,<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">5</span>]<br>arr.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">item, index, arr</span>)</span>&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">this</span>[index])  <span class=\"hljs-comment\">//  9 8 7 6 5</span><br>&#125;, arr1)<br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>forEach 方法不会改变原数组，也没有返回值；</li>\n<li>forEach无法使用 break，continue 跳出循环，使用 return 时，效果和在 for 循环中使用 continue 一致；</li>\n<li>forEach 方法无法遍历对象，仅适用于数组的遍历。</li>\n</ul>\n<h3 id=\"2-map\"><a href=\"#2-map\" class=\"headerlink\" title=\"2. map()\"></a>2. map()</h3><p><code>map()</code> 方法会返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。该方法按照原始数组元素顺序依次处理元素。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br> <br>arr.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> &#123;<br>    <span class=\"hljs-keyword\">return</span> item + <span class=\"hljs-number\">1</span>;<br>&#125;)<br><br><span class=\"hljs-comment\">// 输出结果： [2, 3, 4]</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第二个参数用来绑定参数函数内部的this变量，是可选的：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];<br> <br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>].map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) </span>&#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>[e];<br>&#125;, arr)<br><br><span class=\"hljs-comment\">// 输出结果： [&#x27;b&#x27;, &#x27;c&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法还可以进行链式调用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br> <br>arr.map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>).map(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item + <span class=\"hljs-number\">1</span>)<br><br><span class=\"hljs-comment\">// 输出结果： [3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>map 方法不会对空数组进行检测；</li>\n<li>map 方法遍历数组时会返回一个新数组，<strong>不会改变原始数组</strong>；</li>\n<li>map 方法有返回值，可以return出来，map的回调函数中支持return返回值；</li>\n<li>map 方法无法遍历对象，仅适用于数组的遍历。</li>\n</ul>\n<h3 id=\"3-for-of\"><a href=\"#3-for-of\" class=\"headerlink\" title=\"3. for of\"></a>3. for of</h3><p><code>for...of</code> 语句创建一个循环来迭代可迭代的对象。在 ES6 中引入的 <code>for...of</code> 循环，以替代 <code>for...in</code> 和 <code>forEach()</code> ，并支持新的迭代协议。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (variable <span class=\"hljs-keyword\">of</span> iterable) &#123;<br>    statement<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该方法有两个参数：</p>\n<ul>\n<li>variable：每个迭代的属性值被分配给该变量。</li>\n<li>iterable：一个具有可枚举属性并且可以迭代的对象。</li>\n</ul>\n<p>该方法可以获取数组的每一项：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;hello&#x27;</span>&#125;,<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;world&#x27;</span>&#125;,<br>    &#123;<span class=\"hljs-attr\">id</span>:<span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">value</span>:<span class=\"hljs-string\">&#x27;JavaScript&#x27;</span>&#125;<br>]<br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> arr) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item); <br>&#125;<br><span class=\"hljs-comment\">// 输出结果：&#123;id:1, value:&#x27;hello&#x27;&#125;  &#123;id:2, value:&#x27;world&#x27;&#125; &#123;id:3, value:&#x27;JavaScript&#x27;&#125;</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>for of 方法只会遍历当前对象的属性，不会遍历其原型链上的属性；</li>\n<li>for of 方法适用遍历 <strong>数组/ 类数组/字符串/map/set</strong> 等拥有迭代器对象的集合；</li>\n<li>for of 方法不支持遍历普通对象，因为其没有迭代器对象。如果想要遍历一个对象的属性，可以用 for in 方法；</li>\n<li>可以使用break、continue、return来中断循环遍历；</li>\n</ul>\n<h3 id=\"4-filter\"><a href=\"#4-filter\" class=\"headerlink\" title=\"4. filter()\"></a>4. filter()</h3><p><code>filter()</code>方法用于过滤数组，满足条件的元素会被返回。它的参数是一个回调函数，所有数组元素依次执行该函数，返回结果为true的元素会被返回，如果没有符合条件的元素，则返回空数组。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>), <span class=\"hljs-title\">thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>该方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.filter(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：[3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<p>同样，它也有第二个参数，用来绑定参数函数内部的this变量。</p>\n<p>可以使用<code>filter()</code>方法来移除数组中的undefined、null、NAN等值：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">undefined</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">null</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-string\">&#x27;&#x27;</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>]<br>arr.filter(<span class=\"hljs-built_in\">Boolean</span>)<br><br><span class=\"hljs-comment\">// 输出结果：[1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>filter 方法会返回一个新的数组，不会改变原数组；</li>\n<li>filter 方法不会对空数组进行检测；</li>\n<li>filter 方法仅适用于检测数组。</li>\n</ul>\n<h3 id=\"5-some-、every\"><a href=\"#5-some-、every\" class=\"headerlink\" title=\"5. some()、every()\"></a>5. some()、every()</h3><p>some() 方法会对数组中的每一项进行遍历，只要有一个元素符合条件，就返回true，且剩余的元素不会再进行检测，否则就返回false。</p>\n<p>every() 方法会对数组中的每一项进行遍历，只有所有元素都符合条件时，才返回true，如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。其语法如下：</p>\n<p>两者的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.some(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue,index,arr</span>),<span class=\"hljs-title\">thisValue</span>)</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">array</span>.<span class=\"hljs-title\">every</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">function</span>(currentValue,index,arr), thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>两个方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必须。当前元素的值；</li>\n<li>index：可选。当前元素的索引值；</li>\n<li>arr：可选。当前元素属于的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.some(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">4</span>) <br><br><span class=\"hljs-comment\">// 输出结果：true</span><br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.every(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">0</span>) <br><br><span class=\"hljs-comment\">// 输出结果：true</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>两个方法都不会改变原数组，会返回一个布尔值；</li>\n<li>两个方法都不会对空数组进行检测；</li>\n<li>两个方法都仅适用于检测数组。</li>\n</ul>\n<h3 id=\"6-reduce-、reduceRight\"><a href=\"#6-reduce-、reduceRight\" class=\"headerlink\" title=\"6. reduce()、reduceRight()\"></a>6. reduce()、reduceRight()</h3><p>reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce() 可以作为一个高阶函数，用于函数的 compose。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">total, currentValue, currentIndex, arr</span>), <span class=\"hljs-title\">initialValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>reduce 方法会为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，回调函数接受四个参数：</p>\n<ul>\n<li>total：上一次调用回调返回的值，或者是提供的初始值（initialValue）；</li>\n<li>currentValue：当前被处理的元素；</li>\n<li>currentIndex：当前元素的索引；</li>\n<li>arr：当前元素所属的数组对象。</li>\n</ul>\n<p>该方法的第二个参数是 <code>initialValue</code>，表示传递给函数的初始值 （作为第一次调用 callback 的第一个参数）：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">3</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">10</span><br></code></pre></td></tr></table></figure>\n\n<p>再来加一个初始值试试：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduce(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;, <span class=\"hljs-number\">5</span>)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br><span class=\"hljs-number\">6</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">8</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">15</span><br></code></pre></td></tr></table></figure>\n\n<p>由此可以得出结论：<strong>如果没有提供初始值initialValue，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引。如果提供了初始值initialValue，从索引0开始执行</strong></p>\n<p>reduceRight() 方法和的<code>reduce()</code>用法几乎一致，只是该方法是对数组进行倒序遍历的，而<code>reduce()</code>方法是正序遍历的。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]<br><span class=\"hljs-keyword\">let</span> sum = arr.reduceRight(<span class=\"hljs-function\">(<span class=\"hljs-params\">prev, cur, index, arr</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(prev, cur, index);<br>    <span class=\"hljs-keyword\">return</span> prev + cur;<br>&#125;, <span class=\"hljs-number\">5</span>)<br><span class=\"hljs-built_in\">console</span>.log(arr, sum);<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">3</span><br><span class=\"hljs-number\">9</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span><br><span class=\"hljs-number\">12</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span><br><span class=\"hljs-number\">14</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">0</span><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>] <span class=\"hljs-number\">15</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>两个方法都不会改变原数组；</li>\n<li>两个方法如果添加初始值，就会改变原数组，会将这个初始值放在数组的最后一位；</li>\n<li>两个方法对于空数组是不会执行回调函数的。</li>\n</ul>\n<h3 id=\"7-find-、findIndex\"><a href=\"#7-find-、findIndex\" class=\"headerlink\" title=\"7. find()、findIndex()\"></a>7. find()、findIndex()</h3><p><code>find()</code> 方法返回通过函数内判断的数组的第一个元素的值。当数组中的元素在测试条件时返回 true 时， <code>find()</code> 返回符合条件的元素，之后的值不会再调用执行函数。如果没有符合条件的元素返回 undefined。</p>\n<p><code>findIndex()</code> 方法返回传入一个测试函数符合条件的数组<strong>第一个元素位置</strong>（索引）。当数组中的元素在函数条件时返回 true 时， <code>findIndex()</code> 返回符合条件的元素的索引位置，之后的值不会再调用执行函数。如果没有符合条件的元素返回 -1。</p>\n<p>两个方法的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.find(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">currentValue, index, arr</span>),<span class=\"hljs-title\">thisValue</span>)</span><br><span class=\"hljs-function\"><span class=\"hljs-title\">array</span>.<span class=\"hljs-title\">findIndex</span>(<span class=\"hljs-params\"><span class=\"hljs-keyword\">function</span>(currentValue, index, arr), thisValue</span>)</span><br></code></pre></td></tr></table></figure>\n\n<p>两个方法的第一个参数为回调函数，是必传的，它有三个参数：</p>\n<ul>\n<li>currentValue：必需。当前元素；</li>\n<li>index：可选。当前元素的索引；</li>\n<li>arr：可选。当前元素所属的数组对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.find(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：3</span><br><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>]<br>arr.findIndex(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item &gt; <span class=\"hljs-number\">2</span>) <br><br><span class=\"hljs-comment\">// 输出结果：2</span><br></code></pre></td></tr></table></figure>\n\n<p><code>find()</code>和<code>findIndex()</code>两个方法几乎一样，只是返回结果不同：</p>\n<ul>\n<li><code>find()</code>：返回的是第一个符合条件的值；</li>\n<li><code>findIndex</code>：返回的是第一个返回条件的值的索引值。</li>\n</ul>\n<p>注意：</p>\n<ul>\n<li>两个方法对于空数组，函数是不会执行的；</li>\n<li>两个方法否不会改变原数组。</li>\n</ul>\n<h3 id=\"8-keys-、values-、entries\"><a href=\"#8-keys-、values-、entries\" class=\"headerlink\" title=\"8. keys()、values()、entries()\"></a>8. keys()、values()、entries()</h3><p>三个方法都返回一个数组的迭代对象，对象的内容不太相同：</p>\n<ul>\n<li>keys() 返回数组的索引值；</li>\n<li>values() 返回数组的元素；</li>\n<li>entries() 返回数组的键值对。</li>\n</ul>\n<p>三个方法的语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">array.keys()<br>array.values()<br>array.entries()<br></code></pre></td></tr></table></figure>\n\n<p>这三个方法都没有参数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-string\">&quot;Banana&quot;</span>, <span class=\"hljs-string\">&quot;Orange&quot;</span>, <span class=\"hljs-string\">&quot;Apple&quot;</span>, <span class=\"hljs-string\">&quot;Mango&quot;</span>];<br><span class=\"hljs-keyword\">const</span> iterator1 = arr.keys();<br><span class=\"hljs-keyword\">const</span> iterator2 = arr.values() <br><span class=\"hljs-keyword\">const</span> iterator3 = arr.entries() <br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator1) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果： 0 1 2 3</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator2) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果：Banana Orange Apple Mango</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> iterator3) &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(item);<br>&#125;<br><span class=\"hljs-comment\">// 输出结果：[0, &#x27;Banana&#x27;] [1, &#x27;Orange&#x27;] [2, &#x27;Apple&#x27;] [3, &#x27;Mango&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>方法</strong></th>\n<th align=\"center\"><strong>是否改变原数组</strong></th>\n<th align=\"center\"><strong>特点</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">forEach()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">没有返回值</td>\n</tr>\n<tr>\n<td align=\"center\">map()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">有返回值，可链式调用</td>\n</tr>\n<tr>\n<td align=\"center\">for of</td>\n<td align=\"center\">否</td>\n<td align=\"center\">for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>\n</tr>\n<tr>\n<td align=\"center\">filter()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">过滤数组，返回包含符合条件的元素的数组，可链式调用</td>\n</tr>\n<tr>\n<td align=\"center\">every()、some()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>\n</tr>\n<tr>\n<td align=\"center\">find()、findIndex()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>\n</tr>\n<tr>\n<td align=\"center\">reduce()、reduceRight()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">reduce()对数组正序操作；reduceRight()对数组逆序操作</td>\n</tr>\n<tr>\n<td align=\"center\">keys()、values()、entries()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">keys() 返回数组的索引值；values() 返回数组元素；entries() 返回数组的键值对。</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-2对象遍历方法\"><a href=\"#1-2对象遍历方法\" class=\"headerlink\" title=\"1.2对象遍历方法\"></a>1.2对象遍历方法</h2><h3 id=\"1-for-in\"><a href=\"#1-for-in\" class=\"headerlink\" title=\"1. for in\"></a>1. for in</h3><p><code>for…in</code> 主要用于循环对象属性。循环中的代码每执行一次，就会对对象的属性进行一次操作。其语法如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">in</span> object) &#123;<br> 执行的代码块<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其中两个参数：</p>\n<ul>\n<li>var：必须。指定的变量可以是数组元素，也可以是对象的属性。</li>\n<li>object：必须。指定迭代的的对象。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span>&#125;; <br> <br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">in</span> obj) &#123; <br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;键名：&#x27;</span>, i); <br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&#x27;键值：&#x27;</span>, obj[i]); <br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>输出结果：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\">键名：a<br>键值： <span class=\"hljs-number\">1</span><br>键名：b<br>键值： <span class=\"hljs-number\">2</span><br>键名：c<br>键值： <span class=\"hljs-number\">3</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li>for in 方法不仅会遍历当前的对象所有的可枚举属性，还会遍历其原型链上的属性。</li>\n</ul>\n<h3 id=\"2-Object-keys-、Object-values-、Object-entries\"><a href=\"#2-Object-keys-、Object-values-、Object-entries\" class=\"headerlink\" title=\"2. Object.keys()、Object.values()、Object.entries()\"></a>2. Object.keys()、Object.values()、Object.entries()</h3><p>这三个方法都用来遍历对象，它会返回一个由给定对象的自身可枚举属性（不含继承的和Symbol属性）组成的数组，数组元素的排列顺序和正常循环遍历该对象时返回的顺序一致，这个三个元素返回的值分别如下：</p>\n<ul>\n<li>Object.keys()：返回包含对象键名的数组；</li>\n<li>Object.values()：返回包含对象键值的数组；</li>\n<li>Object.entries()：返回包含对象键名和键值的数组。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123; <br>  <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;hello&#x27;</span>, <br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">18</span> <br>&#125;;<br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(obj));   <span class=\"hljs-comment\">// 输出结果: [&#x27;id&#x27;, &#x27;name&#x27;, &#x27;age&#x27;]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.values(obj)); <span class=\"hljs-comment\">// 输出结果: [1, &#x27;hello&#x27;, 18]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.entries(obj));   <span class=\"hljs-comment\">// 输出结果: [[&#x27;id&#x27;, 1], [&#x27;name&#x27;, &#x27;hello&#x27;], [&#x27;age&#x27;, 18]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意</p>\n<ul>\n<li>Object.keys()方法返回的数组中的值都是字符串，也就是说不是字符串的key值会转化为字符串。</li>\n<li>结果数组中的属性值都是对象本身<strong>可枚举的属性</strong>，不包括继承来的属性。</li>\n</ul>\n<h3 id=\"3-Object-getOwnPropertyNames\"><a href=\"#3-Object-getOwnPropertyNames\" class=\"headerlink\" title=\"3. Object.getOwnPropertyNames()\"></a>3. Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames()</code>方法与<code>Object.keys()</code>类似，也是接受一个对象作为参数，返回一个数组，包含了该对象自身的所有属性名。但它能返回<strong>不可枚举的属性。</strong></p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> a = [<span class=\"hljs-string\">&#x27;Hello&#x27;</span>, <span class=\"hljs-string\">&#x27;World&#x27;</span>];<br> <br><span class=\"hljs-built_in\">Object</span>.keys(a) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;]</span><br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(a) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;, &quot;length&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<p>这两个方法都可以用来计算对象中属性的个数：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123; <span class=\"hljs-number\">0</span>: <span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-number\">1</span>: <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-number\">2</span>: <span class=\"hljs-string\">&quot;c&quot;</span>&#125;;<br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj) <span class=\"hljs-comment\">// [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br><span class=\"hljs-built_in\">Object</span>.keys(obj).length <span class=\"hljs-comment\">// 3</span><br><span class=\"hljs-built_in\">Object</span>.getOwnPropertyNames(obj).length <span class=\"hljs-comment\">// 3</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-Object-getOwnPropertySymbols\"><a href=\"#4-Object-getOwnPropertySymbols\" class=\"headerlink\" title=\"4. Object.getOwnPropertySymbols()\"></a>4. Object.getOwnPropertySymbols()</h3><p><code>Object.getOwnPropertySymbols()</code> 方法返回对象自身的 Symbol 属性组成的数组，不包括字符串属性：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> obj = &#123;<span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>&#125;<br><br><span class=\"hljs-comment\">// 给对象添加一个不可枚举的 Symbol 属性</span><br><span class=\"hljs-built_in\">Object</span>.defineProperties(obj, &#123;<br> [<span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;baz&#x27;</span>)]: &#123;<br>  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-string\">&#x27;Symbol baz&#x27;</span>,<br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span><br> &#125;<br>&#125;)<br> <br><span class=\"hljs-comment\">// 给对象添加一个可枚举的 Symbol 属性</span><br>obj[<span class=\"hljs-built_in\">Symbol</span>(<span class=\"hljs-string\">&#x27;foo&#x27;</span>)] = <span class=\"hljs-string\">&#x27;Symbol foo&#x27;</span><br> <br><span class=\"hljs-built_in\">Object</span>.getOwnPropertySymbols(obj).forEach(<span class=\"hljs-function\">(<span class=\"hljs-params\">key</span>) =&gt;</span> &#123;<br> <span class=\"hljs-built_in\">console</span>.log(obj[key]) <br>&#125;)<br><br><span class=\"hljs-comment\">// 输出结果：Symbol baz Symbol foo</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-Reflect-ownKeys\"><a href=\"#5-Reflect-ownKeys\" class=\"headerlink\" title=\"5. Reflect.ownKeys()\"></a>5. Reflect.ownKeys()</h3><p>Reflect.ownKeys() 返回一个数组，包含对象自身的所有属性。它和Object.keys()类似，Object.keys()返回属性key，但不包括不可枚举的属性，而Reflect.ownKeys()会返回所有属性key：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">var</span> obj = &#123;<br> <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>,<br> <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span><br>&#125;<br><span class=\"hljs-built_in\">Object</span>.defineProperty(obj, <span class=\"hljs-string\">&#x27;method&#x27;</span>, &#123;<br> <span class=\"hljs-attr\">value</span>: <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>     alert(<span class=\"hljs-string\">&quot;Non enumerable property&quot;</span>)<br> &#125;,<br> <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span><br>&#125;)<br><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Object</span>.keys(obj))<br><span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;]</span><br><span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Reflect</span>.ownKeys(obj))<br><span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;method&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<p>注意：</p>\n<ul>\n<li><p>Object.keys() ：相当于返回对象属性数组；</p>\n</li>\n<li><p>Reflect.ownKeys() :相当于</p>\n<p><code>Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj)</code>。</p>\n</li>\n</ul>\n<p><strong>总结：</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"><strong>对象方法</strong></th>\n<th align=\"center\"><strong>遍历基本属性</strong></th>\n<th align=\"center\"><strong>遍历原型链</strong></th>\n<th align=\"center\"><strong>遍历不可枚举属性</strong></th>\n<th align=\"center\"><strong>遍历Symbol</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"center\">for in</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.keys()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.getOwnPropertyNames()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n</tr>\n<tr>\n<td align=\"center\">Object.getOwnPropertySymbols()</td>\n<td align=\"center\">否</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n<tr>\n<td align=\"center\">Reflect.ownKeys()</td>\n<td align=\"center\">是</td>\n<td align=\"center\">否</td>\n<td align=\"center\">是</td>\n<td align=\"center\">是</td>\n</tr>\n</tbody></table>\n<h2 id=\"1-3其他遍历方式\"><a href=\"#1-3其他遍历方式\" class=\"headerlink\" title=\"1.3其他遍历方式\"></a>1.3其他遍历方式</h2><h3 id=\"1-for\"><a href=\"#1-for\" class=\"headerlink\" title=\"1. for\"></a>1. for</h3><p>for循环是应该是最常见的循环方式了，它由三个表达式组成，分别是声明循环变量、判断循环条件、更新循环变量。这三个表达式用分号分隔。可以使用临时变量将数组的长度缓存起来，避免重复获取数组长度，当数组较大时优化效果会比较明显。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>,<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>, len = arr.length; i &lt; len; i++ )&#123;<br>  <span class=\"hljs-built_in\">console</span>.log(arr[i])<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在执行的时候，会先判断执行条件，再执行。for循环可以用来遍历数组，字符串，类数组，DOM节点等。可以改变原数组。</p>\n<h3 id=\"2-while\"><a href=\"#2-while\" class=\"headerlink\" title=\"2. while\"></a>2. while</h3><p><code>while</code>循环中的结束条件可以是各种类型，但是最终都会转为布尔值，转换规则如下。</p>\n<ul>\n<li>Boolean：true为真，false为假；</li>\n<li>String：空字符串为假，所有非空字符串为真；</li>\n<li>Number：0为假，非0数字为真；</li>\n<li>null/Undefined/NaN：全为假；</li>\n<li>Object：全为真。</li>\n</ul>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">1</span>;<br>            <br><span class=\"hljs-keyword\">while</span> (num &lt; <span class=\"hljs-number\">10</span>)&#123;<br>    <span class=\"hljs-built_in\">console</span>.log(num);<br>    num ++;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p><code>while</code>和<code>for</code>一样，都是先判断，再执行。只要指定条件为 true，循环就可以一直执行代码。</p>\n<h3 id=\"3-do-while\"><a href=\"#3-do-while\" class=\"headerlink\" title=\"3. do / while\"></a>3. do / while</h3><p>该方法会先执行再判断，即使初始条件不成立，<code>do/while</code>循环也至少会执行一次。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">let</span> num = <span class=\"hljs-number\">10</span>;<br>            <br><span class=\"hljs-keyword\">do</span><br> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(num);<br>    num--;<br>  &#125;<br><span class=\"hljs-keyword\">while</span>(num &gt;= <span class=\"hljs-number\">0</span>);<br>            <br><span class=\"hljs-built_in\">console</span>.log(num); <span class=\"hljs-comment\">//-1</span><br></code></pre></td></tr></table></figure>\n\n<p>不建议使用do / while来遍历数组。</p>\n<h3 id=\"4-for-await-of\"><a href=\"#4-for-await-of\" class=\"headerlink\" title=\"4. for await of\"></a>4. for await of</h3><p><code>for await...of</code>方法被称为<strong>异步迭代器</strong>，该方法是主要用来遍历异步对象。它是ES2018中引入的方法。</p>\n<p><code>for await...of</code> 语句会在异步或者同步可迭代对象上创建一个迭代循环，包括 String，Array，类数组，Map， Set和自定义的异步或者同步可迭代对象。这个语句只能在 <code>async function</code>内使用：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Gen</span> (<span class=\"hljs-params\">time</span>) </span>&#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve,reject</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>       resolve(time)<br>    &#125;,time)<br>  &#125;)<br>&#125;<br><br><span class=\"hljs-keyword\">async</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">test</span> (<span class=\"hljs-params\"></span>) </span>&#123;<br>   <span class=\"hljs-keyword\">let</span> arr = [Gen(<span class=\"hljs-number\">2000</span>),Gen(<span class=\"hljs-number\">100</span>),Gen(<span class=\"hljs-number\">3000</span>)]<br>   <span class=\"hljs-keyword\">for</span> <span class=\"hljs-keyword\">await</span> (<span class=\"hljs-keyword\">let</span> item <span class=\"hljs-keyword\">of</span> arr) &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-built_in\">Date</span>.now(),item)<br>   &#125;<br>&#125;<br>test()<br></code></pre></td></tr></table></figure>\n\n<p><img src=\"https://www.hualigs.cn/image/61556b1601dd4.jpg\"></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cll9ivves0001b0gi3mj44z40","category_id":"cll9ivvew0003b0gidksp8eqt","_id":"cll9ivvf1000db0gi3auadoyn"},{"post_id":"cll9ivveu0002b0gi854a967d","category_id":"cll9ivvez0008b0giadktb1zm","_id":"cll9ivvf3000kb0gic5yca2l7"},{"post_id":"cll9ivvex0005b0gihmkpa5m0","category_id":"cll9ivvf1000eb0gibado6f9a","_id":"cll9ivvf5000rb0gid7hq1c7o"},{"post_id":"cll9ivvey0006b0gi3h5xa5qw","category_id":"cll9ivvf1000eb0gibado6f9a","_id":"cll9ivvf7000wb0gifk9ge665"},{"post_id":"cll9ivvez0007b0gi1pn8g9ye","category_id":"cll9ivvf5000qb0gi5jm9f9dn","_id":"cll9ivvf80013b0gigrg39eqs"},{"post_id":"cll9ivvf0000bb0gi76m79epv","category_id":"cll9ivvf5000qb0gi5jm9f9dn","_id":"cll9ivvf90017b0gi92qq2jky"},{"post_id":"cll9ivvf0000cb0gif5ni7y3k","category_id":"cll9ivvf1000eb0gibado6f9a","_id":"cll9ivvf9001ab0gih2wj56hu"},{"post_id":"cll9ivvf1000hb0giat2e1wh0","category_id":"cll9ivvf80016b0gie0oc1tb1","_id":"cll9ivvf9001eb0gi0wzsanhh"},{"post_id":"cll9ivvf2000jb0gicg6m3qtv","category_id":"cll9ivvf9001bb0gi5ey656ni","_id":"cll9ivvfa001ib0gi2i2wbiwk"},{"post_id":"cll9ivvf4000nb0gifiov7tcz","category_id":"cll9ivvf9001fb0gi959j7ax5","_id":"cll9ivvfa001nb0gif0eig9dk"},{"post_id":"cll9ivvf4000pb0gi3on33zyy","category_id":"cll9ivvf80016b0gie0oc1tb1","_id":"cll9ivvfb001pb0gi6ayc5rdg"},{"post_id":"cll9ivvf5000tb0gi0q50d8t0","category_id":"cll9ivvfa001mb0gi5394e81d","_id":"cll9ivvfb001rb0gi8tzj7uj9"},{"post_id":"cll9ivvf6000vb0gi2yie8877","category_id":"cll9ivvfb001qb0gi45tncag5","_id":"cll9ivvfb001tb0gi5l07fcsv"},{"post_id":"cll9ivvf7000zb0gi3sohhimr","category_id":"cll9ivvfb001sb0gi3mo23pfl","_id":"cll9ivvfb001ub0gi7jbbdfce"},{"post_id":"cll9ivvfc001vb0gi103z382u","category_id":"cll9ivvf1000eb0gibado6f9a","_id":"cll9ivvfc001xb0gi6cyc2ivk"}],"PostTag":[{"post_id":"cll9ivves0001b0gi3mj44z40","tag_id":"cll9ivvex0004b0gi2lmc0cmk","_id":"cll9ivvez000ab0gi1sgfhvb2"},{"post_id":"cll9ivvf0000bb0gi76m79epv","tag_id":"cll9ivvez0009b0gi6brqa3j1","_id":"cll9ivvf1000gb0gi7kl43scc"},{"post_id":"cll9ivveu0002b0gi854a967d","tag_id":"cll9ivvez0009b0gi6brqa3j1","_id":"cll9ivvf2000ib0gi9pw541z2"},{"post_id":"cll9ivvex0005b0gihmkpa5m0","tag_id":"cll9ivvf1000fb0gi2vd7714k","_id":"cll9ivvf4000ob0gi46x50w9x"},{"post_id":"cll9ivvey0006b0gi3h5xa5qw","tag_id":"cll9ivvf1000fb0gi2vd7714k","_id":"cll9ivvf6000ub0gibcd05wwv"},{"post_id":"cll9ivvez0007b0gi1pn8g9ye","tag_id":"cll9ivvez0009b0gi6brqa3j1","_id":"cll9ivvf70010b0gi6fh38oc3"},{"post_id":"cll9ivvf6000vb0gi2yie8877","tag_id":"cll9ivvez0009b0gi6brqa3j1","_id":"cll9ivvf80011b0gi2scgc188"},{"post_id":"cll9ivvf1000hb0giat2e1wh0","tag_id":"cll9ivvf7000xb0gian9nb0hq","_id":"cll9ivvf80015b0gi494m5mks"},{"post_id":"cll9ivvf2000jb0gicg6m3qtv","tag_id":"cll9ivvf80014b0gib59q600w","_id":"cll9ivvf90019b0gi7mhg3c6l"},{"post_id":"cll9ivvf4000nb0gifiov7tcz","tag_id":"cll9ivvf90018b0gi91xccb7i","_id":"cll9ivvf9001db0gihutk5h1r"},{"post_id":"cll9ivvf4000pb0gi3on33zyy","tag_id":"cll9ivvf9001cb0gi27c3g6gs","_id":"cll9ivvfa001hb0gi99n70a1i"},{"post_id":"cll9ivvf5000tb0gi0q50d8t0","tag_id":"cll9ivvfa001gb0gi09rch8co","_id":"cll9ivvfa001lb0gifxxf18ph"},{"post_id":"cll9ivvf7000zb0gi3sohhimr","tag_id":"cll9ivvfa001kb0gibjc4e3eg","_id":"cll9ivvfb001ob0gi4rg537d3"},{"post_id":"cll9ivvfc001vb0gi103z382u","tag_id":"cll9ivvf80014b0gib59q600w","_id":"cll9ivvfc001wb0gi4ywv37g7"}],"Tag":[{"name":"webrtc","_id":"cll9ivvex0004b0gi2lmc0cmk"},{"name":"工具","_id":"cll9ivvez0009b0gi6brqa3j1"},{"name":"vue2","_id":"cll9ivvf1000fb0gi2vd7714k"},{"name":"工作中问题","_id":"cll9ivvf7000xb0gian9nb0hq"},{"name":"js","_id":"cll9ivvf80014b0gib59q600w"},{"name":"环境搭建","_id":"cll9ivvf90018b0gi91xccb7i"},{"name":"报错集合","_id":"cll9ivvf9001cb0gi27c3g6gs"},{"name":"DevOps","_id":"cll9ivvfa001gb0gi09rch8co"},{"name":"Java","_id":"cll9ivvfa001kb0gibjc4e3eg"}]}}